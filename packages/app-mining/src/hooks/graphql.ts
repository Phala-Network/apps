/* eslint-disable */
/* This file is generated by graphql-codegen, don't edit it directly. */
import { GraphQLClient } from 'graphql-request';
import { RequestInit } from 'graphql-request/dist/types.dom';
import { useQuery, UseQueryOptions } from 'react-query';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

function fetcher<TData, TVariables>(client: GraphQLClient, query: string, variables?: TVariables, headers?: RequestInit['headers']) {
  return async (): Promise<TData> => client.request<TData, TVariables>(query, variables, headers);
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** The `BigInt` scalar type represents non-fractional signed whole numeric values. */
  BigInt: string;
  /** The javascript `Date` as string. Type represents date and time as the ISO Date string. */
  DateTime: any;
  /** GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library. */
  Decimal: string;
};

export type Accounts = {
  __typename?: 'Accounts';
  _count?: Maybe<AccountsCount>;
  address?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['BigInt'];
  identity?: Maybe<Scalars['String']>;
  identityVerified: Scalars['Boolean'];
  stakePoolStakers: Array<StakePoolStakers>;
  stakePoolWithdrawals: Array<StakePoolWithdrawals>;
  stakePools: Array<StakePools>;
  updatedAt: Scalars['DateTime'];
  workerActivities: Array<WorkerActivities>;
  workers: Array<Workers>;
};


export type AccountsStakePoolStakersArgs = {
  cursor?: InputMaybe<StakePoolStakersWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type AccountsStakePoolWithdrawalsArgs = {
  cursor?: InputMaybe<StakePoolWithdrawalsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolWithdrawalsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type AccountsStakePoolsArgs = {
  cursor?: InputMaybe<StakePoolsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolsWhereInput>;
};


export type AccountsWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type AccountsWorkersArgs = {
  cursor?: InputMaybe<WorkersWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};

export type AccountsAvgAggregate = {
  __typename?: 'AccountsAvgAggregate';
  id?: Maybe<Scalars['Float']>;
};

export type AccountsAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
};

export type AccountsCount = {
  __typename?: 'AccountsCount';
  stakePoolStakers: Scalars['Int'];
  stakePoolWithdrawals: Scalars['Int'];
  stakePools: Scalars['Int'];
  workerActivities: Scalars['Int'];
  workers: Scalars['Int'];
};

export type AccountsCountAggregate = {
  __typename?: 'AccountsCountAggregate';
  _all: Scalars['Int'];
  address: Scalars['Int'];
  createdAt: Scalars['Int'];
  id: Scalars['Int'];
  identity: Scalars['Int'];
  identityVerified: Scalars['Int'];
  updatedAt: Scalars['Int'];
};

export type AccountsCountOrderByAggregateInput = {
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identity?: InputMaybe<SortOrder>;
  identityVerified?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AccountsCreateInput = {
  address?: InputMaybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  identity?: InputMaybe<Scalars['String']>;
  identityVerified?: InputMaybe<Scalars['Boolean']>;
  stakePoolStakers?: InputMaybe<StakePoolStakersCreateNestedManyWithoutAccountsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutAccountsInput>;
  stakePools?: InputMaybe<StakePoolsCreateNestedManyWithoutAccountsInput>;
  updatedAt: Scalars['DateTime'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutAccountsInput>;
  workers?: InputMaybe<WorkersCreateNestedManyWithoutAccountsInput>;
};

export type AccountsCreateManyInput = {
  address?: InputMaybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  identity?: InputMaybe<Scalars['String']>;
  identityVerified?: InputMaybe<Scalars['Boolean']>;
  updatedAt: Scalars['DateTime'];
};

export type AccountsCreateNestedOneWithoutStakePoolStakersInput = {
  connect?: InputMaybe<AccountsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AccountsCreateOrConnectWithoutStakePoolStakersInput>;
  create?: InputMaybe<AccountsCreateWithoutStakePoolStakersInput>;
};

export type AccountsCreateNestedOneWithoutStakePoolWithdrawalsInput = {
  connect?: InputMaybe<AccountsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AccountsCreateOrConnectWithoutStakePoolWithdrawalsInput>;
  create?: InputMaybe<AccountsCreateWithoutStakePoolWithdrawalsInput>;
};

export type AccountsCreateNestedOneWithoutStakePoolsInput = {
  connect?: InputMaybe<AccountsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AccountsCreateOrConnectWithoutStakePoolsInput>;
  create?: InputMaybe<AccountsCreateWithoutStakePoolsInput>;
};

export type AccountsCreateNestedOneWithoutWorkerActivitiesInput = {
  connect?: InputMaybe<AccountsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AccountsCreateOrConnectWithoutWorkerActivitiesInput>;
  create?: InputMaybe<AccountsCreateWithoutWorkerActivitiesInput>;
};

export type AccountsCreateNestedOneWithoutWorkersInput = {
  connect?: InputMaybe<AccountsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AccountsCreateOrConnectWithoutWorkersInput>;
  create?: InputMaybe<AccountsCreateWithoutWorkersInput>;
};

export type AccountsCreateOrConnectWithoutStakePoolStakersInput = {
  create: AccountsCreateWithoutStakePoolStakersInput;
  where: AccountsWhereUniqueInput;
};

export type AccountsCreateOrConnectWithoutStakePoolWithdrawalsInput = {
  create: AccountsCreateWithoutStakePoolWithdrawalsInput;
  where: AccountsWhereUniqueInput;
};

export type AccountsCreateOrConnectWithoutStakePoolsInput = {
  create: AccountsCreateWithoutStakePoolsInput;
  where: AccountsWhereUniqueInput;
};

export type AccountsCreateOrConnectWithoutWorkerActivitiesInput = {
  create: AccountsCreateWithoutWorkerActivitiesInput;
  where: AccountsWhereUniqueInput;
};

export type AccountsCreateOrConnectWithoutWorkersInput = {
  create: AccountsCreateWithoutWorkersInput;
  where: AccountsWhereUniqueInput;
};

export type AccountsCreateWithoutStakePoolStakersInput = {
  address?: InputMaybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  identity?: InputMaybe<Scalars['String']>;
  identityVerified?: InputMaybe<Scalars['Boolean']>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutAccountsInput>;
  stakePools?: InputMaybe<StakePoolsCreateNestedManyWithoutAccountsInput>;
  updatedAt: Scalars['DateTime'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutAccountsInput>;
  workers?: InputMaybe<WorkersCreateNestedManyWithoutAccountsInput>;
};

export type AccountsCreateWithoutStakePoolWithdrawalsInput = {
  address?: InputMaybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  identity?: InputMaybe<Scalars['String']>;
  identityVerified?: InputMaybe<Scalars['Boolean']>;
  stakePoolStakers?: InputMaybe<StakePoolStakersCreateNestedManyWithoutAccountsInput>;
  stakePools?: InputMaybe<StakePoolsCreateNestedManyWithoutAccountsInput>;
  updatedAt: Scalars['DateTime'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutAccountsInput>;
  workers?: InputMaybe<WorkersCreateNestedManyWithoutAccountsInput>;
};

export type AccountsCreateWithoutStakePoolsInput = {
  address?: InputMaybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  identity?: InputMaybe<Scalars['String']>;
  identityVerified?: InputMaybe<Scalars['Boolean']>;
  stakePoolStakers?: InputMaybe<StakePoolStakersCreateNestedManyWithoutAccountsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutAccountsInput>;
  updatedAt: Scalars['DateTime'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutAccountsInput>;
  workers?: InputMaybe<WorkersCreateNestedManyWithoutAccountsInput>;
};

export type AccountsCreateWithoutWorkerActivitiesInput = {
  address?: InputMaybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  identity?: InputMaybe<Scalars['String']>;
  identityVerified?: InputMaybe<Scalars['Boolean']>;
  stakePoolStakers?: InputMaybe<StakePoolStakersCreateNestedManyWithoutAccountsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutAccountsInput>;
  stakePools?: InputMaybe<StakePoolsCreateNestedManyWithoutAccountsInput>;
  updatedAt: Scalars['DateTime'];
  workers?: InputMaybe<WorkersCreateNestedManyWithoutAccountsInput>;
};

export type AccountsCreateWithoutWorkersInput = {
  address?: InputMaybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  identity?: InputMaybe<Scalars['String']>;
  identityVerified?: InputMaybe<Scalars['Boolean']>;
  stakePoolStakers?: InputMaybe<StakePoolStakersCreateNestedManyWithoutAccountsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutAccountsInput>;
  stakePools?: InputMaybe<StakePoolsCreateNestedManyWithoutAccountsInput>;
  updatedAt: Scalars['DateTime'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutAccountsInput>;
};

export type AccountsGroupBy = {
  __typename?: 'AccountsGroupBy';
  _avg?: Maybe<AccountsAvgAggregate>;
  _count?: Maybe<AccountsCountAggregate>;
  _max?: Maybe<AccountsMaxAggregate>;
  _min?: Maybe<AccountsMinAggregate>;
  _sum?: Maybe<AccountsSumAggregate>;
  address?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['BigInt'];
  identity?: Maybe<Scalars['String']>;
  identityVerified: Scalars['Boolean'];
  updatedAt: Scalars['DateTime'];
};

export type AccountsMaxAggregate = {
  __typename?: 'AccountsMaxAggregate';
  address?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  identity?: Maybe<Scalars['String']>;
  identityVerified?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AccountsMaxOrderByAggregateInput = {
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identity?: InputMaybe<SortOrder>;
  identityVerified?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AccountsMinAggregate = {
  __typename?: 'AccountsMinAggregate';
  address?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  identity?: Maybe<Scalars['String']>;
  identityVerified?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AccountsMinOrderByAggregateInput = {
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identity?: InputMaybe<SortOrder>;
  identityVerified?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AccountsOrderByWithAggregationInput = {
  _avg?: InputMaybe<AccountsAvgOrderByAggregateInput>;
  _count?: InputMaybe<AccountsCountOrderByAggregateInput>;
  _max?: InputMaybe<AccountsMaxOrderByAggregateInput>;
  _min?: InputMaybe<AccountsMinOrderByAggregateInput>;
  _sum?: InputMaybe<AccountsSumOrderByAggregateInput>;
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identity?: InputMaybe<SortOrder>;
  identityVerified?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AccountsOrderByWithRelationInput = {
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identity?: InputMaybe<SortOrder>;
  identityVerified?: InputMaybe<SortOrder>;
  stakePoolStakers?: InputMaybe<StakePoolStakersOrderByRelationAggregateInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsOrderByRelationAggregateInput>;
  stakePools?: InputMaybe<StakePoolsOrderByRelationAggregateInput>;
  updatedAt?: InputMaybe<SortOrder>;
  workerActivities?: InputMaybe<WorkerActivitiesOrderByRelationAggregateInput>;
  workers?: InputMaybe<WorkersOrderByRelationAggregateInput>;
};

export type AccountsRelationFilter = {
  is?: InputMaybe<AccountsWhereInput>;
  isNot?: InputMaybe<AccountsWhereInput>;
};

export enum AccountsScalarFieldEnum {
  Address = 'address',
  CreatedAt = 'createdAt',
  Id = 'id',
  Identity = 'identity',
  IdentityVerified = 'identityVerified',
  UpdatedAt = 'updatedAt'
}

export type AccountsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<AccountsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<AccountsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<AccountsScalarWhereWithAggregatesInput>>;
  address?: InputMaybe<StringNullableWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  identity?: InputMaybe<StringNullableWithAggregatesFilter>;
  identityVerified?: InputMaybe<BoolWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type AccountsSumAggregate = {
  __typename?: 'AccountsSumAggregate';
  id?: Maybe<Scalars['BigInt']>;
};

export type AccountsSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
};

export type AccountsUpdateInput = {
  address?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  identity?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  identityVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateManyWithoutAccountsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutAccountsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateManyWithoutAccountsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutAccountsInput>;
  workers?: InputMaybe<WorkersUpdateManyWithoutAccountsInput>;
};

export type AccountsUpdateManyMutationInput = {
  address?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  identity?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  identityVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type AccountsUpdateOneRequiredWithoutStakePoolStakersInput = {
  connect?: InputMaybe<AccountsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AccountsCreateOrConnectWithoutStakePoolStakersInput>;
  create?: InputMaybe<AccountsCreateWithoutStakePoolStakersInput>;
  update?: InputMaybe<AccountsUpdateWithoutStakePoolStakersInput>;
  upsert?: InputMaybe<AccountsUpsertWithoutStakePoolStakersInput>;
};

export type AccountsUpdateOneRequiredWithoutStakePoolWithdrawalsInput = {
  connect?: InputMaybe<AccountsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AccountsCreateOrConnectWithoutStakePoolWithdrawalsInput>;
  create?: InputMaybe<AccountsCreateWithoutStakePoolWithdrawalsInput>;
  update?: InputMaybe<AccountsUpdateWithoutStakePoolWithdrawalsInput>;
  upsert?: InputMaybe<AccountsUpsertWithoutStakePoolWithdrawalsInput>;
};

export type AccountsUpdateOneRequiredWithoutStakePoolsInput = {
  connect?: InputMaybe<AccountsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AccountsCreateOrConnectWithoutStakePoolsInput>;
  create?: InputMaybe<AccountsCreateWithoutStakePoolsInput>;
  update?: InputMaybe<AccountsUpdateWithoutStakePoolsInput>;
  upsert?: InputMaybe<AccountsUpsertWithoutStakePoolsInput>;
};

export type AccountsUpdateOneWithoutWorkerActivitiesInput = {
  connect?: InputMaybe<AccountsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AccountsCreateOrConnectWithoutWorkerActivitiesInput>;
  create?: InputMaybe<AccountsCreateWithoutWorkerActivitiesInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<AccountsUpdateWithoutWorkerActivitiesInput>;
  upsert?: InputMaybe<AccountsUpsertWithoutWorkerActivitiesInput>;
};

export type AccountsUpdateOneWithoutWorkersInput = {
  connect?: InputMaybe<AccountsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AccountsCreateOrConnectWithoutWorkersInput>;
  create?: InputMaybe<AccountsCreateWithoutWorkersInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<AccountsUpdateWithoutWorkersInput>;
  upsert?: InputMaybe<AccountsUpsertWithoutWorkersInput>;
};

export type AccountsUpdateWithoutStakePoolStakersInput = {
  address?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  identity?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  identityVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutAccountsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateManyWithoutAccountsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutAccountsInput>;
  workers?: InputMaybe<WorkersUpdateManyWithoutAccountsInput>;
};

export type AccountsUpdateWithoutStakePoolWithdrawalsInput = {
  address?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  identity?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  identityVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateManyWithoutAccountsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateManyWithoutAccountsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutAccountsInput>;
  workers?: InputMaybe<WorkersUpdateManyWithoutAccountsInput>;
};

export type AccountsUpdateWithoutStakePoolsInput = {
  address?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  identity?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  identityVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateManyWithoutAccountsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutAccountsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutAccountsInput>;
  workers?: InputMaybe<WorkersUpdateManyWithoutAccountsInput>;
};

export type AccountsUpdateWithoutWorkerActivitiesInput = {
  address?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  identity?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  identityVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateManyWithoutAccountsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutAccountsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateManyWithoutAccountsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workers?: InputMaybe<WorkersUpdateManyWithoutAccountsInput>;
};

export type AccountsUpdateWithoutWorkersInput = {
  address?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  identity?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  identityVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateManyWithoutAccountsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutAccountsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateManyWithoutAccountsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutAccountsInput>;
};

export type AccountsUpsertWithoutStakePoolStakersInput = {
  create: AccountsCreateWithoutStakePoolStakersInput;
  update: AccountsUpdateWithoutStakePoolStakersInput;
};

export type AccountsUpsertWithoutStakePoolWithdrawalsInput = {
  create: AccountsCreateWithoutStakePoolWithdrawalsInput;
  update: AccountsUpdateWithoutStakePoolWithdrawalsInput;
};

export type AccountsUpsertWithoutStakePoolsInput = {
  create: AccountsCreateWithoutStakePoolsInput;
  update: AccountsUpdateWithoutStakePoolsInput;
};

export type AccountsUpsertWithoutWorkerActivitiesInput = {
  create: AccountsCreateWithoutWorkerActivitiesInput;
  update: AccountsUpdateWithoutWorkerActivitiesInput;
};

export type AccountsUpsertWithoutWorkersInput = {
  create: AccountsCreateWithoutWorkersInput;
  update: AccountsUpdateWithoutWorkersInput;
};

export type AccountsWhereInput = {
  AND?: InputMaybe<Array<AccountsWhereInput>>;
  NOT?: InputMaybe<Array<AccountsWhereInput>>;
  OR?: InputMaybe<Array<AccountsWhereInput>>;
  address?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<BigIntFilter>;
  identity?: InputMaybe<StringNullableFilter>;
  identityVerified?: InputMaybe<BoolFilter>;
  stakePoolStakers?: InputMaybe<StakePoolStakersListRelationFilter>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsListRelationFilter>;
  stakePools?: InputMaybe<StakePoolsListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  workerActivities?: InputMaybe<WorkerActivitiesListRelationFilter>;
  workers?: InputMaybe<WorkersListRelationFilter>;
};

export type AccountsWhereUniqueInput = {
  address?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

export type AffectedRowsOutput = {
  __typename?: 'AffectedRowsOutput';
  count: Scalars['Int'];
};

export type AggregateAccounts = {
  __typename?: 'AggregateAccounts';
  _avg?: Maybe<AccountsAvgAggregate>;
  _count?: Maybe<AccountsCountAggregate>;
  _max?: Maybe<AccountsMaxAggregate>;
  _min?: Maybe<AccountsMinAggregate>;
  _sum?: Maybe<AccountsSumAggregate>;
};

export type AggregateArInternalMetadata = {
  __typename?: 'AggregateArInternalMetadata';
  _count?: Maybe<ArInternalMetadataCountAggregate>;
  _max?: Maybe<ArInternalMetadataMaxAggregate>;
  _min?: Maybe<ArInternalMetadataMinAggregate>;
};

export type AggregateEvents = {
  __typename?: 'AggregateEvents';
  _avg?: Maybe<EventsAvgAggregate>;
  _count?: Maybe<EventsCountAggregate>;
  _max?: Maybe<EventsMaxAggregate>;
  _min?: Maybe<EventsMinAggregate>;
  _sum?: Maybe<EventsSumAggregate>;
};

export type AggregateMinerActivities = {
  __typename?: 'AggregateMinerActivities';
  _avg?: Maybe<MinerActivitiesAvgAggregate>;
  _count?: Maybe<MinerActivitiesCountAggregate>;
  _max?: Maybe<MinerActivitiesMaxAggregate>;
  _min?: Maybe<MinerActivitiesMinAggregate>;
  _sum?: Maybe<MinerActivitiesSumAggregate>;
};

export type AggregateMiners = {
  __typename?: 'AggregateMiners';
  _avg?: Maybe<MinersAvgAggregate>;
  _count?: Maybe<MinersCountAggregate>;
  _max?: Maybe<MinersMaxAggregate>;
  _min?: Maybe<MinersMinAggregate>;
  _sum?: Maybe<MinersSumAggregate>;
};

export type AggregateSchemaMigrations = {
  __typename?: 'AggregateSchemaMigrations';
  _count?: Maybe<SchemaMigrationsCountAggregate>;
  _max?: Maybe<SchemaMigrationsMaxAggregate>;
  _min?: Maybe<SchemaMigrationsMinAggregate>;
};

export type AggregateStakePoolActivities = {
  __typename?: 'AggregateStakePoolActivities';
  _avg?: Maybe<StakePoolActivitiesAvgAggregate>;
  _count?: Maybe<StakePoolActivitiesCountAggregate>;
  _max?: Maybe<StakePoolActivitiesMaxAggregate>;
  _min?: Maybe<StakePoolActivitiesMinAggregate>;
  _sum?: Maybe<StakePoolActivitiesSumAggregate>;
};

export type AggregateStakePoolStakerActivities = {
  __typename?: 'AggregateStakePoolStakerActivities';
  _avg?: Maybe<StakePoolStakerActivitiesAvgAggregate>;
  _count?: Maybe<StakePoolStakerActivitiesCountAggregate>;
  _max?: Maybe<StakePoolStakerActivitiesMaxAggregate>;
  _min?: Maybe<StakePoolStakerActivitiesMinAggregate>;
  _sum?: Maybe<StakePoolStakerActivitiesSumAggregate>;
};

export type AggregateStakePoolStakers = {
  __typename?: 'AggregateStakePoolStakers';
  _avg?: Maybe<StakePoolStakersAvgAggregate>;
  _count?: Maybe<StakePoolStakersCountAggregate>;
  _max?: Maybe<StakePoolStakersMaxAggregate>;
  _min?: Maybe<StakePoolStakersMinAggregate>;
  _sum?: Maybe<StakePoolStakersSumAggregate>;
};

export type AggregateStakePoolWithdrawals = {
  __typename?: 'AggregateStakePoolWithdrawals';
  _avg?: Maybe<StakePoolWithdrawalsAvgAggregate>;
  _count?: Maybe<StakePoolWithdrawalsCountAggregate>;
  _max?: Maybe<StakePoolWithdrawalsMaxAggregate>;
  _min?: Maybe<StakePoolWithdrawalsMinAggregate>;
  _sum?: Maybe<StakePoolWithdrawalsSumAggregate>;
};

export type AggregateStakePools = {
  __typename?: 'AggregateStakePools';
  _avg?: Maybe<StakePoolsAvgAggregate>;
  _count?: Maybe<StakePoolsCountAggregate>;
  _max?: Maybe<StakePoolsMaxAggregate>;
  _min?: Maybe<StakePoolsMinAggregate>;
  _sum?: Maybe<StakePoolsSumAggregate>;
};

export type AggregateStates = {
  __typename?: 'AggregateStates';
  _avg?: Maybe<StatesAvgAggregate>;
  _count?: Maybe<StatesCountAggregate>;
  _max?: Maybe<StatesMaxAggregate>;
  _min?: Maybe<StatesMinAggregate>;
  _sum?: Maybe<StatesSumAggregate>;
};

export type AggregateWorkerActivities = {
  __typename?: 'AggregateWorkerActivities';
  _avg?: Maybe<WorkerActivitiesAvgAggregate>;
  _count?: Maybe<WorkerActivitiesCountAggregate>;
  _max?: Maybe<WorkerActivitiesMaxAggregate>;
  _min?: Maybe<WorkerActivitiesMinAggregate>;
  _sum?: Maybe<WorkerActivitiesSumAggregate>;
};

export type AggregateWorkers = {
  __typename?: 'AggregateWorkers';
  _avg?: Maybe<WorkersAvgAggregate>;
  _count?: Maybe<WorkersCountAggregate>;
  _max?: Maybe<WorkersMaxAggregate>;
  _min?: Maybe<WorkersMinAggregate>;
  _sum?: Maybe<WorkersSumAggregate>;
};

export type ArInternalMetadata = {
  __typename?: 'ArInternalMetadata';
  createdAt: Scalars['DateTime'];
  key: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
};

export type ArInternalMetadataCountAggregate = {
  __typename?: 'ArInternalMetadataCountAggregate';
  _all: Scalars['Int'];
  createdAt: Scalars['Int'];
  key: Scalars['Int'];
  updatedAt: Scalars['Int'];
  value: Scalars['Int'];
};

export type ArInternalMetadataCountOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ArInternalMetadataCreateInput = {
  createdAt: Scalars['DateTime'];
  key: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  value?: InputMaybe<Scalars['String']>;
};

export type ArInternalMetadataCreateManyInput = {
  createdAt: Scalars['DateTime'];
  key: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  value?: InputMaybe<Scalars['String']>;
};

export type ArInternalMetadataGroupBy = {
  __typename?: 'ArInternalMetadataGroupBy';
  _count?: Maybe<ArInternalMetadataCountAggregate>;
  _max?: Maybe<ArInternalMetadataMaxAggregate>;
  _min?: Maybe<ArInternalMetadataMinAggregate>;
  createdAt: Scalars['DateTime'];
  key: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
};

export type ArInternalMetadataMaxAggregate = {
  __typename?: 'ArInternalMetadataMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']>;
  key?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  value?: Maybe<Scalars['String']>;
};

export type ArInternalMetadataMaxOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ArInternalMetadataMinAggregate = {
  __typename?: 'ArInternalMetadataMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']>;
  key?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  value?: Maybe<Scalars['String']>;
};

export type ArInternalMetadataMinOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ArInternalMetadataOrderByWithAggregationInput = {
  _count?: InputMaybe<ArInternalMetadataCountOrderByAggregateInput>;
  _max?: InputMaybe<ArInternalMetadataMaxOrderByAggregateInput>;
  _min?: InputMaybe<ArInternalMetadataMinOrderByAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ArInternalMetadataOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum ArInternalMetadataScalarFieldEnum {
  CreatedAt = 'createdAt',
  Key = 'key',
  UpdatedAt = 'updatedAt',
  Value = 'value'
}

export type ArInternalMetadataScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ArInternalMetadataScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ArInternalMetadataScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ArInternalMetadataScalarWhereWithAggregatesInput>>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  key?: InputMaybe<StringWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  value?: InputMaybe<StringNullableWithAggregatesFilter>;
};

export type ArInternalMetadataUpdateInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  key?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  value?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type ArInternalMetadataUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  key?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  value?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type ArInternalMetadataWhereInput = {
  AND?: InputMaybe<Array<ArInternalMetadataWhereInput>>;
  NOT?: InputMaybe<Array<ArInternalMetadataWhereInput>>;
  OR?: InputMaybe<Array<ArInternalMetadataWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  key?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  value?: InputMaybe<StringNullableFilter>;
};

export type ArInternalMetadataWhereUniqueInput = {
  key?: InputMaybe<Scalars['String']>;
};

export type BigIntFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['BigInt']>;
  divide?: InputMaybe<Scalars['BigInt']>;
  increment?: InputMaybe<Scalars['BigInt']>;
  multiply?: InputMaybe<Scalars['BigInt']>;
  set?: InputMaybe<Scalars['BigInt']>;
};

export type BigIntFilter = {
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type BigIntNullableFilter = {
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type BigIntNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedBigIntNullableFilter>;
  _min?: InputMaybe<NestedBigIntNullableFilter>;
  _sum?: InputMaybe<NestedBigIntNullableFilter>;
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type BigIntWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBigIntFilter>;
  _min?: InputMaybe<NestedBigIntFilter>;
  _sum?: InputMaybe<NestedBigIntFilter>;
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type BoolFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['Boolean']>;
};

export type BoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type BoolNullableFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolNullableFilter>;
};

export type BoolNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedBoolNullableFilter>;
  _min?: InputMaybe<NestedBoolNullableFilter>;
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolNullableWithAggregatesFilter>;
};

export type BoolWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBoolFilter>;
  _min?: InputMaybe<NestedBoolFilter>;
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolWithAggregatesFilter>;
};

export type DateTimeFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['DateTime']>;
};

export type DateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type DateTimeNullableFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type DateTimeNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDateTimeNullableFilter>;
  _min?: InputMaybe<NestedDateTimeNullableFilter>;
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type DateTimeWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedDateTimeFilter>;
  _min?: InputMaybe<NestedDateTimeFilter>;
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type DecimalFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Decimal']>;
  divide?: InputMaybe<Scalars['Decimal']>;
  increment?: InputMaybe<Scalars['Decimal']>;
  multiply?: InputMaybe<Scalars['Decimal']>;
  set?: InputMaybe<Scalars['Decimal']>;
};

export type DecimalFilter = {
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type DecimalNullableFilter = {
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type DecimalNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedDecimalNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDecimalNullableFilter>;
  _min?: InputMaybe<NestedDecimalNullableFilter>;
  _sum?: InputMaybe<NestedDecimalNullableFilter>;
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type DecimalWithAggregatesFilter = {
  _avg?: InputMaybe<NestedDecimalFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedDecimalFilter>;
  _min?: InputMaybe<NestedDecimalFilter>;
  _sum?: InputMaybe<NestedDecimalFilter>;
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type Events = {
  __typename?: 'Events';
  _count?: Maybe<EventsCount>;
  blockNumber: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['DateTime']>;
  data?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  minerActivities: Array<MinerActivities>;
  name: Scalars['String'];
  note?: Maybe<Scalars['String']>;
  processedAt?: Maybe<Scalars['DateTime']>;
  section: Scalars['String'];
  skipped: Scalars['Boolean'];
  stakePoolActivities: Array<StakePoolActivities>;
  stakePoolStakerActivities: Array<StakePoolStakerActivities>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds: Array<StakePoolWithdrawals>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds: Array<StakePoolWithdrawals>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  workerActivities: Array<WorkerActivities>;
};


export type EventsMinerActivitiesArgs = {
  cursor?: InputMaybe<MinerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type EventsStakePoolActivitiesArgs = {
  cursor?: InputMaybe<StakePoolActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type EventsStakePoolStakerActivitiesArgs = {
  cursor?: InputMaybe<StakePoolStakerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};


export type EventsStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsArgs = {
  cursor?: InputMaybe<StakePoolWithdrawalsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolWithdrawalsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type EventsStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsArgs = {
  cursor?: InputMaybe<StakePoolWithdrawalsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolWithdrawalsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type EventsWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};

export type EventsAvgAggregate = {
  __typename?: 'EventsAvgAggregate';
  blockNumber?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  tokenomicVersion?: Maybe<Scalars['Float']>;
};

export type EventsAvgOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
};

export type EventsCount = {
  __typename?: 'EventsCount';
  minerActivities: Scalars['Int'];
  stakePoolActivities: Scalars['Int'];
  stakePoolStakerActivities: Scalars['Int'];
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds: Scalars['Int'];
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds: Scalars['Int'];
  workerActivities: Scalars['Int'];
};

export type EventsCountAggregate = {
  __typename?: 'EventsCountAggregate';
  _all: Scalars['Int'];
  blockNumber: Scalars['Int'];
  createdAt: Scalars['Int'];
  data: Scalars['Int'];
  id: Scalars['Int'];
  name: Scalars['Int'];
  note: Scalars['Int'];
  processedAt: Scalars['Int'];
  section: Scalars['Int'];
  skipped: Scalars['Int'];
  timestamp: Scalars['Int'];
  tokenomicVersion: Scalars['Int'];
};

export type EventsCountOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  data?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  note?: InputMaybe<SortOrder>;
  processedAt?: InputMaybe<SortOrder>;
  section?: InputMaybe<SortOrder>;
  skipped?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
};

export type EventsCreateInput = {
  blockNumber: Scalars['BigInt'];
  createdAt?: InputMaybe<Scalars['DateTime']>;
  data?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  minerActivities?: InputMaybe<MinerActivitiesCreateNestedManyWithoutEventsInput>;
  name: Scalars['String'];
  note?: InputMaybe<Scalars['String']>;
  processedAt?: InputMaybe<Scalars['DateTime']>;
  section: Scalars['String'];
  skipped?: InputMaybe<Scalars['Boolean']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutEventsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesCreateNestedManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutEventsInput>;
};

export type EventsCreateManyInput = {
  blockNumber: Scalars['BigInt'];
  createdAt?: InputMaybe<Scalars['DateTime']>;
  data?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  name: Scalars['String'];
  note?: InputMaybe<Scalars['String']>;
  processedAt?: InputMaybe<Scalars['DateTime']>;
  section: Scalars['String'];
  skipped?: InputMaybe<Scalars['Boolean']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
};

export type EventsCreateNestedOneWithoutMinerActivitiesInput = {
  connect?: InputMaybe<EventsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EventsCreateOrConnectWithoutMinerActivitiesInput>;
  create?: InputMaybe<EventsCreateWithoutMinerActivitiesInput>;
};

export type EventsCreateNestedOneWithoutStakePoolActivitiesInput = {
  connect?: InputMaybe<EventsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EventsCreateOrConnectWithoutStakePoolActivitiesInput>;
  create?: InputMaybe<EventsCreateWithoutStakePoolActivitiesInput>;
};

export type EventsCreateNestedOneWithoutStakePoolStakerActivitiesInput = {
  connect?: InputMaybe<EventsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EventsCreateOrConnectWithoutStakePoolStakerActivitiesInput>;
  create?: InputMaybe<EventsCreateWithoutStakePoolStakerActivitiesInput>;
};

export type EventsCreateNestedOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput = {
  connect?: InputMaybe<EventsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EventsCreateOrConnectWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
  create?: InputMaybe<EventsCreateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
};

export type EventsCreateNestedOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput = {
  connect?: InputMaybe<EventsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EventsCreateOrConnectWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
  create?: InputMaybe<EventsCreateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
};

export type EventsCreateNestedOneWithoutWorkerActivitiesInput = {
  connect?: InputMaybe<EventsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EventsCreateOrConnectWithoutWorkerActivitiesInput>;
  create?: InputMaybe<EventsCreateWithoutWorkerActivitiesInput>;
};

export type EventsCreateOrConnectWithoutMinerActivitiesInput = {
  create: EventsCreateWithoutMinerActivitiesInput;
  where: EventsWhereUniqueInput;
};

export type EventsCreateOrConnectWithoutStakePoolActivitiesInput = {
  create: EventsCreateWithoutStakePoolActivitiesInput;
  where: EventsWhereUniqueInput;
};

export type EventsCreateOrConnectWithoutStakePoolStakerActivitiesInput = {
  create: EventsCreateWithoutStakePoolStakerActivitiesInput;
  where: EventsWhereUniqueInput;
};

export type EventsCreateOrConnectWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput = {
  create: EventsCreateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput;
  where: EventsWhereUniqueInput;
};

export type EventsCreateOrConnectWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput = {
  create: EventsCreateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput;
  where: EventsWhereUniqueInput;
};

export type EventsCreateOrConnectWithoutWorkerActivitiesInput = {
  create: EventsCreateWithoutWorkerActivitiesInput;
  where: EventsWhereUniqueInput;
};

export type EventsCreateWithoutMinerActivitiesInput = {
  blockNumber: Scalars['BigInt'];
  createdAt?: InputMaybe<Scalars['DateTime']>;
  data?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  name: Scalars['String'];
  note?: InputMaybe<Scalars['String']>;
  processedAt?: InputMaybe<Scalars['DateTime']>;
  section: Scalars['String'];
  skipped?: InputMaybe<Scalars['Boolean']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutEventsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesCreateNestedManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutEventsInput>;
};

export type EventsCreateWithoutStakePoolActivitiesInput = {
  blockNumber: Scalars['BigInt'];
  createdAt?: InputMaybe<Scalars['DateTime']>;
  data?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  minerActivities?: InputMaybe<MinerActivitiesCreateNestedManyWithoutEventsInput>;
  name: Scalars['String'];
  note?: InputMaybe<Scalars['String']>;
  processedAt?: InputMaybe<Scalars['DateTime']>;
  section: Scalars['String'];
  skipped?: InputMaybe<Scalars['Boolean']>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesCreateNestedManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutEventsInput>;
};

export type EventsCreateWithoutStakePoolStakerActivitiesInput = {
  blockNumber: Scalars['BigInt'];
  createdAt?: InputMaybe<Scalars['DateTime']>;
  data?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  minerActivities?: InputMaybe<MinerActivitiesCreateNestedManyWithoutEventsInput>;
  name: Scalars['String'];
  note?: InputMaybe<Scalars['String']>;
  processedAt?: InputMaybe<Scalars['DateTime']>;
  section: Scalars['String'];
  skipped?: InputMaybe<Scalars['Boolean']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutEventsInput>;
};

export type EventsCreateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput = {
  blockNumber: Scalars['BigInt'];
  createdAt?: InputMaybe<Scalars['DateTime']>;
  data?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  minerActivities?: InputMaybe<MinerActivitiesCreateNestedManyWithoutEventsInput>;
  name: Scalars['String'];
  note?: InputMaybe<Scalars['String']>;
  processedAt?: InputMaybe<Scalars['DateTime']>;
  section: Scalars['String'];
  skipped?: InputMaybe<Scalars['Boolean']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutEventsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesCreateNestedManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutEventsInput>;
};

export type EventsCreateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput = {
  blockNumber: Scalars['BigInt'];
  createdAt?: InputMaybe<Scalars['DateTime']>;
  data?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  minerActivities?: InputMaybe<MinerActivitiesCreateNestedManyWithoutEventsInput>;
  name: Scalars['String'];
  note?: InputMaybe<Scalars['String']>;
  processedAt?: InputMaybe<Scalars['DateTime']>;
  section: Scalars['String'];
  skipped?: InputMaybe<Scalars['Boolean']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutEventsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesCreateNestedManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutEventsInput>;
};

export type EventsCreateWithoutWorkerActivitiesInput = {
  blockNumber: Scalars['BigInt'];
  createdAt?: InputMaybe<Scalars['DateTime']>;
  data?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  minerActivities?: InputMaybe<MinerActivitiesCreateNestedManyWithoutEventsInput>;
  name: Scalars['String'];
  note?: InputMaybe<Scalars['String']>;
  processedAt?: InputMaybe<Scalars['DateTime']>;
  section: Scalars['String'];
  skipped?: InputMaybe<Scalars['Boolean']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutEventsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesCreateNestedManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
};

export type EventsGroupBy = {
  __typename?: 'EventsGroupBy';
  _avg?: Maybe<EventsAvgAggregate>;
  _count?: Maybe<EventsCountAggregate>;
  _max?: Maybe<EventsMaxAggregate>;
  _min?: Maybe<EventsMinAggregate>;
  _sum?: Maybe<EventsSumAggregate>;
  blockNumber: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['DateTime']>;
  data?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  name: Scalars['String'];
  note?: Maybe<Scalars['String']>;
  processedAt?: Maybe<Scalars['DateTime']>;
  section: Scalars['String'];
  skipped: Scalars['Boolean'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
};

export type EventsMaxAggregate = {
  __typename?: 'EventsMaxAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  data?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['BigInt']>;
  name?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  processedAt?: Maybe<Scalars['DateTime']>;
  section?: Maybe<Scalars['String']>;
  skipped?: Maybe<Scalars['Boolean']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
};

export type EventsMaxOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  data?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  note?: InputMaybe<SortOrder>;
  processedAt?: InputMaybe<SortOrder>;
  section?: InputMaybe<SortOrder>;
  skipped?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
};

export type EventsMinAggregate = {
  __typename?: 'EventsMinAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  data?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['BigInt']>;
  name?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  processedAt?: Maybe<Scalars['DateTime']>;
  section?: Maybe<Scalars['String']>;
  skipped?: Maybe<Scalars['Boolean']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
};

export type EventsMinOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  data?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  note?: InputMaybe<SortOrder>;
  processedAt?: InputMaybe<SortOrder>;
  section?: InputMaybe<SortOrder>;
  skipped?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
};

export type EventsOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventsAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventsCountOrderByAggregateInput>;
  _max?: InputMaybe<EventsMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventsMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventsSumOrderByAggregateInput>;
  blockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  data?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  note?: InputMaybe<SortOrder>;
  processedAt?: InputMaybe<SortOrder>;
  section?: InputMaybe<SortOrder>;
  skipped?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
};

export type EventsOrderByWithRelationInput = {
  blockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  data?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  minerActivities?: InputMaybe<MinerActivitiesOrderByRelationAggregateInput>;
  name?: InputMaybe<SortOrder>;
  note?: InputMaybe<SortOrder>;
  processedAt?: InputMaybe<SortOrder>;
  section?: InputMaybe<SortOrder>;
  skipped?: InputMaybe<SortOrder>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesOrderByRelationAggregateInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesOrderByRelationAggregateInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsOrderByRelationAggregateInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsOrderByRelationAggregateInput>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  workerActivities?: InputMaybe<WorkerActivitiesOrderByRelationAggregateInput>;
};

export type EventsRelationFilter = {
  is?: InputMaybe<EventsWhereInput>;
  isNot?: InputMaybe<EventsWhereInput>;
};

export enum EventsScalarFieldEnum {
  BlockNumber = 'blockNumber',
  CreatedAt = 'createdAt',
  Data = 'data',
  Id = 'id',
  Name = 'name',
  Note = 'note',
  ProcessedAt = 'processedAt',
  Section = 'section',
  Skipped = 'skipped',
  Timestamp = 'timestamp',
  TokenomicVersion = 'tokenomicVersion'
}

export type EventsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventsScalarWhereWithAggregatesInput>>;
  blockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  data?: InputMaybe<StringNullableWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
  note?: InputMaybe<StringNullableWithAggregatesFilter>;
  processedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  section?: InputMaybe<StringWithAggregatesFilter>;
  skipped?: InputMaybe<BoolWithAggregatesFilter>;
  timestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  tokenomicVersion?: InputMaybe<IntWithAggregatesFilter>;
};

export type EventsSumAggregate = {
  __typename?: 'EventsSumAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
};

export type EventsSumOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
};

export type EventsUpdateInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  data?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  minerActivities?: InputMaybe<MinerActivitiesUpdateManyWithoutEventsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  note?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  processedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  section?: InputMaybe<StringFieldUpdateOperationsInput>;
  skipped?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutEventsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesUpdateManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutEventsInput>;
};

export type EventsUpdateManyMutationInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  data?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  note?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  processedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  section?: InputMaybe<StringFieldUpdateOperationsInput>;
  skipped?: InputMaybe<BoolFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type EventsUpdateOneWithoutMinerActivitiesInput = {
  connect?: InputMaybe<EventsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EventsCreateOrConnectWithoutMinerActivitiesInput>;
  create?: InputMaybe<EventsCreateWithoutMinerActivitiesInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<EventsUpdateWithoutMinerActivitiesInput>;
  upsert?: InputMaybe<EventsUpsertWithoutMinerActivitiesInput>;
};

export type EventsUpdateOneWithoutStakePoolActivitiesInput = {
  connect?: InputMaybe<EventsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EventsCreateOrConnectWithoutStakePoolActivitiesInput>;
  create?: InputMaybe<EventsCreateWithoutStakePoolActivitiesInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<EventsUpdateWithoutStakePoolActivitiesInput>;
  upsert?: InputMaybe<EventsUpsertWithoutStakePoolActivitiesInput>;
};

export type EventsUpdateOneWithoutStakePoolStakerActivitiesInput = {
  connect?: InputMaybe<EventsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EventsCreateOrConnectWithoutStakePoolStakerActivitiesInput>;
  create?: InputMaybe<EventsCreateWithoutStakePoolStakerActivitiesInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<EventsUpdateWithoutStakePoolStakerActivitiesInput>;
  upsert?: InputMaybe<EventsUpsertWithoutStakePoolStakerActivitiesInput>;
};

export type EventsUpdateOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput = {
  connect?: InputMaybe<EventsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EventsCreateOrConnectWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
  create?: InputMaybe<EventsCreateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<EventsUpdateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
  upsert?: InputMaybe<EventsUpsertWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
};

export type EventsUpdateOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput = {
  connect?: InputMaybe<EventsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EventsCreateOrConnectWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
  create?: InputMaybe<EventsCreateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<EventsUpdateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
  upsert?: InputMaybe<EventsUpsertWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
};

export type EventsUpdateOneWithoutWorkerActivitiesInput = {
  connect?: InputMaybe<EventsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EventsCreateOrConnectWithoutWorkerActivitiesInput>;
  create?: InputMaybe<EventsCreateWithoutWorkerActivitiesInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<EventsUpdateWithoutWorkerActivitiesInput>;
  upsert?: InputMaybe<EventsUpsertWithoutWorkerActivitiesInput>;
};

export type EventsUpdateWithoutMinerActivitiesInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  data?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  note?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  processedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  section?: InputMaybe<StringFieldUpdateOperationsInput>;
  skipped?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutEventsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesUpdateManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutEventsInput>;
};

export type EventsUpdateWithoutStakePoolActivitiesInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  data?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  minerActivities?: InputMaybe<MinerActivitiesUpdateManyWithoutEventsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  note?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  processedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  section?: InputMaybe<StringFieldUpdateOperationsInput>;
  skipped?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesUpdateManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutEventsInput>;
};

export type EventsUpdateWithoutStakePoolStakerActivitiesInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  data?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  minerActivities?: InputMaybe<MinerActivitiesUpdateManyWithoutEventsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  note?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  processedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  section?: InputMaybe<StringFieldUpdateOperationsInput>;
  skipped?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutEventsInput>;
};

export type EventsUpdateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  data?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  minerActivities?: InputMaybe<MinerActivitiesUpdateManyWithoutEventsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  note?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  processedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  section?: InputMaybe<StringFieldUpdateOperationsInput>;
  skipped?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutEventsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesUpdateManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutEventsInput>;
};

export type EventsUpdateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  data?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  minerActivities?: InputMaybe<MinerActivitiesUpdateManyWithoutEventsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  note?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  processedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  section?: InputMaybe<StringFieldUpdateOperationsInput>;
  skipped?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutEventsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesUpdateManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutEventsInput>;
};

export type EventsUpdateWithoutWorkerActivitiesInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  data?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  minerActivities?: InputMaybe<MinerActivitiesUpdateManyWithoutEventsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  note?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  processedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  section?: InputMaybe<StringFieldUpdateOperationsInput>;
  skipped?: InputMaybe<BoolFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutEventsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesUpdateManyWithoutEventsInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type EventsUpsertWithoutMinerActivitiesInput = {
  create: EventsCreateWithoutMinerActivitiesInput;
  update: EventsUpdateWithoutMinerActivitiesInput;
};

export type EventsUpsertWithoutStakePoolActivitiesInput = {
  create: EventsCreateWithoutStakePoolActivitiesInput;
  update: EventsUpdateWithoutStakePoolActivitiesInput;
};

export type EventsUpsertWithoutStakePoolStakerActivitiesInput = {
  create: EventsCreateWithoutStakePoolStakerActivitiesInput;
  update: EventsUpdateWithoutStakePoolStakerActivitiesInput;
};

export type EventsUpsertWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput = {
  create: EventsCreateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput;
  update: EventsUpdateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput;
};

export type EventsUpsertWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput = {
  create: EventsCreateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput;
  update: EventsUpdateWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput;
};

export type EventsUpsertWithoutWorkerActivitiesInput = {
  create: EventsCreateWithoutWorkerActivitiesInput;
  update: EventsUpdateWithoutWorkerActivitiesInput;
};

export type EventsWhereInput = {
  AND?: InputMaybe<Array<EventsWhereInput>>;
  NOT?: InputMaybe<Array<EventsWhereInput>>;
  OR?: InputMaybe<Array<EventsWhereInput>>;
  blockNumber?: InputMaybe<BigIntFilter>;
  createdAt?: InputMaybe<DateTimeNullableFilter>;
  data?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<BigIntFilter>;
  minerActivities?: InputMaybe<MinerActivitiesListRelationFilter>;
  name?: InputMaybe<StringFilter>;
  note?: InputMaybe<StringNullableFilter>;
  processedAt?: InputMaybe<DateTimeNullableFilter>;
  section?: InputMaybe<StringFilter>;
  skipped?: InputMaybe<BoolFilter>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesListRelationFilter>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesListRelationFilter>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIds?: InputMaybe<StakePoolWithdrawalsListRelationFilter>;
  stakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIds?: InputMaybe<StakePoolWithdrawalsListRelationFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  workerActivities?: InputMaybe<WorkerActivitiesListRelationFilter>;
};

export type EventsWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type IntFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Int']>;
  divide?: InputMaybe<Scalars['Int']>;
  increment?: InputMaybe<Scalars['Int']>;
  multiply?: InputMaybe<Scalars['Int']>;
  set?: InputMaybe<Scalars['Int']>;
};

export type IntFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type IntNullableFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type IntNullableListFilter = {
  equals?: InputMaybe<Array<Scalars['Int']>>;
  has?: InputMaybe<Scalars['Int']>;
  hasEvery?: InputMaybe<Array<Scalars['Int']>>;
  hasSome?: InputMaybe<Array<Scalars['Int']>>;
  isEmpty?: InputMaybe<Scalars['Boolean']>;
};

export type IntNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedIntNullableFilter>;
  _min?: InputMaybe<NestedIntNullableFilter>;
  _sum?: InputMaybe<NestedIntNullableFilter>;
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type IntWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedIntFilter>;
  _min?: InputMaybe<NestedIntFilter>;
  _sum?: InputMaybe<NestedIntFilter>;
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type MinerActivities = {
  __typename?: 'MinerActivities';
  active: Scalars['Boolean'];
  blockNumber: Scalars['BigInt'];
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current: Scalars['Boolean'];
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  events?: Maybe<Events>;
  id: Scalars['BigInt'];
  iterations: Scalars['BigInt'];
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  minerId: Scalars['BigInt'];
  miners: Miners;
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  sMax: Scalars['Decimal'];
  sMin: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stakes: Scalars['Decimal'];
  state: Scalars['String'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalReward: Scalars['Decimal'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  v: Scalars['Decimal'];
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve: Scalars['Decimal'];
};

export type MinerActivitiesAvgAggregate = {
  __typename?: 'MinerActivitiesAvgAggregate';
  blockNumber?: Maybe<Scalars['Float']>;
  eventId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  iterations?: Maybe<Scalars['Float']>;
  minerId?: Maybe<Scalars['Float']>;
  pInit?: Maybe<Scalars['Float']>;
  pInstant?: Maybe<Scalars['Float']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakes?: Maybe<Scalars['Decimal']>;
  tokenomicVersion?: Maybe<Scalars['Float']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  v?: Maybe<Scalars['Decimal']>;
  ve?: Maybe<Scalars['Decimal']>;
};

export type MinerActivitiesAvgOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export type MinerActivitiesCountAggregate = {
  __typename?: 'MinerActivitiesCountAggregate';
  _all: Scalars['Int'];
  active: Scalars['Int'];
  blockNumber: Scalars['Int'];
  coolingDownStartedAt: Scalars['Int'];
  createdAt: Scalars['Int'];
  current: Scalars['Int'];
  estimatesReclaimableAt: Scalars['Int'];
  eventId: Scalars['Int'];
  id: Scalars['Int'];
  iterations: Scalars['Int'];
  lastChallengedAt: Scalars['Int'];
  minerId: Scalars['Int'];
  miningStartedAt: Scalars['Int'];
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  sMax: Scalars['Int'];
  sMin: Scalars['Int'];
  shares: Scalars['Int'];
  stakes: Scalars['Int'];
  state: Scalars['Int'];
  timestamp: Scalars['Int'];
  tokenomicVersion: Scalars['Int'];
  totalReward: Scalars['Int'];
  type: Scalars['Int'];
  updatedAt: Scalars['Int'];
  v: Scalars['Int'];
  vUpdatedAt: Scalars['Int'];
  ve: Scalars['Int'];
};

export type MinerActivitiesCountOrderByAggregateInput = {
  active?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export type MinerActivitiesCreateInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  blockNumber: Scalars['BigInt'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  events?: InputMaybe<EventsCreateNestedOneWithoutMinerActivitiesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  miners: MinersCreateNestedOneWithoutMinerActivitiesInput;
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalReward?: InputMaybe<Scalars['Decimal']>;
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
};

export type MinerActivitiesCreateManyEventsInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  blockNumber: Scalars['BigInt'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  minerId: Scalars['BigInt'];
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalReward?: InputMaybe<Scalars['Decimal']>;
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
};

export type MinerActivitiesCreateManyEventsInputEnvelope = {
  data: Array<MinerActivitiesCreateManyEventsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type MinerActivitiesCreateManyInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  blockNumber: Scalars['BigInt'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  eventId?: InputMaybe<Scalars['BigInt']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  minerId: Scalars['BigInt'];
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalReward?: InputMaybe<Scalars['Decimal']>;
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
};

export type MinerActivitiesCreateManyMinersInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  blockNumber: Scalars['BigInt'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  eventId?: InputMaybe<Scalars['BigInt']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalReward?: InputMaybe<Scalars['Decimal']>;
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
};

export type MinerActivitiesCreateManyMinersInputEnvelope = {
  data: Array<MinerActivitiesCreateManyMinersInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type MinerActivitiesCreateNestedManyWithoutEventsInput = {
  connect?: InputMaybe<Array<MinerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<MinerActivitiesCreateOrConnectWithoutEventsInput>>;
  create?: InputMaybe<Array<MinerActivitiesCreateWithoutEventsInput>>;
  createMany?: InputMaybe<MinerActivitiesCreateManyEventsInputEnvelope>;
};

export type MinerActivitiesCreateNestedManyWithoutMinersInput = {
  connect?: InputMaybe<Array<MinerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<MinerActivitiesCreateOrConnectWithoutMinersInput>>;
  create?: InputMaybe<Array<MinerActivitiesCreateWithoutMinersInput>>;
  createMany?: InputMaybe<MinerActivitiesCreateManyMinersInputEnvelope>;
};

export type MinerActivitiesCreateOrConnectWithoutEventsInput = {
  create: MinerActivitiesCreateWithoutEventsInput;
  where: MinerActivitiesWhereUniqueInput;
};

export type MinerActivitiesCreateOrConnectWithoutMinersInput = {
  create: MinerActivitiesCreateWithoutMinersInput;
  where: MinerActivitiesWhereUniqueInput;
};

export type MinerActivitiesCreateWithoutEventsInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  blockNumber: Scalars['BigInt'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  miners: MinersCreateNestedOneWithoutMinerActivitiesInput;
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalReward?: InputMaybe<Scalars['Decimal']>;
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
};

export type MinerActivitiesCreateWithoutMinersInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  blockNumber: Scalars['BigInt'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  events?: InputMaybe<EventsCreateNestedOneWithoutMinerActivitiesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalReward?: InputMaybe<Scalars['Decimal']>;
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
};

export type MinerActivitiesGroupBy = {
  __typename?: 'MinerActivitiesGroupBy';
  _avg?: Maybe<MinerActivitiesAvgAggregate>;
  _count?: Maybe<MinerActivitiesCountAggregate>;
  _max?: Maybe<MinerActivitiesMaxAggregate>;
  _min?: Maybe<MinerActivitiesMinAggregate>;
  _sum?: Maybe<MinerActivitiesSumAggregate>;
  active: Scalars['Boolean'];
  blockNumber: Scalars['BigInt'];
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current: Scalars['Boolean'];
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id: Scalars['BigInt'];
  iterations: Scalars['BigInt'];
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  minerId: Scalars['BigInt'];
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  sMax: Scalars['Decimal'];
  sMin: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stakes: Scalars['Decimal'];
  state: Scalars['String'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalReward: Scalars['Decimal'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  v: Scalars['Decimal'];
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve: Scalars['Decimal'];
};

export type MinerActivitiesListRelationFilter = {
  every?: InputMaybe<MinerActivitiesWhereInput>;
  none?: InputMaybe<MinerActivitiesWhereInput>;
  some?: InputMaybe<MinerActivitiesWhereInput>;
};

export type MinerActivitiesMaxAggregate = {
  __typename?: 'MinerActivitiesMaxAggregate';
  active?: Maybe<Scalars['Boolean']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  current?: Maybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  iterations?: Maybe<Scalars['BigInt']>;
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  minerId?: Maybe<Scalars['BigInt']>;
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit?: Maybe<Scalars['Int']>;
  pInstant?: Maybe<Scalars['Int']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakes?: Maybe<Scalars['Decimal']>;
  state?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  v?: Maybe<Scalars['Decimal']>;
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve?: Maybe<Scalars['Decimal']>;
};

export type MinerActivitiesMaxOrderByAggregateInput = {
  active?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export type MinerActivitiesMinAggregate = {
  __typename?: 'MinerActivitiesMinAggregate';
  active?: Maybe<Scalars['Boolean']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  current?: Maybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  iterations?: Maybe<Scalars['BigInt']>;
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  minerId?: Maybe<Scalars['BigInt']>;
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit?: Maybe<Scalars['Int']>;
  pInstant?: Maybe<Scalars['Int']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakes?: Maybe<Scalars['Decimal']>;
  state?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  v?: Maybe<Scalars['Decimal']>;
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve?: Maybe<Scalars['Decimal']>;
};

export type MinerActivitiesMinOrderByAggregateInput = {
  active?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export type MinerActivitiesOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type MinerActivitiesOrderByWithAggregationInput = {
  _avg?: InputMaybe<MinerActivitiesAvgOrderByAggregateInput>;
  _count?: InputMaybe<MinerActivitiesCountOrderByAggregateInput>;
  _max?: InputMaybe<MinerActivitiesMaxOrderByAggregateInput>;
  _min?: InputMaybe<MinerActivitiesMinOrderByAggregateInput>;
  _sum?: InputMaybe<MinerActivitiesSumOrderByAggregateInput>;
  active?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export type MinerActivitiesOrderByWithRelationInput = {
  active?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  events?: InputMaybe<EventsOrderByWithRelationInput>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  miners?: InputMaybe<MinersOrderByWithRelationInput>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export enum MinerActivitiesScalarFieldEnum {
  Active = 'active',
  BlockNumber = 'blockNumber',
  CoolingDownStartedAt = 'coolingDownStartedAt',
  CreatedAt = 'createdAt',
  Current = 'current',
  EstimatesReclaimableAt = 'estimatesReclaimableAt',
  EventId = 'eventId',
  Id = 'id',
  Iterations = 'iterations',
  LastChallengedAt = 'lastChallengedAt',
  MinerId = 'minerId',
  MiningStartedAt = 'miningStartedAt',
  PInit = 'pInit',
  PInstant = 'pInstant',
  SMax = 'sMax',
  SMin = 'sMin',
  Shares = 'shares',
  Stakes = 'stakes',
  State = 'state',
  Timestamp = 'timestamp',
  TokenomicVersion = 'tokenomicVersion',
  TotalReward = 'totalReward',
  Type = 'type',
  UpdatedAt = 'updatedAt',
  V = 'v',
  VUpdatedAt = 'vUpdatedAt',
  Ve = 've'
}

export type MinerActivitiesScalarWhereInput = {
  AND?: InputMaybe<Array<MinerActivitiesScalarWhereInput>>;
  NOT?: InputMaybe<Array<MinerActivitiesScalarWhereInput>>;
  OR?: InputMaybe<Array<MinerActivitiesScalarWhereInput>>;
  active?: InputMaybe<BoolFilter>;
  blockNumber?: InputMaybe<BigIntFilter>;
  coolingDownStartedAt?: InputMaybe<DateTimeNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  current?: InputMaybe<BoolFilter>;
  estimatesReclaimableAt?: InputMaybe<DateTimeNullableFilter>;
  eventId?: InputMaybe<BigIntNullableFilter>;
  id?: InputMaybe<BigIntFilter>;
  iterations?: InputMaybe<BigIntFilter>;
  lastChallengedAt?: InputMaybe<DateTimeNullableFilter>;
  minerId?: InputMaybe<BigIntFilter>;
  miningStartedAt?: InputMaybe<DateTimeNullableFilter>;
  pInit?: InputMaybe<IntFilter>;
  pInstant?: InputMaybe<IntFilter>;
  sMax?: InputMaybe<DecimalFilter>;
  sMin?: InputMaybe<DecimalFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stakes?: InputMaybe<DecimalFilter>;
  state?: InputMaybe<StringFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  totalReward?: InputMaybe<DecimalFilter>;
  type?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  v?: InputMaybe<DecimalFilter>;
  vUpdatedAt?: InputMaybe<DateTimeNullableFilter>;
  ve?: InputMaybe<DecimalFilter>;
};

export type MinerActivitiesScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<MinerActivitiesScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<MinerActivitiesScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<MinerActivitiesScalarWhereWithAggregatesInput>>;
  active?: InputMaybe<BoolWithAggregatesFilter>;
  blockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  coolingDownStartedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  current?: InputMaybe<BoolWithAggregatesFilter>;
  estimatesReclaimableAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  eventId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  iterations?: InputMaybe<BigIntWithAggregatesFilter>;
  lastChallengedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  minerId?: InputMaybe<BigIntWithAggregatesFilter>;
  miningStartedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  pInit?: InputMaybe<IntWithAggregatesFilter>;
  pInstant?: InputMaybe<IntWithAggregatesFilter>;
  sMax?: InputMaybe<DecimalWithAggregatesFilter>;
  sMin?: InputMaybe<DecimalWithAggregatesFilter>;
  shares?: InputMaybe<DecimalWithAggregatesFilter>;
  stakes?: InputMaybe<DecimalWithAggregatesFilter>;
  state?: InputMaybe<StringWithAggregatesFilter>;
  timestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  tokenomicVersion?: InputMaybe<IntWithAggregatesFilter>;
  totalReward?: InputMaybe<DecimalWithAggregatesFilter>;
  type?: InputMaybe<StringWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  v?: InputMaybe<DecimalWithAggregatesFilter>;
  vUpdatedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  ve?: InputMaybe<DecimalWithAggregatesFilter>;
};

export type MinerActivitiesSumAggregate = {
  __typename?: 'MinerActivitiesSumAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  iterations?: Maybe<Scalars['BigInt']>;
  minerId?: Maybe<Scalars['BigInt']>;
  pInit?: Maybe<Scalars['Int']>;
  pInstant?: Maybe<Scalars['Int']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakes?: Maybe<Scalars['Decimal']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  v?: Maybe<Scalars['Decimal']>;
  ve?: Maybe<Scalars['Decimal']>;
};

export type MinerActivitiesSumOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export type MinerActivitiesUpdateInput = {
  active?: InputMaybe<BoolFieldUpdateOperationsInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  coolingDownStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  current?: InputMaybe<BoolFieldUpdateOperationsInput>;
  estimatesReclaimableAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  events?: InputMaybe<EventsUpdateOneWithoutMinerActivitiesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  iterations?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastChallengedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateOneRequiredWithoutMinerActivitiesInput>;
  miningStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  pInit?: InputMaybe<IntFieldUpdateOperationsInput>;
  pInstant?: InputMaybe<IntFieldUpdateOperationsInput>;
  sMax?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  sMin?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakes?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  v?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  vUpdatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  ve?: InputMaybe<DecimalFieldUpdateOperationsInput>;
};

export type MinerActivitiesUpdateManyMutationInput = {
  active?: InputMaybe<BoolFieldUpdateOperationsInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  coolingDownStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  current?: InputMaybe<BoolFieldUpdateOperationsInput>;
  estimatesReclaimableAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  iterations?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastChallengedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  miningStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  pInit?: InputMaybe<IntFieldUpdateOperationsInput>;
  pInstant?: InputMaybe<IntFieldUpdateOperationsInput>;
  sMax?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  sMin?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakes?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  v?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  vUpdatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  ve?: InputMaybe<DecimalFieldUpdateOperationsInput>;
};

export type MinerActivitiesUpdateManyWithWhereWithoutEventsInput = {
  data: MinerActivitiesUpdateManyMutationInput;
  where: MinerActivitiesScalarWhereInput;
};

export type MinerActivitiesUpdateManyWithWhereWithoutMinersInput = {
  data: MinerActivitiesUpdateManyMutationInput;
  where: MinerActivitiesScalarWhereInput;
};

export type MinerActivitiesUpdateManyWithoutEventsInput = {
  connect?: InputMaybe<Array<MinerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<MinerActivitiesCreateOrConnectWithoutEventsInput>>;
  create?: InputMaybe<Array<MinerActivitiesCreateWithoutEventsInput>>;
  createMany?: InputMaybe<MinerActivitiesCreateManyEventsInputEnvelope>;
  delete?: InputMaybe<Array<MinerActivitiesWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<MinerActivitiesScalarWhereInput>>;
  disconnect?: InputMaybe<Array<MinerActivitiesWhereUniqueInput>>;
  set?: InputMaybe<Array<MinerActivitiesWhereUniqueInput>>;
  update?: InputMaybe<Array<MinerActivitiesUpdateWithWhereUniqueWithoutEventsInput>>;
  updateMany?: InputMaybe<Array<MinerActivitiesUpdateManyWithWhereWithoutEventsInput>>;
  upsert?: InputMaybe<Array<MinerActivitiesUpsertWithWhereUniqueWithoutEventsInput>>;
};

export type MinerActivitiesUpdateManyWithoutMinersInput = {
  connect?: InputMaybe<Array<MinerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<MinerActivitiesCreateOrConnectWithoutMinersInput>>;
  create?: InputMaybe<Array<MinerActivitiesCreateWithoutMinersInput>>;
  createMany?: InputMaybe<MinerActivitiesCreateManyMinersInputEnvelope>;
  delete?: InputMaybe<Array<MinerActivitiesWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<MinerActivitiesScalarWhereInput>>;
  disconnect?: InputMaybe<Array<MinerActivitiesWhereUniqueInput>>;
  set?: InputMaybe<Array<MinerActivitiesWhereUniqueInput>>;
  update?: InputMaybe<Array<MinerActivitiesUpdateWithWhereUniqueWithoutMinersInput>>;
  updateMany?: InputMaybe<Array<MinerActivitiesUpdateManyWithWhereWithoutMinersInput>>;
  upsert?: InputMaybe<Array<MinerActivitiesUpsertWithWhereUniqueWithoutMinersInput>>;
};

export type MinerActivitiesUpdateWithWhereUniqueWithoutEventsInput = {
  data: MinerActivitiesUpdateWithoutEventsInput;
  where: MinerActivitiesWhereUniqueInput;
};

export type MinerActivitiesUpdateWithWhereUniqueWithoutMinersInput = {
  data: MinerActivitiesUpdateWithoutMinersInput;
  where: MinerActivitiesWhereUniqueInput;
};

export type MinerActivitiesUpdateWithoutEventsInput = {
  active?: InputMaybe<BoolFieldUpdateOperationsInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  coolingDownStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  current?: InputMaybe<BoolFieldUpdateOperationsInput>;
  estimatesReclaimableAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  iterations?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastChallengedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateOneRequiredWithoutMinerActivitiesInput>;
  miningStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  pInit?: InputMaybe<IntFieldUpdateOperationsInput>;
  pInstant?: InputMaybe<IntFieldUpdateOperationsInput>;
  sMax?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  sMin?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakes?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  v?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  vUpdatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  ve?: InputMaybe<DecimalFieldUpdateOperationsInput>;
};

export type MinerActivitiesUpdateWithoutMinersInput = {
  active?: InputMaybe<BoolFieldUpdateOperationsInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  coolingDownStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  current?: InputMaybe<BoolFieldUpdateOperationsInput>;
  estimatesReclaimableAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  events?: InputMaybe<EventsUpdateOneWithoutMinerActivitiesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  iterations?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastChallengedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  miningStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  pInit?: InputMaybe<IntFieldUpdateOperationsInput>;
  pInstant?: InputMaybe<IntFieldUpdateOperationsInput>;
  sMax?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  sMin?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakes?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  v?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  vUpdatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  ve?: InputMaybe<DecimalFieldUpdateOperationsInput>;
};

export type MinerActivitiesUpsertWithWhereUniqueWithoutEventsInput = {
  create: MinerActivitiesCreateWithoutEventsInput;
  update: MinerActivitiesUpdateWithoutEventsInput;
  where: MinerActivitiesWhereUniqueInput;
};

export type MinerActivitiesUpsertWithWhereUniqueWithoutMinersInput = {
  create: MinerActivitiesCreateWithoutMinersInput;
  update: MinerActivitiesUpdateWithoutMinersInput;
  where: MinerActivitiesWhereUniqueInput;
};

export type MinerActivitiesWhereInput = {
  AND?: InputMaybe<Array<MinerActivitiesWhereInput>>;
  NOT?: InputMaybe<Array<MinerActivitiesWhereInput>>;
  OR?: InputMaybe<Array<MinerActivitiesWhereInput>>;
  active?: InputMaybe<BoolFilter>;
  blockNumber?: InputMaybe<BigIntFilter>;
  coolingDownStartedAt?: InputMaybe<DateTimeNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  current?: InputMaybe<BoolFilter>;
  estimatesReclaimableAt?: InputMaybe<DateTimeNullableFilter>;
  eventId?: InputMaybe<BigIntNullableFilter>;
  events?: InputMaybe<EventsRelationFilter>;
  id?: InputMaybe<BigIntFilter>;
  iterations?: InputMaybe<BigIntFilter>;
  lastChallengedAt?: InputMaybe<DateTimeNullableFilter>;
  minerId?: InputMaybe<BigIntFilter>;
  miners?: InputMaybe<MinersRelationFilter>;
  miningStartedAt?: InputMaybe<DateTimeNullableFilter>;
  pInit?: InputMaybe<IntFilter>;
  pInstant?: InputMaybe<IntFilter>;
  sMax?: InputMaybe<DecimalFilter>;
  sMin?: InputMaybe<DecimalFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stakes?: InputMaybe<DecimalFilter>;
  state?: InputMaybe<StringFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  totalReward?: InputMaybe<DecimalFilter>;
  type?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  v?: InputMaybe<DecimalFilter>;
  vUpdatedAt?: InputMaybe<DateTimeNullableFilter>;
  ve?: InputMaybe<DecimalFilter>;
};

export type MinerActivitiesWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type Miners = {
  __typename?: 'Miners';
  _count?: Maybe<MinersCount>;
  active: Scalars['Boolean'];
  address: Scalars['String'];
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current: Scalars['Boolean'];
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['BigInt'];
  iterations: Scalars['BigInt'];
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minerActivities: Array<MinerActivities>;
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  pid: Scalars['Int'];
  sMax: Scalars['Decimal'];
  sMin: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakePools: StakePools;
  stakes: Scalars['Decimal'];
  state: Scalars['String'];
  totalReward: Scalars['Decimal'];
  updatedAt: Scalars['DateTime'];
  v: Scalars['Decimal'];
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve: Scalars['Decimal'];
  workerActivities: Array<WorkerActivities>;
  workerId: Scalars['BigInt'];
  workerPublicKey: Scalars['String'];
  workersMinersToWorkersCurrentMinerIds: Array<Workers>;
  workersMinersWorkerIdToWorkers: Workers;
};


export type MinersMinerActivitiesArgs = {
  cursor?: InputMaybe<MinerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type MinersWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type MinersWorkersMinersToWorkersCurrentMinerIdsArgs = {
  cursor?: InputMaybe<WorkersWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};

export type MinersAvgAggregate = {
  __typename?: 'MinersAvgAggregate';
  id?: Maybe<Scalars['Float']>;
  iterations?: Maybe<Scalars['Float']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  pInit?: Maybe<Scalars['Float']>;
  pInstant?: Maybe<Scalars['Float']>;
  pid?: Maybe<Scalars['Float']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['Float']>;
  stakes?: Maybe<Scalars['Decimal']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  v?: Maybe<Scalars['Decimal']>;
  ve?: Maybe<Scalars['Decimal']>;
  workerId?: Maybe<Scalars['Float']>;
};

export type MinersAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type MinersCount = {
  __typename?: 'MinersCount';
  minerActivities: Scalars['Int'];
  workerActivities: Scalars['Int'];
  workersMinersToWorkersCurrentMinerIds: Scalars['Int'];
};

export type MinersCountAggregate = {
  __typename?: 'MinersCountAggregate';
  _all: Scalars['Int'];
  active: Scalars['Int'];
  address: Scalars['Int'];
  coolingDownStartedAt: Scalars['Int'];
  createdAt: Scalars['Int'];
  current: Scalars['Int'];
  estimatesReclaimableAt: Scalars['Int'];
  id: Scalars['Int'];
  iterations: Scalars['Int'];
  lastChallengedAt: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['Int'];
  lastUpdatedTimestamp: Scalars['Int'];
  miningStartedAt: Scalars['Int'];
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  pid: Scalars['Int'];
  sMax: Scalars['Int'];
  sMin: Scalars['Int'];
  shares: Scalars['Int'];
  stakePoolId: Scalars['Int'];
  stakes: Scalars['Int'];
  state: Scalars['Int'];
  totalReward: Scalars['Int'];
  updatedAt: Scalars['Int'];
  v: Scalars['Int'];
  vUpdatedAt: Scalars['Int'];
  ve: Scalars['Int'];
  workerId: Scalars['Int'];
  workerPublicKey: Scalars['Int'];
};

export type MinersCountOrderByAggregateInput = {
  active?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
  workerPublicKey?: InputMaybe<SortOrder>;
};

export type MinersCreateInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  address: Scalars['String'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minerActivities?: InputMaybe<MinerActivitiesCreateNestedManyWithoutMinersInput>;
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  pid: Scalars['Int'];
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakePools: StakePoolsCreateNestedOneWithoutMinersInput;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  totalReward?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutMinersInput>;
  workerPublicKey: Scalars['String'];
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersCreateNestedManyWithoutMinersMinersToWorkersCurrentMinerIdInput>;
  workersMinersWorkerIdToWorkers: WorkersCreateNestedOneWithoutMinersMinersWorkerIdToWorkersInput;
};

export type MinersCreateManyInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  address: Scalars['String'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  pid: Scalars['Int'];
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakePoolId: Scalars['BigInt'];
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  totalReward?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
  workerId: Scalars['BigInt'];
  workerPublicKey: Scalars['String'];
};

export type MinersCreateManyStakePoolsInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  address: Scalars['String'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  pid: Scalars['Int'];
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  totalReward?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
  workerId: Scalars['BigInt'];
  workerPublicKey: Scalars['String'];
};

export type MinersCreateManyStakePoolsInputEnvelope = {
  data: Array<MinersCreateManyStakePoolsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type MinersCreateManyWorkersMinersWorkerIdToWorkersInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  address: Scalars['String'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  pid: Scalars['Int'];
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakePoolId: Scalars['BigInt'];
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  totalReward?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
  workerPublicKey: Scalars['String'];
};

export type MinersCreateManyWorkersMinersWorkerIdToWorkersInputEnvelope = {
  data: Array<MinersCreateManyWorkersMinersWorkerIdToWorkersInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type MinersCreateNestedManyWithoutStakePoolsInput = {
  connect?: InputMaybe<Array<MinersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<MinersCreateOrConnectWithoutStakePoolsInput>>;
  create?: InputMaybe<Array<MinersCreateWithoutStakePoolsInput>>;
  createMany?: InputMaybe<MinersCreateManyStakePoolsInputEnvelope>;
};

export type MinersCreateNestedManyWithoutWorkersMinersWorkerIdToWorkersInput = {
  connect?: InputMaybe<Array<MinersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<MinersCreateOrConnectWithoutWorkersMinersWorkerIdToWorkersInput>>;
  create?: InputMaybe<Array<MinersCreateWithoutWorkersMinersWorkerIdToWorkersInput>>;
  createMany?: InputMaybe<MinersCreateManyWorkersMinersWorkerIdToWorkersInputEnvelope>;
};

export type MinersCreateNestedOneWithoutMinerActivitiesInput = {
  connect?: InputMaybe<MinersWhereUniqueInput>;
  connectOrCreate?: InputMaybe<MinersCreateOrConnectWithoutMinerActivitiesInput>;
  create?: InputMaybe<MinersCreateWithoutMinerActivitiesInput>;
};

export type MinersCreateNestedOneWithoutWorkerActivitiesInput = {
  connect?: InputMaybe<MinersWhereUniqueInput>;
  connectOrCreate?: InputMaybe<MinersCreateOrConnectWithoutWorkerActivitiesInput>;
  create?: InputMaybe<MinersCreateWithoutWorkerActivitiesInput>;
};

export type MinersCreateNestedOneWithoutWorkersMinersToWorkersCurrentMinerIdsInput = {
  connect?: InputMaybe<MinersWhereUniqueInput>;
  connectOrCreate?: InputMaybe<MinersCreateOrConnectWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  create?: InputMaybe<MinersCreateWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
};

export type MinersCreateOrConnectWithoutMinerActivitiesInput = {
  create: MinersCreateWithoutMinerActivitiesInput;
  where: MinersWhereUniqueInput;
};

export type MinersCreateOrConnectWithoutStakePoolsInput = {
  create: MinersCreateWithoutStakePoolsInput;
  where: MinersWhereUniqueInput;
};

export type MinersCreateOrConnectWithoutWorkerActivitiesInput = {
  create: MinersCreateWithoutWorkerActivitiesInput;
  where: MinersWhereUniqueInput;
};

export type MinersCreateOrConnectWithoutWorkersMinersToWorkersCurrentMinerIdsInput = {
  create: MinersCreateWithoutWorkersMinersToWorkersCurrentMinerIdsInput;
  where: MinersWhereUniqueInput;
};

export type MinersCreateOrConnectWithoutWorkersMinersWorkerIdToWorkersInput = {
  create: MinersCreateWithoutWorkersMinersWorkerIdToWorkersInput;
  where: MinersWhereUniqueInput;
};

export type MinersCreateWithoutMinerActivitiesInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  address: Scalars['String'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  pid: Scalars['Int'];
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakePools: StakePoolsCreateNestedOneWithoutMinersInput;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  totalReward?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutMinersInput>;
  workerPublicKey: Scalars['String'];
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersCreateNestedManyWithoutMinersMinersToWorkersCurrentMinerIdInput>;
  workersMinersWorkerIdToWorkers: WorkersCreateNestedOneWithoutMinersMinersWorkerIdToWorkersInput;
};

export type MinersCreateWithoutStakePoolsInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  address: Scalars['String'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minerActivities?: InputMaybe<MinerActivitiesCreateNestedManyWithoutMinersInput>;
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  pid: Scalars['Int'];
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  totalReward?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutMinersInput>;
  workerPublicKey: Scalars['String'];
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersCreateNestedManyWithoutMinersMinersToWorkersCurrentMinerIdInput>;
  workersMinersWorkerIdToWorkers: WorkersCreateNestedOneWithoutMinersMinersWorkerIdToWorkersInput;
};

export type MinersCreateWithoutWorkerActivitiesInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  address: Scalars['String'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minerActivities?: InputMaybe<MinerActivitiesCreateNestedManyWithoutMinersInput>;
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  pid: Scalars['Int'];
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakePools: StakePoolsCreateNestedOneWithoutMinersInput;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  totalReward?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
  workerPublicKey: Scalars['String'];
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersCreateNestedManyWithoutMinersMinersToWorkersCurrentMinerIdInput>;
  workersMinersWorkerIdToWorkers: WorkersCreateNestedOneWithoutMinersMinersWorkerIdToWorkersInput;
};

export type MinersCreateWithoutWorkersMinersToWorkersCurrentMinerIdsInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  address: Scalars['String'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minerActivities?: InputMaybe<MinerActivitiesCreateNestedManyWithoutMinersInput>;
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  pid: Scalars['Int'];
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakePools: StakePoolsCreateNestedOneWithoutMinersInput;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  totalReward?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutMinersInput>;
  workerPublicKey: Scalars['String'];
  workersMinersWorkerIdToWorkers: WorkersCreateNestedOneWithoutMinersMinersWorkerIdToWorkersInput;
};

export type MinersCreateWithoutWorkersMinersWorkerIdToWorkersInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  address: Scalars['String'];
  coolingDownStartedAt?: InputMaybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current?: InputMaybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  iterations?: InputMaybe<Scalars['BigInt']>;
  lastChallengedAt?: InputMaybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minerActivities?: InputMaybe<MinerActivitiesCreateNestedManyWithoutMinersInput>;
  miningStartedAt?: InputMaybe<Scalars['DateTime']>;
  pInit?: InputMaybe<Scalars['Int']>;
  pInstant?: InputMaybe<Scalars['Int']>;
  pid: Scalars['Int'];
  sMax?: InputMaybe<Scalars['Decimal']>;
  sMin?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stakePools: StakePoolsCreateNestedOneWithoutMinersInput;
  stakes?: InputMaybe<Scalars['Decimal']>;
  state?: InputMaybe<Scalars['String']>;
  totalReward?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
  v?: InputMaybe<Scalars['Decimal']>;
  vUpdatedAt?: InputMaybe<Scalars['DateTime']>;
  ve?: InputMaybe<Scalars['Decimal']>;
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutMinersInput>;
  workerPublicKey: Scalars['String'];
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersCreateNestedManyWithoutMinersMinersToWorkersCurrentMinerIdInput>;
};

export type MinersGroupBy = {
  __typename?: 'MinersGroupBy';
  _avg?: Maybe<MinersAvgAggregate>;
  _count?: Maybe<MinersCountAggregate>;
  _max?: Maybe<MinersMaxAggregate>;
  _min?: Maybe<MinersMinAggregate>;
  _sum?: Maybe<MinersSumAggregate>;
  active: Scalars['Boolean'];
  address: Scalars['String'];
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current: Scalars['Boolean'];
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['BigInt'];
  iterations: Scalars['BigInt'];
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  pid: Scalars['Int'];
  sMax: Scalars['Decimal'];
  sMin: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakes: Scalars['Decimal'];
  state: Scalars['String'];
  totalReward: Scalars['Decimal'];
  updatedAt: Scalars['DateTime'];
  v: Scalars['Decimal'];
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve: Scalars['Decimal'];
  workerId: Scalars['BigInt'];
  workerPublicKey: Scalars['String'];
};

export type MinersListRelationFilter = {
  every?: InputMaybe<MinersWhereInput>;
  none?: InputMaybe<MinersWhereInput>;
  some?: InputMaybe<MinersWhereInput>;
};

export type MinersMaxAggregate = {
  __typename?: 'MinersMaxAggregate';
  active?: Maybe<Scalars['Boolean']>;
  address?: Maybe<Scalars['String']>;
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  current?: Maybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  iterations?: Maybe<Scalars['BigInt']>;
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit?: Maybe<Scalars['Int']>;
  pInstant?: Maybe<Scalars['Int']>;
  pid?: Maybe<Scalars['Int']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakes?: Maybe<Scalars['Decimal']>;
  state?: Maybe<Scalars['String']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  v?: Maybe<Scalars['Decimal']>;
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve?: Maybe<Scalars['Decimal']>;
  workerId?: Maybe<Scalars['BigInt']>;
  workerPublicKey?: Maybe<Scalars['String']>;
};

export type MinersMaxOrderByAggregateInput = {
  active?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
  workerPublicKey?: InputMaybe<SortOrder>;
};

export type MinersMinAggregate = {
  __typename?: 'MinersMinAggregate';
  active?: Maybe<Scalars['Boolean']>;
  address?: Maybe<Scalars['String']>;
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  current?: Maybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  iterations?: Maybe<Scalars['BigInt']>;
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit?: Maybe<Scalars['Int']>;
  pInstant?: Maybe<Scalars['Int']>;
  pid?: Maybe<Scalars['Int']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakes?: Maybe<Scalars['Decimal']>;
  state?: Maybe<Scalars['String']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  v?: Maybe<Scalars['Decimal']>;
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve?: Maybe<Scalars['Decimal']>;
  workerId?: Maybe<Scalars['BigInt']>;
  workerPublicKey?: Maybe<Scalars['String']>;
};

export type MinersMinOrderByAggregateInput = {
  active?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
  workerPublicKey?: InputMaybe<SortOrder>;
};

export type MinersOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type MinersOrderByWithAggregationInput = {
  _avg?: InputMaybe<MinersAvgOrderByAggregateInput>;
  _count?: InputMaybe<MinersCountOrderByAggregateInput>;
  _max?: InputMaybe<MinersMaxOrderByAggregateInput>;
  _min?: InputMaybe<MinersMinOrderByAggregateInput>;
  _sum?: InputMaybe<MinersSumOrderByAggregateInput>;
  active?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
  workerPublicKey?: InputMaybe<SortOrder>;
};

export type MinersOrderByWithRelationInput = {
  active?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minerActivities?: InputMaybe<MinerActivitiesOrderByRelationAggregateInput>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerActivities?: InputMaybe<WorkerActivitiesOrderByRelationAggregateInput>;
  workerId?: InputMaybe<SortOrder>;
  workerPublicKey?: InputMaybe<SortOrder>;
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersOrderByRelationAggregateInput>;
  workersMinersWorkerIdToWorkers?: InputMaybe<WorkersOrderByWithRelationInput>;
};

export type MinersRelationFilter = {
  is?: InputMaybe<MinersWhereInput>;
  isNot?: InputMaybe<MinersWhereInput>;
};

export enum MinersScalarFieldEnum {
  Active = 'active',
  Address = 'address',
  CoolingDownStartedAt = 'coolingDownStartedAt',
  CreatedAt = 'createdAt',
  Current = 'current',
  EstimatesReclaimableAt = 'estimatesReclaimableAt',
  Id = 'id',
  Iterations = 'iterations',
  LastChallengedAt = 'lastChallengedAt',
  LastUpdatedBlockNumber = 'lastUpdatedBlockNumber',
  LastUpdatedTimestamp = 'lastUpdatedTimestamp',
  MiningStartedAt = 'miningStartedAt',
  PInit = 'pInit',
  PInstant = 'pInstant',
  Pid = 'pid',
  SMax = 'sMax',
  SMin = 'sMin',
  Shares = 'shares',
  StakePoolId = 'stakePoolId',
  Stakes = 'stakes',
  State = 'state',
  TotalReward = 'totalReward',
  UpdatedAt = 'updatedAt',
  V = 'v',
  VUpdatedAt = 'vUpdatedAt',
  Ve = 've',
  WorkerId = 'workerId',
  WorkerPublicKey = 'workerPublicKey'
}

export type MinersScalarWhereInput = {
  AND?: InputMaybe<Array<MinersScalarWhereInput>>;
  NOT?: InputMaybe<Array<MinersScalarWhereInput>>;
  OR?: InputMaybe<Array<MinersScalarWhereInput>>;
  active?: InputMaybe<BoolFilter>;
  address?: InputMaybe<StringFilter>;
  coolingDownStartedAt?: InputMaybe<DateTimeNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  current?: InputMaybe<BoolFilter>;
  estimatesReclaimableAt?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<BigIntFilter>;
  iterations?: InputMaybe<BigIntFilter>;
  lastChallengedAt?: InputMaybe<DateTimeNullableFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  miningStartedAt?: InputMaybe<DateTimeNullableFilter>;
  pInit?: InputMaybe<IntFilter>;
  pInstant?: InputMaybe<IntFilter>;
  pid?: InputMaybe<IntFilter>;
  sMax?: InputMaybe<DecimalFilter>;
  sMin?: InputMaybe<DecimalFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stakePoolId?: InputMaybe<BigIntFilter>;
  stakes?: InputMaybe<DecimalFilter>;
  state?: InputMaybe<StringFilter>;
  totalReward?: InputMaybe<DecimalFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  v?: InputMaybe<DecimalFilter>;
  vUpdatedAt?: InputMaybe<DateTimeNullableFilter>;
  ve?: InputMaybe<DecimalFilter>;
  workerId?: InputMaybe<BigIntFilter>;
  workerPublicKey?: InputMaybe<StringFilter>;
};

export type MinersScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<MinersScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<MinersScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<MinersScalarWhereWithAggregatesInput>>;
  active?: InputMaybe<BoolWithAggregatesFilter>;
  address?: InputMaybe<StringWithAggregatesFilter>;
  coolingDownStartedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  current?: InputMaybe<BoolWithAggregatesFilter>;
  estimatesReclaimableAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  iterations?: InputMaybe<BigIntWithAggregatesFilter>;
  lastChallengedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  miningStartedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  pInit?: InputMaybe<IntWithAggregatesFilter>;
  pInstant?: InputMaybe<IntWithAggregatesFilter>;
  pid?: InputMaybe<IntWithAggregatesFilter>;
  sMax?: InputMaybe<DecimalWithAggregatesFilter>;
  sMin?: InputMaybe<DecimalWithAggregatesFilter>;
  shares?: InputMaybe<DecimalWithAggregatesFilter>;
  stakePoolId?: InputMaybe<BigIntWithAggregatesFilter>;
  stakes?: InputMaybe<DecimalWithAggregatesFilter>;
  state?: InputMaybe<StringWithAggregatesFilter>;
  totalReward?: InputMaybe<DecimalWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  v?: InputMaybe<DecimalWithAggregatesFilter>;
  vUpdatedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  ve?: InputMaybe<DecimalWithAggregatesFilter>;
  workerId?: InputMaybe<BigIntWithAggregatesFilter>;
  workerPublicKey?: InputMaybe<StringWithAggregatesFilter>;
};

export type MinersSumAggregate = {
  __typename?: 'MinersSumAggregate';
  id?: Maybe<Scalars['BigInt']>;
  iterations?: Maybe<Scalars['BigInt']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  pInit?: Maybe<Scalars['Int']>;
  pInstant?: Maybe<Scalars['Int']>;
  pid?: Maybe<Scalars['Int']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakes?: Maybe<Scalars['Decimal']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  v?: Maybe<Scalars['Decimal']>;
  ve?: Maybe<Scalars['Decimal']>;
  workerId?: Maybe<Scalars['BigInt']>;
};

export type MinersSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type MinersUpdateInput = {
  active?: InputMaybe<BoolFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  coolingDownStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  current?: InputMaybe<BoolFieldUpdateOperationsInput>;
  estimatesReclaimableAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  iterations?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastChallengedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minerActivities?: InputMaybe<MinerActivitiesUpdateManyWithoutMinersInput>;
  miningStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  pInit?: InputMaybe<IntFieldUpdateOperationsInput>;
  pInstant?: InputMaybe<IntFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  sMax?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  sMin?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutMinersInput>;
  stakes?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  v?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  vUpdatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  ve?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutMinersInput>;
  workerPublicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersUpdateManyWithoutMinersMinersToWorkersCurrentMinerIdInput>;
  workersMinersWorkerIdToWorkers?: InputMaybe<WorkersUpdateOneRequiredWithoutMinersMinersWorkerIdToWorkersInput>;
};

export type MinersUpdateManyMutationInput = {
  active?: InputMaybe<BoolFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  coolingDownStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  current?: InputMaybe<BoolFieldUpdateOperationsInput>;
  estimatesReclaimableAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  iterations?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastChallengedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  miningStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  pInit?: InputMaybe<IntFieldUpdateOperationsInput>;
  pInstant?: InputMaybe<IntFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  sMax?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  sMin?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakes?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  v?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  vUpdatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  ve?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  workerPublicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type MinersUpdateManyWithWhereWithoutStakePoolsInput = {
  data: MinersUpdateManyMutationInput;
  where: MinersScalarWhereInput;
};

export type MinersUpdateManyWithWhereWithoutWorkersMinersWorkerIdToWorkersInput = {
  data: MinersUpdateManyMutationInput;
  where: MinersScalarWhereInput;
};

export type MinersUpdateManyWithoutStakePoolsInput = {
  connect?: InputMaybe<Array<MinersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<MinersCreateOrConnectWithoutStakePoolsInput>>;
  create?: InputMaybe<Array<MinersCreateWithoutStakePoolsInput>>;
  createMany?: InputMaybe<MinersCreateManyStakePoolsInputEnvelope>;
  delete?: InputMaybe<Array<MinersWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<MinersScalarWhereInput>>;
  disconnect?: InputMaybe<Array<MinersWhereUniqueInput>>;
  set?: InputMaybe<Array<MinersWhereUniqueInput>>;
  update?: InputMaybe<Array<MinersUpdateWithWhereUniqueWithoutStakePoolsInput>>;
  updateMany?: InputMaybe<Array<MinersUpdateManyWithWhereWithoutStakePoolsInput>>;
  upsert?: InputMaybe<Array<MinersUpsertWithWhereUniqueWithoutStakePoolsInput>>;
};

export type MinersUpdateManyWithoutWorkersMinersWorkerIdToWorkersInput = {
  connect?: InputMaybe<Array<MinersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<MinersCreateOrConnectWithoutWorkersMinersWorkerIdToWorkersInput>>;
  create?: InputMaybe<Array<MinersCreateWithoutWorkersMinersWorkerIdToWorkersInput>>;
  createMany?: InputMaybe<MinersCreateManyWorkersMinersWorkerIdToWorkersInputEnvelope>;
  delete?: InputMaybe<Array<MinersWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<MinersScalarWhereInput>>;
  disconnect?: InputMaybe<Array<MinersWhereUniqueInput>>;
  set?: InputMaybe<Array<MinersWhereUniqueInput>>;
  update?: InputMaybe<Array<MinersUpdateWithWhereUniqueWithoutWorkersMinersWorkerIdToWorkersInput>>;
  updateMany?: InputMaybe<Array<MinersUpdateManyWithWhereWithoutWorkersMinersWorkerIdToWorkersInput>>;
  upsert?: InputMaybe<Array<MinersUpsertWithWhereUniqueWithoutWorkersMinersWorkerIdToWorkersInput>>;
};

export type MinersUpdateOneRequiredWithoutMinerActivitiesInput = {
  connect?: InputMaybe<MinersWhereUniqueInput>;
  connectOrCreate?: InputMaybe<MinersCreateOrConnectWithoutMinerActivitiesInput>;
  create?: InputMaybe<MinersCreateWithoutMinerActivitiesInput>;
  update?: InputMaybe<MinersUpdateWithoutMinerActivitiesInput>;
  upsert?: InputMaybe<MinersUpsertWithoutMinerActivitiesInput>;
};

export type MinersUpdateOneWithoutWorkerActivitiesInput = {
  connect?: InputMaybe<MinersWhereUniqueInput>;
  connectOrCreate?: InputMaybe<MinersCreateOrConnectWithoutWorkerActivitiesInput>;
  create?: InputMaybe<MinersCreateWithoutWorkerActivitiesInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<MinersUpdateWithoutWorkerActivitiesInput>;
  upsert?: InputMaybe<MinersUpsertWithoutWorkerActivitiesInput>;
};

export type MinersUpdateOneWithoutWorkersMinersToWorkersCurrentMinerIdsInput = {
  connect?: InputMaybe<MinersWhereUniqueInput>;
  connectOrCreate?: InputMaybe<MinersCreateOrConnectWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  create?: InputMaybe<MinersCreateWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<MinersUpdateWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  upsert?: InputMaybe<MinersUpsertWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
};

export type MinersUpdateWithWhereUniqueWithoutStakePoolsInput = {
  data: MinersUpdateWithoutStakePoolsInput;
  where: MinersWhereUniqueInput;
};

export type MinersUpdateWithWhereUniqueWithoutWorkersMinersWorkerIdToWorkersInput = {
  data: MinersUpdateWithoutWorkersMinersWorkerIdToWorkersInput;
  where: MinersWhereUniqueInput;
};

export type MinersUpdateWithoutMinerActivitiesInput = {
  active?: InputMaybe<BoolFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  coolingDownStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  current?: InputMaybe<BoolFieldUpdateOperationsInput>;
  estimatesReclaimableAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  iterations?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastChallengedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  miningStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  pInit?: InputMaybe<IntFieldUpdateOperationsInput>;
  pInstant?: InputMaybe<IntFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  sMax?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  sMin?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutMinersInput>;
  stakes?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  v?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  vUpdatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  ve?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutMinersInput>;
  workerPublicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersUpdateManyWithoutMinersMinersToWorkersCurrentMinerIdInput>;
  workersMinersWorkerIdToWorkers?: InputMaybe<WorkersUpdateOneRequiredWithoutMinersMinersWorkerIdToWorkersInput>;
};

export type MinersUpdateWithoutStakePoolsInput = {
  active?: InputMaybe<BoolFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  coolingDownStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  current?: InputMaybe<BoolFieldUpdateOperationsInput>;
  estimatesReclaimableAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  iterations?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastChallengedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minerActivities?: InputMaybe<MinerActivitiesUpdateManyWithoutMinersInput>;
  miningStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  pInit?: InputMaybe<IntFieldUpdateOperationsInput>;
  pInstant?: InputMaybe<IntFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  sMax?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  sMin?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakes?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  v?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  vUpdatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  ve?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutMinersInput>;
  workerPublicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersUpdateManyWithoutMinersMinersToWorkersCurrentMinerIdInput>;
  workersMinersWorkerIdToWorkers?: InputMaybe<WorkersUpdateOneRequiredWithoutMinersMinersWorkerIdToWorkersInput>;
};

export type MinersUpdateWithoutWorkerActivitiesInput = {
  active?: InputMaybe<BoolFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  coolingDownStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  current?: InputMaybe<BoolFieldUpdateOperationsInput>;
  estimatesReclaimableAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  iterations?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastChallengedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minerActivities?: InputMaybe<MinerActivitiesUpdateManyWithoutMinersInput>;
  miningStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  pInit?: InputMaybe<IntFieldUpdateOperationsInput>;
  pInstant?: InputMaybe<IntFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  sMax?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  sMin?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutMinersInput>;
  stakes?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  v?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  vUpdatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  ve?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  workerPublicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersUpdateManyWithoutMinersMinersToWorkersCurrentMinerIdInput>;
  workersMinersWorkerIdToWorkers?: InputMaybe<WorkersUpdateOneRequiredWithoutMinersMinersWorkerIdToWorkersInput>;
};

export type MinersUpdateWithoutWorkersMinersToWorkersCurrentMinerIdsInput = {
  active?: InputMaybe<BoolFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  coolingDownStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  current?: InputMaybe<BoolFieldUpdateOperationsInput>;
  estimatesReclaimableAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  iterations?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastChallengedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minerActivities?: InputMaybe<MinerActivitiesUpdateManyWithoutMinersInput>;
  miningStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  pInit?: InputMaybe<IntFieldUpdateOperationsInput>;
  pInstant?: InputMaybe<IntFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  sMax?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  sMin?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutMinersInput>;
  stakes?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  v?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  vUpdatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  ve?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutMinersInput>;
  workerPublicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  workersMinersWorkerIdToWorkers?: InputMaybe<WorkersUpdateOneRequiredWithoutMinersMinersWorkerIdToWorkersInput>;
};

export type MinersUpdateWithoutWorkersMinersWorkerIdToWorkersInput = {
  active?: InputMaybe<BoolFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  coolingDownStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  current?: InputMaybe<BoolFieldUpdateOperationsInput>;
  estimatesReclaimableAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  iterations?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastChallengedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minerActivities?: InputMaybe<MinerActivitiesUpdateManyWithoutMinersInput>;
  miningStartedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  pInit?: InputMaybe<IntFieldUpdateOperationsInput>;
  pInstant?: InputMaybe<IntFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  sMax?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  sMin?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutMinersInput>;
  stakes?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  v?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  vUpdatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  ve?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutMinersInput>;
  workerPublicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersUpdateManyWithoutMinersMinersToWorkersCurrentMinerIdInput>;
};

export type MinersUpsertWithWhereUniqueWithoutStakePoolsInput = {
  create: MinersCreateWithoutStakePoolsInput;
  update: MinersUpdateWithoutStakePoolsInput;
  where: MinersWhereUniqueInput;
};

export type MinersUpsertWithWhereUniqueWithoutWorkersMinersWorkerIdToWorkersInput = {
  create: MinersCreateWithoutWorkersMinersWorkerIdToWorkersInput;
  update: MinersUpdateWithoutWorkersMinersWorkerIdToWorkersInput;
  where: MinersWhereUniqueInput;
};

export type MinersUpsertWithoutMinerActivitiesInput = {
  create: MinersCreateWithoutMinerActivitiesInput;
  update: MinersUpdateWithoutMinerActivitiesInput;
};

export type MinersUpsertWithoutWorkerActivitiesInput = {
  create: MinersCreateWithoutWorkerActivitiesInput;
  update: MinersUpdateWithoutWorkerActivitiesInput;
};

export type MinersUpsertWithoutWorkersMinersToWorkersCurrentMinerIdsInput = {
  create: MinersCreateWithoutWorkersMinersToWorkersCurrentMinerIdsInput;
  update: MinersUpdateWithoutWorkersMinersToWorkersCurrentMinerIdsInput;
};

export type MinersWhereInput = {
  AND?: InputMaybe<Array<MinersWhereInput>>;
  NOT?: InputMaybe<Array<MinersWhereInput>>;
  OR?: InputMaybe<Array<MinersWhereInput>>;
  active?: InputMaybe<BoolFilter>;
  address?: InputMaybe<StringFilter>;
  coolingDownStartedAt?: InputMaybe<DateTimeNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  current?: InputMaybe<BoolFilter>;
  estimatesReclaimableAt?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<BigIntFilter>;
  iterations?: InputMaybe<BigIntFilter>;
  lastChallengedAt?: InputMaybe<DateTimeNullableFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  minerActivities?: InputMaybe<MinerActivitiesListRelationFilter>;
  miningStartedAt?: InputMaybe<DateTimeNullableFilter>;
  pInit?: InputMaybe<IntFilter>;
  pInstant?: InputMaybe<IntFilter>;
  pid?: InputMaybe<IntFilter>;
  sMax?: InputMaybe<DecimalFilter>;
  sMin?: InputMaybe<DecimalFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stakePoolId?: InputMaybe<BigIntFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  stakes?: InputMaybe<DecimalFilter>;
  state?: InputMaybe<StringFilter>;
  totalReward?: InputMaybe<DecimalFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  v?: InputMaybe<DecimalFilter>;
  vUpdatedAt?: InputMaybe<DateTimeNullableFilter>;
  ve?: InputMaybe<DecimalFilter>;
  workerActivities?: InputMaybe<WorkerActivitiesListRelationFilter>;
  workerId?: InputMaybe<BigIntFilter>;
  workerPublicKey?: InputMaybe<StringFilter>;
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersListRelationFilter>;
  workersMinersWorkerIdToWorkers?: InputMaybe<WorkersRelationFilter>;
};

export type MinersWhereUniqueInput = {
  address?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createAccounts: Accounts;
  createArInternalMetadata: ArInternalMetadata;
  createEvents: Events;
  createManyAccounts: AffectedRowsOutput;
  createManyArInternalMetadata: AffectedRowsOutput;
  createManyEvents: AffectedRowsOutput;
  createManyMinerActivities: AffectedRowsOutput;
  createManyMiners: AffectedRowsOutput;
  createManySchemaMigrations: AffectedRowsOutput;
  createManyStakePoolActivities: AffectedRowsOutput;
  createManyStakePoolStakerActivities: AffectedRowsOutput;
  createManyStakePoolStakers: AffectedRowsOutput;
  createManyStakePoolWithdrawals: AffectedRowsOutput;
  createManyStakePools: AffectedRowsOutput;
  createManyStates: AffectedRowsOutput;
  createManyWorkerActivities: AffectedRowsOutput;
  createManyWorkers: AffectedRowsOutput;
  createMinerActivities: MinerActivities;
  createMiners: Miners;
  createSchemaMigrations: SchemaMigrations;
  createStakePoolActivities: StakePoolActivities;
  createStakePoolStakerActivities: StakePoolStakerActivities;
  createStakePoolStakers: StakePoolStakers;
  createStakePoolWithdrawals: StakePoolWithdrawals;
  createStakePools: StakePools;
  createStates: States;
  createWorkerActivities: WorkerActivities;
  createWorkers: Workers;
  deleteAccounts?: Maybe<Accounts>;
  deleteArInternalMetadata?: Maybe<ArInternalMetadata>;
  deleteEvents?: Maybe<Events>;
  deleteManyAccounts: AffectedRowsOutput;
  deleteManyArInternalMetadata: AffectedRowsOutput;
  deleteManyEvents: AffectedRowsOutput;
  deleteManyMinerActivities: AffectedRowsOutput;
  deleteManyMiners: AffectedRowsOutput;
  deleteManySchemaMigrations: AffectedRowsOutput;
  deleteManyStakePoolActivities: AffectedRowsOutput;
  deleteManyStakePoolStakerActivities: AffectedRowsOutput;
  deleteManyStakePoolStakers: AffectedRowsOutput;
  deleteManyStakePoolWithdrawals: AffectedRowsOutput;
  deleteManyStakePools: AffectedRowsOutput;
  deleteManyStates: AffectedRowsOutput;
  deleteManyWorkerActivities: AffectedRowsOutput;
  deleteManyWorkers: AffectedRowsOutput;
  deleteMinerActivities?: Maybe<MinerActivities>;
  deleteMiners?: Maybe<Miners>;
  deleteSchemaMigrations?: Maybe<SchemaMigrations>;
  deleteStakePoolActivities?: Maybe<StakePoolActivities>;
  deleteStakePoolStakerActivities?: Maybe<StakePoolStakerActivities>;
  deleteStakePoolStakers?: Maybe<StakePoolStakers>;
  deleteStakePoolWithdrawals?: Maybe<StakePoolWithdrawals>;
  deleteStakePools?: Maybe<StakePools>;
  deleteStates?: Maybe<States>;
  deleteWorkerActivities?: Maybe<WorkerActivities>;
  deleteWorkers?: Maybe<Workers>;
  updateAccounts?: Maybe<Accounts>;
  updateArInternalMetadata?: Maybe<ArInternalMetadata>;
  updateEvents?: Maybe<Events>;
  updateManyAccounts: AffectedRowsOutput;
  updateManyArInternalMetadata: AffectedRowsOutput;
  updateManyEvents: AffectedRowsOutput;
  updateManyMinerActivities: AffectedRowsOutput;
  updateManyMiners: AffectedRowsOutput;
  updateManySchemaMigrations: AffectedRowsOutput;
  updateManyStakePoolActivities: AffectedRowsOutput;
  updateManyStakePoolStakerActivities: AffectedRowsOutput;
  updateManyStakePoolStakers: AffectedRowsOutput;
  updateManyStakePoolWithdrawals: AffectedRowsOutput;
  updateManyStakePools: AffectedRowsOutput;
  updateManyStates: AffectedRowsOutput;
  updateManyWorkerActivities: AffectedRowsOutput;
  updateManyWorkers: AffectedRowsOutput;
  updateMinerActivities?: Maybe<MinerActivities>;
  updateMiners?: Maybe<Miners>;
  updateSchemaMigrations?: Maybe<SchemaMigrations>;
  updateStakePoolActivities?: Maybe<StakePoolActivities>;
  updateStakePoolStakerActivities?: Maybe<StakePoolStakerActivities>;
  updateStakePoolStakers?: Maybe<StakePoolStakers>;
  updateStakePoolWithdrawals?: Maybe<StakePoolWithdrawals>;
  updateStakePools?: Maybe<StakePools>;
  updateStates?: Maybe<States>;
  updateWorkerActivities?: Maybe<WorkerActivities>;
  updateWorkers?: Maybe<Workers>;
  upsertAccounts: Accounts;
  upsertArInternalMetadata: ArInternalMetadata;
  upsertEvents: Events;
  upsertMinerActivities: MinerActivities;
  upsertMiners: Miners;
  upsertSchemaMigrations: SchemaMigrations;
  upsertStakePoolActivities: StakePoolActivities;
  upsertStakePoolStakerActivities: StakePoolStakerActivities;
  upsertStakePoolStakers: StakePoolStakers;
  upsertStakePoolWithdrawals: StakePoolWithdrawals;
  upsertStakePools: StakePools;
  upsertStates: States;
  upsertWorkerActivities: WorkerActivities;
  upsertWorkers: Workers;
};


export type MutationCreateAccountsArgs = {
  data: AccountsCreateInput;
};


export type MutationCreateArInternalMetadataArgs = {
  data: ArInternalMetadataCreateInput;
};


export type MutationCreateEventsArgs = {
  data: EventsCreateInput;
};


export type MutationCreateManyAccountsArgs = {
  data: Array<AccountsCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManyArInternalMetadataArgs = {
  data: Array<ArInternalMetadataCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManyEventsArgs = {
  data: Array<EventsCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManyMinerActivitiesArgs = {
  data: Array<MinerActivitiesCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManyMinersArgs = {
  data: Array<MinersCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManySchemaMigrationsArgs = {
  data: Array<SchemaMigrationsCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManyStakePoolActivitiesArgs = {
  data: Array<StakePoolActivitiesCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManyStakePoolStakerActivitiesArgs = {
  data: Array<StakePoolStakerActivitiesCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManyStakePoolStakersArgs = {
  data: Array<StakePoolStakersCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManyStakePoolWithdrawalsArgs = {
  data: Array<StakePoolWithdrawalsCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManyStakePoolsArgs = {
  data: Array<StakePoolsCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManyStatesArgs = {
  data: Array<StatesCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManyWorkerActivitiesArgs = {
  data: Array<WorkerActivitiesCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateManyWorkersArgs = {
  data: Array<WorkersCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};


export type MutationCreateMinerActivitiesArgs = {
  data: MinerActivitiesCreateInput;
};


export type MutationCreateMinersArgs = {
  data: MinersCreateInput;
};


export type MutationCreateSchemaMigrationsArgs = {
  data: SchemaMigrationsCreateInput;
};


export type MutationCreateStakePoolActivitiesArgs = {
  data: StakePoolActivitiesCreateInput;
};


export type MutationCreateStakePoolStakerActivitiesArgs = {
  data: StakePoolStakerActivitiesCreateInput;
};


export type MutationCreateStakePoolStakersArgs = {
  data: StakePoolStakersCreateInput;
};


export type MutationCreateStakePoolWithdrawalsArgs = {
  data: StakePoolWithdrawalsCreateInput;
};


export type MutationCreateStakePoolsArgs = {
  data: StakePoolsCreateInput;
};


export type MutationCreateStatesArgs = {
  data: StatesCreateInput;
};


export type MutationCreateWorkerActivitiesArgs = {
  data: WorkerActivitiesCreateInput;
};


export type MutationCreateWorkersArgs = {
  data: WorkersCreateInput;
};


export type MutationDeleteAccountsArgs = {
  where: AccountsWhereUniqueInput;
};


export type MutationDeleteArInternalMetadataArgs = {
  where: ArInternalMetadataWhereUniqueInput;
};


export type MutationDeleteEventsArgs = {
  where: EventsWhereUniqueInput;
};


export type MutationDeleteManyAccountsArgs = {
  where?: InputMaybe<AccountsWhereInput>;
};


export type MutationDeleteManyArInternalMetadataArgs = {
  where?: InputMaybe<ArInternalMetadataWhereInput>;
};


export type MutationDeleteManyEventsArgs = {
  where?: InputMaybe<EventsWhereInput>;
};


export type MutationDeleteManyMinerActivitiesArgs = {
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type MutationDeleteManyMinersArgs = {
  where?: InputMaybe<MinersWhereInput>;
};


export type MutationDeleteManySchemaMigrationsArgs = {
  where?: InputMaybe<SchemaMigrationsWhereInput>;
};


export type MutationDeleteManyStakePoolActivitiesArgs = {
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type MutationDeleteManyStakePoolStakerActivitiesArgs = {
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};


export type MutationDeleteManyStakePoolStakersArgs = {
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type MutationDeleteManyStakePoolWithdrawalsArgs = {
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type MutationDeleteManyStakePoolsArgs = {
  where?: InputMaybe<StakePoolsWhereInput>;
};


export type MutationDeleteManyStatesArgs = {
  where?: InputMaybe<StatesWhereInput>;
};


export type MutationDeleteManyWorkerActivitiesArgs = {
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type MutationDeleteManyWorkersArgs = {
  where?: InputMaybe<WorkersWhereInput>;
};


export type MutationDeleteMinerActivitiesArgs = {
  where: MinerActivitiesWhereUniqueInput;
};


export type MutationDeleteMinersArgs = {
  where: MinersWhereUniqueInput;
};


export type MutationDeleteSchemaMigrationsArgs = {
  where: SchemaMigrationsWhereUniqueInput;
};


export type MutationDeleteStakePoolActivitiesArgs = {
  where: StakePoolActivitiesWhereUniqueInput;
};


export type MutationDeleteStakePoolStakerActivitiesArgs = {
  where: StakePoolStakerActivitiesWhereUniqueInput;
};


export type MutationDeleteStakePoolStakersArgs = {
  where: StakePoolStakersWhereUniqueInput;
};


export type MutationDeleteStakePoolWithdrawalsArgs = {
  where: StakePoolWithdrawalsWhereUniqueInput;
};


export type MutationDeleteStakePoolsArgs = {
  where: StakePoolsWhereUniqueInput;
};


export type MutationDeleteStatesArgs = {
  where: StatesWhereUniqueInput;
};


export type MutationDeleteWorkerActivitiesArgs = {
  where: WorkerActivitiesWhereUniqueInput;
};


export type MutationDeleteWorkersArgs = {
  where: WorkersWhereUniqueInput;
};


export type MutationUpdateAccountsArgs = {
  data: AccountsUpdateInput;
  where: AccountsWhereUniqueInput;
};


export type MutationUpdateArInternalMetadataArgs = {
  data: ArInternalMetadataUpdateInput;
  where: ArInternalMetadataWhereUniqueInput;
};


export type MutationUpdateEventsArgs = {
  data: EventsUpdateInput;
  where: EventsWhereUniqueInput;
};


export type MutationUpdateManyAccountsArgs = {
  data: AccountsUpdateManyMutationInput;
  where?: InputMaybe<AccountsWhereInput>;
};


export type MutationUpdateManyArInternalMetadataArgs = {
  data: ArInternalMetadataUpdateManyMutationInput;
  where?: InputMaybe<ArInternalMetadataWhereInput>;
};


export type MutationUpdateManyEventsArgs = {
  data: EventsUpdateManyMutationInput;
  where?: InputMaybe<EventsWhereInput>;
};


export type MutationUpdateManyMinerActivitiesArgs = {
  data: MinerActivitiesUpdateManyMutationInput;
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type MutationUpdateManyMinersArgs = {
  data: MinersUpdateManyMutationInput;
  where?: InputMaybe<MinersWhereInput>;
};


export type MutationUpdateManySchemaMigrationsArgs = {
  data: SchemaMigrationsUpdateManyMutationInput;
  where?: InputMaybe<SchemaMigrationsWhereInput>;
};


export type MutationUpdateManyStakePoolActivitiesArgs = {
  data: StakePoolActivitiesUpdateManyMutationInput;
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type MutationUpdateManyStakePoolStakerActivitiesArgs = {
  data: StakePoolStakerActivitiesUpdateManyMutationInput;
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};


export type MutationUpdateManyStakePoolStakersArgs = {
  data: StakePoolStakersUpdateManyMutationInput;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type MutationUpdateManyStakePoolWithdrawalsArgs = {
  data: StakePoolWithdrawalsUpdateManyMutationInput;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type MutationUpdateManyStakePoolsArgs = {
  data: StakePoolsUpdateManyMutationInput;
  where?: InputMaybe<StakePoolsWhereInput>;
};


export type MutationUpdateManyStatesArgs = {
  data: StatesUpdateManyMutationInput;
  where?: InputMaybe<StatesWhereInput>;
};


export type MutationUpdateManyWorkerActivitiesArgs = {
  data: WorkerActivitiesUpdateManyMutationInput;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type MutationUpdateManyWorkersArgs = {
  data: WorkersUpdateManyMutationInput;
  where?: InputMaybe<WorkersWhereInput>;
};


export type MutationUpdateMinerActivitiesArgs = {
  data: MinerActivitiesUpdateInput;
  where: MinerActivitiesWhereUniqueInput;
};


export type MutationUpdateMinersArgs = {
  data: MinersUpdateInput;
  where: MinersWhereUniqueInput;
};


export type MutationUpdateSchemaMigrationsArgs = {
  data: SchemaMigrationsUpdateInput;
  where: SchemaMigrationsWhereUniqueInput;
};


export type MutationUpdateStakePoolActivitiesArgs = {
  data: StakePoolActivitiesUpdateInput;
  where: StakePoolActivitiesWhereUniqueInput;
};


export type MutationUpdateStakePoolStakerActivitiesArgs = {
  data: StakePoolStakerActivitiesUpdateInput;
  where: StakePoolStakerActivitiesWhereUniqueInput;
};


export type MutationUpdateStakePoolStakersArgs = {
  data: StakePoolStakersUpdateInput;
  where: StakePoolStakersWhereUniqueInput;
};


export type MutationUpdateStakePoolWithdrawalsArgs = {
  data: StakePoolWithdrawalsUpdateInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};


export type MutationUpdateStakePoolsArgs = {
  data: StakePoolsUpdateInput;
  where: StakePoolsWhereUniqueInput;
};


export type MutationUpdateStatesArgs = {
  data: StatesUpdateInput;
  where: StatesWhereUniqueInput;
};


export type MutationUpdateWorkerActivitiesArgs = {
  data: WorkerActivitiesUpdateInput;
  where: WorkerActivitiesWhereUniqueInput;
};


export type MutationUpdateWorkersArgs = {
  data: WorkersUpdateInput;
  where: WorkersWhereUniqueInput;
};


export type MutationUpsertAccountsArgs = {
  create: AccountsCreateInput;
  update: AccountsUpdateInput;
  where: AccountsWhereUniqueInput;
};


export type MutationUpsertArInternalMetadataArgs = {
  create: ArInternalMetadataCreateInput;
  update: ArInternalMetadataUpdateInput;
  where: ArInternalMetadataWhereUniqueInput;
};


export type MutationUpsertEventsArgs = {
  create: EventsCreateInput;
  update: EventsUpdateInput;
  where: EventsWhereUniqueInput;
};


export type MutationUpsertMinerActivitiesArgs = {
  create: MinerActivitiesCreateInput;
  update: MinerActivitiesUpdateInput;
  where: MinerActivitiesWhereUniqueInput;
};


export type MutationUpsertMinersArgs = {
  create: MinersCreateInput;
  update: MinersUpdateInput;
  where: MinersWhereUniqueInput;
};


export type MutationUpsertSchemaMigrationsArgs = {
  create: SchemaMigrationsCreateInput;
  update: SchemaMigrationsUpdateInput;
  where: SchemaMigrationsWhereUniqueInput;
};


export type MutationUpsertStakePoolActivitiesArgs = {
  create: StakePoolActivitiesCreateInput;
  update: StakePoolActivitiesUpdateInput;
  where: StakePoolActivitiesWhereUniqueInput;
};


export type MutationUpsertStakePoolStakerActivitiesArgs = {
  create: StakePoolStakerActivitiesCreateInput;
  update: StakePoolStakerActivitiesUpdateInput;
  where: StakePoolStakerActivitiesWhereUniqueInput;
};


export type MutationUpsertStakePoolStakersArgs = {
  create: StakePoolStakersCreateInput;
  update: StakePoolStakersUpdateInput;
  where: StakePoolStakersWhereUniqueInput;
};


export type MutationUpsertStakePoolWithdrawalsArgs = {
  create: StakePoolWithdrawalsCreateInput;
  update: StakePoolWithdrawalsUpdateInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};


export type MutationUpsertStakePoolsArgs = {
  create: StakePoolsCreateInput;
  update: StakePoolsUpdateInput;
  where: StakePoolsWhereUniqueInput;
};


export type MutationUpsertStatesArgs = {
  create: StatesCreateInput;
  update: StatesUpdateInput;
  where: StatesWhereUniqueInput;
};


export type MutationUpsertWorkerActivitiesArgs = {
  create: WorkerActivitiesCreateInput;
  update: WorkerActivitiesUpdateInput;
  where: WorkerActivitiesWhereUniqueInput;
};


export type MutationUpsertWorkersArgs = {
  create: WorkersCreateInput;
  update: WorkersUpdateInput;
  where: WorkersWhereUniqueInput;
};

export type NestedBigIntFilter = {
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type NestedBigIntNullableFilter = {
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type NestedBigIntNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedBigIntNullableFilter>;
  _min?: InputMaybe<NestedBigIntNullableFilter>;
  _sum?: InputMaybe<NestedBigIntNullableFilter>;
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type NestedBigIntWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBigIntFilter>;
  _min?: InputMaybe<NestedBigIntFilter>;
  _sum?: InputMaybe<NestedBigIntFilter>;
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type NestedBoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type NestedBoolNullableFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolNullableFilter>;
};

export type NestedBoolNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedBoolNullableFilter>;
  _min?: InputMaybe<NestedBoolNullableFilter>;
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolNullableWithAggregatesFilter>;
};

export type NestedBoolWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBoolFilter>;
  _min?: InputMaybe<NestedBoolFilter>;
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolWithAggregatesFilter>;
};

export type NestedDateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedDateTimeNullableFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedDateTimeNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDateTimeNullableFilter>;
  _min?: InputMaybe<NestedDateTimeNullableFilter>;
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedDateTimeWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedDateTimeFilter>;
  _min?: InputMaybe<NestedDateTimeFilter>;
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedDecimalFilter = {
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type NestedDecimalNullableFilter = {
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type NestedDecimalNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedDecimalNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDecimalNullableFilter>;
  _min?: InputMaybe<NestedDecimalNullableFilter>;
  _sum?: InputMaybe<NestedDecimalNullableFilter>;
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type NestedDecimalWithAggregatesFilter = {
  _avg?: InputMaybe<NestedDecimalFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedDecimalFilter>;
  _min?: InputMaybe<NestedDecimalFilter>;
  _sum?: InputMaybe<NestedDecimalFilter>;
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type NestedFloatFilter = {
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export type NestedFloatNullableFilter = {
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export type NestedIntFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type NestedIntNullableFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type NestedIntNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedIntNullableFilter>;
  _min?: InputMaybe<NestedIntNullableFilter>;
  _sum?: InputMaybe<NestedIntNullableFilter>;
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type NestedIntWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedIntFilter>;
  _min?: InputMaybe<NestedIntFilter>;
  _sum?: InputMaybe<NestedIntFilter>;
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type NestedStringFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type NestedStringNullableFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type NestedStringNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedStringNullableFilter>;
  _min?: InputMaybe<NestedStringNullableFilter>;
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type NestedStringWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedStringFilter>;
  _min?: InputMaybe<NestedStringFilter>;
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type NullableBigIntFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['BigInt']>;
  divide?: InputMaybe<Scalars['BigInt']>;
  increment?: InputMaybe<Scalars['BigInt']>;
  multiply?: InputMaybe<Scalars['BigInt']>;
  set?: InputMaybe<Scalars['BigInt']>;
};

export type NullableBoolFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['Boolean']>;
};

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['DateTime']>;
};

export type NullableDecimalFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Decimal']>;
  divide?: InputMaybe<Scalars['Decimal']>;
  increment?: InputMaybe<Scalars['Decimal']>;
  multiply?: InputMaybe<Scalars['Decimal']>;
  set?: InputMaybe<Scalars['Decimal']>;
};

export type NullableIntFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Int']>;
  divide?: InputMaybe<Scalars['Int']>;
  increment?: InputMaybe<Scalars['Int']>;
  multiply?: InputMaybe<Scalars['Int']>;
  set?: InputMaybe<Scalars['Int']>;
};

export type NullableStringFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['String']>;
};

export type Query = {
  __typename?: 'Query';
  aggregateAccounts: AggregateAccounts;
  aggregateArInternalMetadata: AggregateArInternalMetadata;
  aggregateEvents: AggregateEvents;
  aggregateMinerActivities: AggregateMinerActivities;
  aggregateMiners: AggregateMiners;
  aggregateSchemaMigrations: AggregateSchemaMigrations;
  aggregateStakePoolActivities: AggregateStakePoolActivities;
  aggregateStakePoolStakerActivities: AggregateStakePoolStakerActivities;
  aggregateStakePoolStakers: AggregateStakePoolStakers;
  aggregateStakePoolWithdrawals: AggregateStakePoolWithdrawals;
  aggregateStakePools: AggregateStakePools;
  aggregateStates: AggregateStates;
  aggregateWorkerActivities: AggregateWorkerActivities;
  aggregateWorkers: AggregateWorkers;
  findFirstAccounts?: Maybe<Accounts>;
  findFirstArInternalMetadata?: Maybe<ArInternalMetadata>;
  findFirstEvents?: Maybe<Events>;
  findFirstMinerActivities?: Maybe<MinerActivities>;
  findFirstMiners?: Maybe<Miners>;
  findFirstSchemaMigrations?: Maybe<SchemaMigrations>;
  findFirstStakePoolActivities?: Maybe<StakePoolActivities>;
  findFirstStakePoolStakerActivities?: Maybe<StakePoolStakerActivities>;
  findFirstStakePoolStakers?: Maybe<StakePoolStakers>;
  findFirstStakePoolWithdrawals?: Maybe<StakePoolWithdrawals>;
  findFirstStakePools?: Maybe<StakePools>;
  findFirstStates?: Maybe<States>;
  findFirstWorkerActivities?: Maybe<WorkerActivities>;
  findFirstWorkers?: Maybe<Workers>;
  findManyAccounts: Array<Accounts>;
  findManyArInternalMetadata: Array<ArInternalMetadata>;
  findManyEvents: Array<Events>;
  findManyMinerActivities: Array<MinerActivities>;
  findManyMiners: Array<Miners>;
  findManySchemaMigrations: Array<SchemaMigrations>;
  findManyStakePoolActivities: Array<StakePoolActivities>;
  findManyStakePoolStakerActivities: Array<StakePoolStakerActivities>;
  findManyStakePoolStakers: Array<StakePoolStakers>;
  findManyStakePoolWithdrawals: Array<StakePoolWithdrawals>;
  findManyStakePools: Array<StakePools>;
  findManyStates: Array<States>;
  findManyWorkerActivities: Array<WorkerActivities>;
  findManyWorkers: Array<Workers>;
  findUniqueAccounts?: Maybe<Accounts>;
  findUniqueArInternalMetadata?: Maybe<ArInternalMetadata>;
  findUniqueEvents?: Maybe<Events>;
  findUniqueMinerActivities?: Maybe<MinerActivities>;
  findUniqueMiners?: Maybe<Miners>;
  findUniqueSchemaMigrations?: Maybe<SchemaMigrations>;
  findUniqueStakePoolActivities?: Maybe<StakePoolActivities>;
  findUniqueStakePoolStakerActivities?: Maybe<StakePoolStakerActivities>;
  findUniqueStakePoolStakers?: Maybe<StakePoolStakers>;
  findUniqueStakePoolWithdrawals?: Maybe<StakePoolWithdrawals>;
  findUniqueStakePools?: Maybe<StakePools>;
  findUniqueStates?: Maybe<States>;
  findUniqueWorkerActivities?: Maybe<WorkerActivities>;
  findUniqueWorkers?: Maybe<Workers>;
  groupByAccounts: Array<AccountsGroupBy>;
  groupByArInternalMetadata: Array<ArInternalMetadataGroupBy>;
  groupByEvents: Array<EventsGroupBy>;
  groupByMinerActivities: Array<MinerActivitiesGroupBy>;
  groupByMiners: Array<MinersGroupBy>;
  groupBySchemaMigrations: Array<SchemaMigrationsGroupBy>;
  groupByStakePoolActivities: Array<StakePoolActivitiesGroupBy>;
  groupByStakePoolStakerActivities: Array<StakePoolStakerActivitiesGroupBy>;
  groupByStakePoolStakers: Array<StakePoolStakersGroupBy>;
  groupByStakePoolWithdrawals: Array<StakePoolWithdrawalsGroupBy>;
  groupByStakePools: Array<StakePoolsGroupBy>;
  groupByStates: Array<StatesGroupBy>;
  groupByWorkerActivities: Array<WorkerActivitiesGroupBy>;
  groupByWorkers: Array<WorkersGroupBy>;
};


export type QueryAggregateAccountsArgs = {
  cursor?: InputMaybe<AccountsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<AccountsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountsWhereInput>;
};


export type QueryAggregateArInternalMetadataArgs = {
  cursor?: InputMaybe<ArInternalMetadataWhereUniqueInput>;
  orderBy?: InputMaybe<Array<ArInternalMetadataOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ArInternalMetadataWhereInput>;
};


export type QueryAggregateEventsArgs = {
  cursor?: InputMaybe<EventsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<EventsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EventsWhereInput>;
};


export type QueryAggregateMinerActivitiesArgs = {
  cursor?: InputMaybe<MinerActivitiesWhereUniqueInput>;
  orderBy?: InputMaybe<Array<MinerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type QueryAggregateMinersArgs = {
  cursor?: InputMaybe<MinersWhereUniqueInput>;
  orderBy?: InputMaybe<Array<MinersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinersWhereInput>;
};


export type QueryAggregateSchemaMigrationsArgs = {
  cursor?: InputMaybe<SchemaMigrationsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<SchemaMigrationsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SchemaMigrationsWhereInput>;
};


export type QueryAggregateStakePoolActivitiesArgs = {
  cursor?: InputMaybe<StakePoolActivitiesWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StakePoolActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type QueryAggregateStakePoolStakerActivitiesArgs = {
  cursor?: InputMaybe<StakePoolStakerActivitiesWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StakePoolStakerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};


export type QueryAggregateStakePoolStakersArgs = {
  cursor?: InputMaybe<StakePoolStakersWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StakePoolStakersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type QueryAggregateStakePoolWithdrawalsArgs = {
  cursor?: InputMaybe<StakePoolWithdrawalsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type QueryAggregateStakePoolsArgs = {
  cursor?: InputMaybe<StakePoolsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StakePoolsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolsWhereInput>;
};


export type QueryAggregateStatesArgs = {
  cursor?: InputMaybe<StatesWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StatesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StatesWhereInput>;
};


export type QueryAggregateWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type QueryAggregateWorkersArgs = {
  cursor?: InputMaybe<WorkersWhereUniqueInput>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};


export type QueryFindFirstAccountsArgs = {
  cursor?: InputMaybe<AccountsWhereUniqueInput>;
  distinct?: InputMaybe<Array<AccountsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AccountsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountsWhereInput>;
};


export type QueryFindFirstArInternalMetadataArgs = {
  cursor?: InputMaybe<ArInternalMetadataWhereUniqueInput>;
  distinct?: InputMaybe<Array<ArInternalMetadataScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ArInternalMetadataOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ArInternalMetadataWhereInput>;
};


export type QueryFindFirstEventsArgs = {
  cursor?: InputMaybe<EventsWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EventsWhereInput>;
};


export type QueryFindFirstMinerActivitiesArgs = {
  cursor?: InputMaybe<MinerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type QueryFindFirstMinersArgs = {
  cursor?: InputMaybe<MinersWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinersWhereInput>;
};


export type QueryFindFirstSchemaMigrationsArgs = {
  cursor?: InputMaybe<SchemaMigrationsWhereUniqueInput>;
  distinct?: InputMaybe<Array<SchemaMigrationsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<SchemaMigrationsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SchemaMigrationsWhereInput>;
};


export type QueryFindFirstStakePoolActivitiesArgs = {
  cursor?: InputMaybe<StakePoolActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type QueryFindFirstStakePoolStakerActivitiesArgs = {
  cursor?: InputMaybe<StakePoolStakerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};


export type QueryFindFirstStakePoolStakersArgs = {
  cursor?: InputMaybe<StakePoolStakersWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type QueryFindFirstStakePoolWithdrawalsArgs = {
  cursor?: InputMaybe<StakePoolWithdrawalsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolWithdrawalsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type QueryFindFirstStakePoolsArgs = {
  cursor?: InputMaybe<StakePoolsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolsWhereInput>;
};


export type QueryFindFirstStatesArgs = {
  cursor?: InputMaybe<StatesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StatesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StatesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StatesWhereInput>;
};


export type QueryFindFirstWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type QueryFindFirstWorkersArgs = {
  cursor?: InputMaybe<WorkersWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};


export type QueryFindManyAccountsArgs = {
  cursor?: InputMaybe<AccountsWhereUniqueInput>;
  distinct?: InputMaybe<Array<AccountsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AccountsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountsWhereInput>;
};


export type QueryFindManyArInternalMetadataArgs = {
  cursor?: InputMaybe<ArInternalMetadataWhereUniqueInput>;
  distinct?: InputMaybe<Array<ArInternalMetadataScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ArInternalMetadataOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ArInternalMetadataWhereInput>;
};


export type QueryFindManyEventsArgs = {
  cursor?: InputMaybe<EventsWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EventsWhereInput>;
};


export type QueryFindManyMinerActivitiesArgs = {
  cursor?: InputMaybe<MinerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type QueryFindManyMinersArgs = {
  cursor?: InputMaybe<MinersWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinersWhereInput>;
};


export type QueryFindManySchemaMigrationsArgs = {
  cursor?: InputMaybe<SchemaMigrationsWhereUniqueInput>;
  distinct?: InputMaybe<Array<SchemaMigrationsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<SchemaMigrationsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SchemaMigrationsWhereInput>;
};


export type QueryFindManyStakePoolActivitiesArgs = {
  cursor?: InputMaybe<StakePoolActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type QueryFindManyStakePoolStakerActivitiesArgs = {
  cursor?: InputMaybe<StakePoolStakerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};


export type QueryFindManyStakePoolStakersArgs = {
  cursor?: InputMaybe<StakePoolStakersWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type QueryFindManyStakePoolWithdrawalsArgs = {
  cursor?: InputMaybe<StakePoolWithdrawalsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolWithdrawalsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type QueryFindManyStakePoolsArgs = {
  cursor?: InputMaybe<StakePoolsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolsWhereInput>;
};


export type QueryFindManyStatesArgs = {
  cursor?: InputMaybe<StatesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StatesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StatesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StatesWhereInput>;
};


export type QueryFindManyWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type QueryFindManyWorkersArgs = {
  cursor?: InputMaybe<WorkersWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};


export type QueryFindUniqueAccountsArgs = {
  where: AccountsWhereUniqueInput;
};


export type QueryFindUniqueArInternalMetadataArgs = {
  where: ArInternalMetadataWhereUniqueInput;
};


export type QueryFindUniqueEventsArgs = {
  where: EventsWhereUniqueInput;
};


export type QueryFindUniqueMinerActivitiesArgs = {
  where: MinerActivitiesWhereUniqueInput;
};


export type QueryFindUniqueMinersArgs = {
  where: MinersWhereUniqueInput;
};


export type QueryFindUniqueSchemaMigrationsArgs = {
  where: SchemaMigrationsWhereUniqueInput;
};


export type QueryFindUniqueStakePoolActivitiesArgs = {
  where: StakePoolActivitiesWhereUniqueInput;
};


export type QueryFindUniqueStakePoolStakerActivitiesArgs = {
  where: StakePoolStakerActivitiesWhereUniqueInput;
};


export type QueryFindUniqueStakePoolStakersArgs = {
  where: StakePoolStakersWhereUniqueInput;
};


export type QueryFindUniqueStakePoolWithdrawalsArgs = {
  where: StakePoolWithdrawalsWhereUniqueInput;
};


export type QueryFindUniqueStakePoolsArgs = {
  where: StakePoolsWhereUniqueInput;
};


export type QueryFindUniqueStatesArgs = {
  where: StatesWhereUniqueInput;
};


export type QueryFindUniqueWorkerActivitiesArgs = {
  where: WorkerActivitiesWhereUniqueInput;
};


export type QueryFindUniqueWorkersArgs = {
  where: WorkersWhereUniqueInput;
};


export type QueryGroupByAccountsArgs = {
  by: Array<AccountsScalarFieldEnum>;
  having?: InputMaybe<AccountsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<AccountsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountsWhereInput>;
};


export type QueryGroupByArInternalMetadataArgs = {
  by: Array<ArInternalMetadataScalarFieldEnum>;
  having?: InputMaybe<ArInternalMetadataScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<ArInternalMetadataOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ArInternalMetadataWhereInput>;
};


export type QueryGroupByEventsArgs = {
  by: Array<EventsScalarFieldEnum>;
  having?: InputMaybe<EventsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<EventsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EventsWhereInput>;
};


export type QueryGroupByMinerActivitiesArgs = {
  by: Array<MinerActivitiesScalarFieldEnum>;
  having?: InputMaybe<MinerActivitiesScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<MinerActivitiesOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type QueryGroupByMinersArgs = {
  by: Array<MinersScalarFieldEnum>;
  having?: InputMaybe<MinersScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<MinersOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinersWhereInput>;
};


export type QueryGroupBySchemaMigrationsArgs = {
  by: Array<SchemaMigrationsScalarFieldEnum>;
  having?: InputMaybe<SchemaMigrationsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<SchemaMigrationsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SchemaMigrationsWhereInput>;
};


export type QueryGroupByStakePoolActivitiesArgs = {
  by: Array<StakePoolActivitiesScalarFieldEnum>;
  having?: InputMaybe<StakePoolActivitiesScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StakePoolActivitiesOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type QueryGroupByStakePoolStakerActivitiesArgs = {
  by: Array<StakePoolStakerActivitiesScalarFieldEnum>;
  having?: InputMaybe<StakePoolStakerActivitiesScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StakePoolStakerActivitiesOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};


export type QueryGroupByStakePoolStakersArgs = {
  by: Array<StakePoolStakersScalarFieldEnum>;
  having?: InputMaybe<StakePoolStakersScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StakePoolStakersOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type QueryGroupByStakePoolWithdrawalsArgs = {
  by: Array<StakePoolWithdrawalsScalarFieldEnum>;
  having?: InputMaybe<StakePoolWithdrawalsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type QueryGroupByStakePoolsArgs = {
  by: Array<StakePoolsScalarFieldEnum>;
  having?: InputMaybe<StakePoolsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StakePoolsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolsWhereInput>;
};


export type QueryGroupByStatesArgs = {
  by: Array<StatesScalarFieldEnum>;
  having?: InputMaybe<StatesScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StatesOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StatesWhereInput>;
};


export type QueryGroupByWorkerActivitiesArgs = {
  by: Array<WorkerActivitiesScalarFieldEnum>;
  having?: InputMaybe<WorkerActivitiesScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type QueryGroupByWorkersArgs = {
  by: Array<WorkersScalarFieldEnum>;
  having?: InputMaybe<WorkersScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive'
}

export type SchemaMigrations = {
  __typename?: 'SchemaMigrations';
  version: Scalars['String'];
};

export type SchemaMigrationsCountAggregate = {
  __typename?: 'SchemaMigrationsCountAggregate';
  _all: Scalars['Int'];
  version: Scalars['Int'];
};

export type SchemaMigrationsCountOrderByAggregateInput = {
  version?: InputMaybe<SortOrder>;
};

export type SchemaMigrationsCreateInput = {
  version: Scalars['String'];
};

export type SchemaMigrationsCreateManyInput = {
  version: Scalars['String'];
};

export type SchemaMigrationsGroupBy = {
  __typename?: 'SchemaMigrationsGroupBy';
  _count?: Maybe<SchemaMigrationsCountAggregate>;
  _max?: Maybe<SchemaMigrationsMaxAggregate>;
  _min?: Maybe<SchemaMigrationsMinAggregate>;
  version: Scalars['String'];
};

export type SchemaMigrationsMaxAggregate = {
  __typename?: 'SchemaMigrationsMaxAggregate';
  version?: Maybe<Scalars['String']>;
};

export type SchemaMigrationsMaxOrderByAggregateInput = {
  version?: InputMaybe<SortOrder>;
};

export type SchemaMigrationsMinAggregate = {
  __typename?: 'SchemaMigrationsMinAggregate';
  version?: Maybe<Scalars['String']>;
};

export type SchemaMigrationsMinOrderByAggregateInput = {
  version?: InputMaybe<SortOrder>;
};

export type SchemaMigrationsOrderByWithAggregationInput = {
  _count?: InputMaybe<SchemaMigrationsCountOrderByAggregateInput>;
  _max?: InputMaybe<SchemaMigrationsMaxOrderByAggregateInput>;
  _min?: InputMaybe<SchemaMigrationsMinOrderByAggregateInput>;
  version?: InputMaybe<SortOrder>;
};

export type SchemaMigrationsOrderByWithRelationInput = {
  version?: InputMaybe<SortOrder>;
};

export enum SchemaMigrationsScalarFieldEnum {
  Version = 'version'
}

export type SchemaMigrationsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<SchemaMigrationsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<SchemaMigrationsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<SchemaMigrationsScalarWhereWithAggregatesInput>>;
  version?: InputMaybe<StringWithAggregatesFilter>;
};

export type SchemaMigrationsUpdateInput = {
  version?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type SchemaMigrationsUpdateManyMutationInput = {
  version?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type SchemaMigrationsWhereInput = {
  AND?: InputMaybe<Array<SchemaMigrationsWhereInput>>;
  NOT?: InputMaybe<Array<SchemaMigrationsWhereInput>>;
  OR?: InputMaybe<Array<SchemaMigrationsWhereInput>>;
  version?: InputMaybe<StringFilter>;
};

export type SchemaMigrationsWhereUniqueInput = {
  version?: InputMaybe<Scalars['String']>;
};

export enum SortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type StakePoolActivities = {
  __typename?: 'StakePoolActivities';
  blockNumber: Scalars['BigInt'];
  cap?: Maybe<Scalars['Decimal']>;
  commission: Scalars['Decimal'];
  coolingDownMinersCount: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  eventId?: Maybe<Scalars['BigInt']>;
  events?: Maybe<Events>;
  freeStake: Scalars['Decimal'];
  id: Scalars['BigInt'];
  idleMinersCount: Scalars['Int'];
  instantApr: Scalars['Decimal'];
  minersCount: Scalars['Int'];
  ownerReward: Scalars['Decimal'];
  readyMinersCount: Scalars['Int'];
  releasingStake: Scalars['Decimal'];
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakePools: StakePools;
  stakersCount: Scalars['Int'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalShares: Scalars['Decimal'];
  totalStake: Scalars['Decimal'];
  type: Scalars['String'];
  unresponsiveMinersCount: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
  usedStake: Scalars['Decimal'];
  withdrawalsCount: Scalars['Int'];
};

export type StakePoolActivitiesAvgAggregate = {
  __typename?: 'StakePoolActivitiesAvgAggregate';
  blockNumber?: Maybe<Scalars['Float']>;
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Float']>;
  eventId?: Maybe<Scalars['Float']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['Float']>;
  idleMinersCount?: Maybe<Scalars['Float']>;
  instantApr?: Maybe<Scalars['Decimal']>;
  minersCount?: Maybe<Scalars['Float']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  readyMinersCount?: Maybe<Scalars['Float']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['Float']>;
  stakersCount?: Maybe<Scalars['Float']>;
  tokenomicVersion?: Maybe<Scalars['Float']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: Maybe<Scalars['Float']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Float']>;
};

export type StakePoolActivitiesAvgOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesCountAggregate = {
  __typename?: 'StakePoolActivitiesCountAggregate';
  _all: Scalars['Int'];
  blockNumber: Scalars['Int'];
  cap: Scalars['Int'];
  commission: Scalars['Int'];
  coolingDownMinersCount: Scalars['Int'];
  createdAt: Scalars['Int'];
  eventId: Scalars['Int'];
  freeStake: Scalars['Int'];
  id: Scalars['Int'];
  idleMinersCount: Scalars['Int'];
  instantApr: Scalars['Int'];
  minersCount: Scalars['Int'];
  ownerReward: Scalars['Int'];
  readyMinersCount: Scalars['Int'];
  releasingStake: Scalars['Int'];
  remainingStake: Scalars['Int'];
  rewardAcc: Scalars['Int'];
  stakePoolId: Scalars['Int'];
  stakersCount: Scalars['Int'];
  timestamp: Scalars['Int'];
  tokenomicVersion: Scalars['Int'];
  totalShares: Scalars['Int'];
  totalStake: Scalars['Int'];
  type: Scalars['Int'];
  unresponsiveMinersCount: Scalars['Int'];
  updatedAt: Scalars['Int'];
  usedStake: Scalars['Int'];
  withdrawalsCount: Scalars['Int'];
};

export type StakePoolActivitiesCountOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesCreateInput = {
  blockNumber: Scalars['BigInt'];
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  events?: InputMaybe<EventsCreateNestedOneWithoutStakePoolActivitiesInput>;
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakePools: StakePoolsCreateNestedOneWithoutStakePoolActivitiesInput;
  stakersCount?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  type: Scalars['String'];
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
};

export type StakePoolActivitiesCreateManyEventsInput = {
  blockNumber: Scalars['BigInt'];
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakePoolId: Scalars['BigInt'];
  stakersCount?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  type: Scalars['String'];
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
};

export type StakePoolActivitiesCreateManyEventsInputEnvelope = {
  data: Array<StakePoolActivitiesCreateManyEventsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type StakePoolActivitiesCreateManyInput = {
  blockNumber: Scalars['BigInt'];
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  eventId?: InputMaybe<Scalars['BigInt']>;
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakePoolId: Scalars['BigInt'];
  stakersCount?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  type: Scalars['String'];
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
};

export type StakePoolActivitiesCreateManyStakePoolsInput = {
  blockNumber: Scalars['BigInt'];
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  eventId?: InputMaybe<Scalars['BigInt']>;
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakersCount?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  type: Scalars['String'];
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
};

export type StakePoolActivitiesCreateManyStakePoolsInputEnvelope = {
  data: Array<StakePoolActivitiesCreateManyStakePoolsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type StakePoolActivitiesCreateNestedManyWithoutEventsInput = {
  connect?: InputMaybe<Array<StakePoolActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolActivitiesCreateOrConnectWithoutEventsInput>>;
  create?: InputMaybe<Array<StakePoolActivitiesCreateWithoutEventsInput>>;
  createMany?: InputMaybe<StakePoolActivitiesCreateManyEventsInputEnvelope>;
};

export type StakePoolActivitiesCreateNestedManyWithoutStakePoolsInput = {
  connect?: InputMaybe<Array<StakePoolActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolActivitiesCreateOrConnectWithoutStakePoolsInput>>;
  create?: InputMaybe<Array<StakePoolActivitiesCreateWithoutStakePoolsInput>>;
  createMany?: InputMaybe<StakePoolActivitiesCreateManyStakePoolsInputEnvelope>;
};

export type StakePoolActivitiesCreateOrConnectWithoutEventsInput = {
  create: StakePoolActivitiesCreateWithoutEventsInput;
  where: StakePoolActivitiesWhereUniqueInput;
};

export type StakePoolActivitiesCreateOrConnectWithoutStakePoolsInput = {
  create: StakePoolActivitiesCreateWithoutStakePoolsInput;
  where: StakePoolActivitiesWhereUniqueInput;
};

export type StakePoolActivitiesCreateWithoutEventsInput = {
  blockNumber: Scalars['BigInt'];
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakePools: StakePoolsCreateNestedOneWithoutStakePoolActivitiesInput;
  stakersCount?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  type: Scalars['String'];
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
};

export type StakePoolActivitiesCreateWithoutStakePoolsInput = {
  blockNumber: Scalars['BigInt'];
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  events?: InputMaybe<EventsCreateNestedOneWithoutStakePoolActivitiesInput>;
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakersCount?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  type: Scalars['String'];
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
};

export type StakePoolActivitiesGroupBy = {
  __typename?: 'StakePoolActivitiesGroupBy';
  _avg?: Maybe<StakePoolActivitiesAvgAggregate>;
  _count?: Maybe<StakePoolActivitiesCountAggregate>;
  _max?: Maybe<StakePoolActivitiesMaxAggregate>;
  _min?: Maybe<StakePoolActivitiesMinAggregate>;
  _sum?: Maybe<StakePoolActivitiesSumAggregate>;
  blockNumber: Scalars['BigInt'];
  cap?: Maybe<Scalars['Decimal']>;
  commission: Scalars['Decimal'];
  coolingDownMinersCount: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  eventId?: Maybe<Scalars['BigInt']>;
  freeStake: Scalars['Decimal'];
  id: Scalars['BigInt'];
  idleMinersCount: Scalars['Int'];
  instantApr: Scalars['Decimal'];
  minersCount: Scalars['Int'];
  ownerReward: Scalars['Decimal'];
  readyMinersCount: Scalars['Int'];
  releasingStake: Scalars['Decimal'];
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakersCount: Scalars['Int'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalShares: Scalars['Decimal'];
  totalStake: Scalars['Decimal'];
  type: Scalars['String'];
  unresponsiveMinersCount: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
  usedStake: Scalars['Decimal'];
  withdrawalsCount: Scalars['Int'];
};

export type StakePoolActivitiesListRelationFilter = {
  every?: InputMaybe<StakePoolActivitiesWhereInput>;
  none?: InputMaybe<StakePoolActivitiesWhereInput>;
  some?: InputMaybe<StakePoolActivitiesWhereInput>;
};

export type StakePoolActivitiesMaxAggregate = {
  __typename?: 'StakePoolActivitiesMaxAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  idleMinersCount?: Maybe<Scalars['Int']>;
  instantApr?: Maybe<Scalars['Decimal']>;
  minersCount?: Maybe<Scalars['Int']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  readyMinersCount?: Maybe<Scalars['Int']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakersCount?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  type?: Maybe<Scalars['String']>;
  unresponsiveMinersCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Int']>;
};

export type StakePoolActivitiesMaxOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesMinAggregate = {
  __typename?: 'StakePoolActivitiesMinAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  idleMinersCount?: Maybe<Scalars['Int']>;
  instantApr?: Maybe<Scalars['Decimal']>;
  minersCount?: Maybe<Scalars['Int']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  readyMinersCount?: Maybe<Scalars['Int']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakersCount?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  type?: Maybe<Scalars['String']>;
  unresponsiveMinersCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Int']>;
};

export type StakePoolActivitiesMinOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesOrderByWithAggregationInput = {
  _avg?: InputMaybe<StakePoolActivitiesAvgOrderByAggregateInput>;
  _count?: InputMaybe<StakePoolActivitiesCountOrderByAggregateInput>;
  _max?: InputMaybe<StakePoolActivitiesMaxOrderByAggregateInput>;
  _min?: InputMaybe<StakePoolActivitiesMinOrderByAggregateInput>;
  _sum?: InputMaybe<StakePoolActivitiesSumOrderByAggregateInput>;
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesOrderByWithRelationInput = {
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  events?: InputMaybe<EventsOrderByWithRelationInput>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  stakersCount?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export enum StakePoolActivitiesScalarFieldEnum {
  BlockNumber = 'blockNumber',
  Cap = 'cap',
  Commission = 'commission',
  CoolingDownMinersCount = 'coolingDownMinersCount',
  CreatedAt = 'createdAt',
  EventId = 'eventId',
  FreeStake = 'freeStake',
  Id = 'id',
  IdleMinersCount = 'idleMinersCount',
  InstantApr = 'instantApr',
  MinersCount = 'minersCount',
  OwnerReward = 'ownerReward',
  ReadyMinersCount = 'readyMinersCount',
  ReleasingStake = 'releasingStake',
  RemainingStake = 'remainingStake',
  RewardAcc = 'rewardAcc',
  StakePoolId = 'stakePoolId',
  StakersCount = 'stakersCount',
  Timestamp = 'timestamp',
  TokenomicVersion = 'tokenomicVersion',
  TotalShares = 'totalShares',
  TotalStake = 'totalStake',
  Type = 'type',
  UnresponsiveMinersCount = 'unresponsiveMinersCount',
  UpdatedAt = 'updatedAt',
  UsedStake = 'usedStake',
  WithdrawalsCount = 'withdrawalsCount'
}

export type StakePoolActivitiesScalarWhereInput = {
  AND?: InputMaybe<Array<StakePoolActivitiesScalarWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolActivitiesScalarWhereInput>>;
  OR?: InputMaybe<Array<StakePoolActivitiesScalarWhereInput>>;
  blockNumber?: InputMaybe<BigIntFilter>;
  cap?: InputMaybe<DecimalNullableFilter>;
  commission?: InputMaybe<DecimalFilter>;
  coolingDownMinersCount?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  eventId?: InputMaybe<BigIntNullableFilter>;
  freeStake?: InputMaybe<DecimalFilter>;
  id?: InputMaybe<BigIntFilter>;
  idleMinersCount?: InputMaybe<IntFilter>;
  instantApr?: InputMaybe<DecimalFilter>;
  minersCount?: InputMaybe<IntFilter>;
  ownerReward?: InputMaybe<DecimalFilter>;
  readyMinersCount?: InputMaybe<IntFilter>;
  releasingStake?: InputMaybe<DecimalFilter>;
  remainingStake?: InputMaybe<DecimalNullableFilter>;
  rewardAcc?: InputMaybe<DecimalFilter>;
  stakePoolId?: InputMaybe<BigIntFilter>;
  stakersCount?: InputMaybe<IntFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  totalShares?: InputMaybe<DecimalFilter>;
  totalStake?: InputMaybe<DecimalFilter>;
  type?: InputMaybe<StringFilter>;
  unresponsiveMinersCount?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  usedStake?: InputMaybe<DecimalFilter>;
  withdrawalsCount?: InputMaybe<IntFilter>;
};

export type StakePoolActivitiesScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StakePoolActivitiesScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StakePoolActivitiesScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StakePoolActivitiesScalarWhereWithAggregatesInput>>;
  blockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  cap?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  commission?: InputMaybe<DecimalWithAggregatesFilter>;
  coolingDownMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  eventId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  freeStake?: InputMaybe<DecimalWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  idleMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  instantApr?: InputMaybe<DecimalWithAggregatesFilter>;
  minersCount?: InputMaybe<IntWithAggregatesFilter>;
  ownerReward?: InputMaybe<DecimalWithAggregatesFilter>;
  readyMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  releasingStake?: InputMaybe<DecimalWithAggregatesFilter>;
  remainingStake?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  rewardAcc?: InputMaybe<DecimalWithAggregatesFilter>;
  stakePoolId?: InputMaybe<BigIntWithAggregatesFilter>;
  stakersCount?: InputMaybe<IntWithAggregatesFilter>;
  timestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  tokenomicVersion?: InputMaybe<IntWithAggregatesFilter>;
  totalShares?: InputMaybe<DecimalWithAggregatesFilter>;
  totalStake?: InputMaybe<DecimalWithAggregatesFilter>;
  type?: InputMaybe<StringWithAggregatesFilter>;
  unresponsiveMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  usedStake?: InputMaybe<DecimalWithAggregatesFilter>;
  withdrawalsCount?: InputMaybe<IntWithAggregatesFilter>;
};

export type StakePoolActivitiesSumAggregate = {
  __typename?: 'StakePoolActivitiesSumAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Int']>;
  eventId?: Maybe<Scalars['BigInt']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  idleMinersCount?: Maybe<Scalars['Int']>;
  instantApr?: Maybe<Scalars['Decimal']>;
  minersCount?: Maybe<Scalars['Int']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  readyMinersCount?: Maybe<Scalars['Int']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakersCount?: Maybe<Scalars['Int']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: Maybe<Scalars['Int']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Int']>;
};

export type StakePoolActivitiesSumOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesUpdateInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  events?: InputMaybe<EventsUpdateOneWithoutStakePoolActivitiesInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutStakePoolActivitiesInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StakePoolActivitiesUpdateManyMutationInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StakePoolActivitiesUpdateManyWithWhereWithoutEventsInput = {
  data: StakePoolActivitiesUpdateManyMutationInput;
  where: StakePoolActivitiesScalarWhereInput;
};

export type StakePoolActivitiesUpdateManyWithWhereWithoutStakePoolsInput = {
  data: StakePoolActivitiesUpdateManyMutationInput;
  where: StakePoolActivitiesScalarWhereInput;
};

export type StakePoolActivitiesUpdateManyWithoutEventsInput = {
  connect?: InputMaybe<Array<StakePoolActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolActivitiesCreateOrConnectWithoutEventsInput>>;
  create?: InputMaybe<Array<StakePoolActivitiesCreateWithoutEventsInput>>;
  createMany?: InputMaybe<StakePoolActivitiesCreateManyEventsInputEnvelope>;
  delete?: InputMaybe<Array<StakePoolActivitiesWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StakePoolActivitiesScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StakePoolActivitiesWhereUniqueInput>>;
  set?: InputMaybe<Array<StakePoolActivitiesWhereUniqueInput>>;
  update?: InputMaybe<Array<StakePoolActivitiesUpdateWithWhereUniqueWithoutEventsInput>>;
  updateMany?: InputMaybe<Array<StakePoolActivitiesUpdateManyWithWhereWithoutEventsInput>>;
  upsert?: InputMaybe<Array<StakePoolActivitiesUpsertWithWhereUniqueWithoutEventsInput>>;
};

export type StakePoolActivitiesUpdateManyWithoutStakePoolsInput = {
  connect?: InputMaybe<Array<StakePoolActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolActivitiesCreateOrConnectWithoutStakePoolsInput>>;
  create?: InputMaybe<Array<StakePoolActivitiesCreateWithoutStakePoolsInput>>;
  createMany?: InputMaybe<StakePoolActivitiesCreateManyStakePoolsInputEnvelope>;
  delete?: InputMaybe<Array<StakePoolActivitiesWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StakePoolActivitiesScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StakePoolActivitiesWhereUniqueInput>>;
  set?: InputMaybe<Array<StakePoolActivitiesWhereUniqueInput>>;
  update?: InputMaybe<Array<StakePoolActivitiesUpdateWithWhereUniqueWithoutStakePoolsInput>>;
  updateMany?: InputMaybe<Array<StakePoolActivitiesUpdateManyWithWhereWithoutStakePoolsInput>>;
  upsert?: InputMaybe<Array<StakePoolActivitiesUpsertWithWhereUniqueWithoutStakePoolsInput>>;
};

export type StakePoolActivitiesUpdateWithWhereUniqueWithoutEventsInput = {
  data: StakePoolActivitiesUpdateWithoutEventsInput;
  where: StakePoolActivitiesWhereUniqueInput;
};

export type StakePoolActivitiesUpdateWithWhereUniqueWithoutStakePoolsInput = {
  data: StakePoolActivitiesUpdateWithoutStakePoolsInput;
  where: StakePoolActivitiesWhereUniqueInput;
};

export type StakePoolActivitiesUpdateWithoutEventsInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutStakePoolActivitiesInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StakePoolActivitiesUpdateWithoutStakePoolsInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  events?: InputMaybe<EventsUpdateOneWithoutStakePoolActivitiesInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StakePoolActivitiesUpsertWithWhereUniqueWithoutEventsInput = {
  create: StakePoolActivitiesCreateWithoutEventsInput;
  update: StakePoolActivitiesUpdateWithoutEventsInput;
  where: StakePoolActivitiesWhereUniqueInput;
};

export type StakePoolActivitiesUpsertWithWhereUniqueWithoutStakePoolsInput = {
  create: StakePoolActivitiesCreateWithoutStakePoolsInput;
  update: StakePoolActivitiesUpdateWithoutStakePoolsInput;
  where: StakePoolActivitiesWhereUniqueInput;
};

export type StakePoolActivitiesWhereInput = {
  AND?: InputMaybe<Array<StakePoolActivitiesWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolActivitiesWhereInput>>;
  OR?: InputMaybe<Array<StakePoolActivitiesWhereInput>>;
  blockNumber?: InputMaybe<BigIntFilter>;
  cap?: InputMaybe<DecimalNullableFilter>;
  commission?: InputMaybe<DecimalFilter>;
  coolingDownMinersCount?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  eventId?: InputMaybe<BigIntNullableFilter>;
  events?: InputMaybe<EventsRelationFilter>;
  freeStake?: InputMaybe<DecimalFilter>;
  id?: InputMaybe<BigIntFilter>;
  idleMinersCount?: InputMaybe<IntFilter>;
  instantApr?: InputMaybe<DecimalFilter>;
  minersCount?: InputMaybe<IntFilter>;
  ownerReward?: InputMaybe<DecimalFilter>;
  readyMinersCount?: InputMaybe<IntFilter>;
  releasingStake?: InputMaybe<DecimalFilter>;
  remainingStake?: InputMaybe<DecimalNullableFilter>;
  rewardAcc?: InputMaybe<DecimalFilter>;
  stakePoolId?: InputMaybe<BigIntFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  stakersCount?: InputMaybe<IntFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  totalShares?: InputMaybe<DecimalFilter>;
  totalStake?: InputMaybe<DecimalFilter>;
  type?: InputMaybe<StringFilter>;
  unresponsiveMinersCount?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  usedStake?: InputMaybe<DecimalFilter>;
  withdrawalsCount?: InputMaybe<IntFilter>;
};

export type StakePoolActivitiesWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type StakePoolStakerActivities = {
  __typename?: 'StakePoolStakerActivities';
  availableRewards: Scalars['Decimal'];
  blockNumber: Scalars['BigInt'];
  claimableRewards: Scalars['Decimal'];
  createdAt: Scalars['DateTime'];
  eventId?: Maybe<Scalars['BigInt']>;
  events?: Maybe<Events>;
  id: Scalars['BigInt'];
  instantClaimableRewards: Scalars['Decimal'];
  locked: Scalars['Decimal'];
  pendingRewards: Scalars['Decimal'];
  rewardDebt: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stake: Scalars['Decimal'];
  stakePoolStakerId: Scalars['BigInt'];
  stakePoolStakers: StakePoolStakers;
  stakeRewards: Scalars['Decimal'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakerActivitiesAvgAggregate = {
  __typename?: 'StakePoolStakerActivitiesAvgAggregate';
  availableRewards?: Maybe<Scalars['Decimal']>;
  blockNumber?: Maybe<Scalars['Float']>;
  claimableRewards?: Maybe<Scalars['Decimal']>;
  eventId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  instantClaimableRewards?: Maybe<Scalars['Decimal']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingRewards?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolStakerId?: Maybe<Scalars['Float']>;
  stakeRewards?: Maybe<Scalars['Decimal']>;
  tokenomicVersion?: Maybe<Scalars['Float']>;
};

export type StakePoolStakerActivitiesAvgOrderByAggregateInput = {
  availableRewards?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakeRewards?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesCountAggregate = {
  __typename?: 'StakePoolStakerActivitiesCountAggregate';
  _all: Scalars['Int'];
  availableRewards: Scalars['Int'];
  blockNumber: Scalars['Int'];
  claimableRewards: Scalars['Int'];
  createdAt: Scalars['Int'];
  eventId: Scalars['Int'];
  id: Scalars['Int'];
  instantClaimableRewards: Scalars['Int'];
  locked: Scalars['Int'];
  pendingRewards: Scalars['Int'];
  rewardDebt: Scalars['Int'];
  shares: Scalars['Int'];
  stake: Scalars['Int'];
  stakePoolStakerId: Scalars['Int'];
  stakeRewards: Scalars['Int'];
  timestamp: Scalars['Int'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['Int'];
  updatedAt: Scalars['Int'];
};

export type StakePoolStakerActivitiesCountOrderByAggregateInput = {
  availableRewards?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakeRewards?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesCreateInput = {
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  blockNumber: Scalars['BigInt'];
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  events?: InputMaybe<EventsCreateNestedOneWithoutStakePoolStakerActivitiesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolStakers: StakePoolStakersCreateNestedOneWithoutStakePoolStakerActivitiesInput;
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakerActivitiesCreateManyEventsInput = {
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  blockNumber: Scalars['BigInt'];
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolStakerId: Scalars['BigInt'];
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakerActivitiesCreateManyEventsInputEnvelope = {
  data: Array<StakePoolStakerActivitiesCreateManyEventsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type StakePoolStakerActivitiesCreateManyInput = {
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  blockNumber: Scalars['BigInt'];
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  eventId?: InputMaybe<Scalars['BigInt']>;
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolStakerId: Scalars['BigInt'];
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakerActivitiesCreateManyStakePoolStakersInput = {
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  blockNumber: Scalars['BigInt'];
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  eventId?: InputMaybe<Scalars['BigInt']>;
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakerActivitiesCreateManyStakePoolStakersInputEnvelope = {
  data: Array<StakePoolStakerActivitiesCreateManyStakePoolStakersInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type StakePoolStakerActivitiesCreateNestedManyWithoutEventsInput = {
  connect?: InputMaybe<Array<StakePoolStakerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolStakerActivitiesCreateOrConnectWithoutEventsInput>>;
  create?: InputMaybe<Array<StakePoolStakerActivitiesCreateWithoutEventsInput>>;
  createMany?: InputMaybe<StakePoolStakerActivitiesCreateManyEventsInputEnvelope>;
};

export type StakePoolStakerActivitiesCreateNestedManyWithoutStakePoolStakersInput = {
  connect?: InputMaybe<Array<StakePoolStakerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolStakerActivitiesCreateOrConnectWithoutStakePoolStakersInput>>;
  create?: InputMaybe<Array<StakePoolStakerActivitiesCreateWithoutStakePoolStakersInput>>;
  createMany?: InputMaybe<StakePoolStakerActivitiesCreateManyStakePoolStakersInputEnvelope>;
};

export type StakePoolStakerActivitiesCreateOrConnectWithoutEventsInput = {
  create: StakePoolStakerActivitiesCreateWithoutEventsInput;
  where: StakePoolStakerActivitiesWhereUniqueInput;
};

export type StakePoolStakerActivitiesCreateOrConnectWithoutStakePoolStakersInput = {
  create: StakePoolStakerActivitiesCreateWithoutStakePoolStakersInput;
  where: StakePoolStakerActivitiesWhereUniqueInput;
};

export type StakePoolStakerActivitiesCreateWithoutEventsInput = {
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  blockNumber: Scalars['BigInt'];
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolStakers: StakePoolStakersCreateNestedOneWithoutStakePoolStakerActivitiesInput;
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakerActivitiesCreateWithoutStakePoolStakersInput = {
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  blockNumber: Scalars['BigInt'];
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  events?: InputMaybe<EventsCreateNestedOneWithoutStakePoolStakerActivitiesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakerActivitiesGroupBy = {
  __typename?: 'StakePoolStakerActivitiesGroupBy';
  _avg?: Maybe<StakePoolStakerActivitiesAvgAggregate>;
  _count?: Maybe<StakePoolStakerActivitiesCountAggregate>;
  _max?: Maybe<StakePoolStakerActivitiesMaxAggregate>;
  _min?: Maybe<StakePoolStakerActivitiesMinAggregate>;
  _sum?: Maybe<StakePoolStakerActivitiesSumAggregate>;
  availableRewards: Scalars['Decimal'];
  blockNumber: Scalars['BigInt'];
  claimableRewards: Scalars['Decimal'];
  createdAt: Scalars['DateTime'];
  eventId?: Maybe<Scalars['BigInt']>;
  id: Scalars['BigInt'];
  instantClaimableRewards: Scalars['Decimal'];
  locked: Scalars['Decimal'];
  pendingRewards: Scalars['Decimal'];
  rewardDebt: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stake: Scalars['Decimal'];
  stakePoolStakerId: Scalars['BigInt'];
  stakeRewards: Scalars['Decimal'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakerActivitiesListRelationFilter = {
  every?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
  none?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
  some?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};

export type StakePoolStakerActivitiesMaxAggregate = {
  __typename?: 'StakePoolStakerActivitiesMaxAggregate';
  availableRewards?: Maybe<Scalars['Decimal']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  claimableRewards?: Maybe<Scalars['Decimal']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  instantClaimableRewards?: Maybe<Scalars['Decimal']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingRewards?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolStakerId?: Maybe<Scalars['BigInt']>;
  stakeRewards?: Maybe<Scalars['Decimal']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StakePoolStakerActivitiesMaxOrderByAggregateInput = {
  availableRewards?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakeRewards?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesMinAggregate = {
  __typename?: 'StakePoolStakerActivitiesMinAggregate';
  availableRewards?: Maybe<Scalars['Decimal']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  claimableRewards?: Maybe<Scalars['Decimal']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  instantClaimableRewards?: Maybe<Scalars['Decimal']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingRewards?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolStakerId?: Maybe<Scalars['BigInt']>;
  stakeRewards?: Maybe<Scalars['Decimal']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StakePoolStakerActivitiesMinOrderByAggregateInput = {
  availableRewards?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakeRewards?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesOrderByWithAggregationInput = {
  _avg?: InputMaybe<StakePoolStakerActivitiesAvgOrderByAggregateInput>;
  _count?: InputMaybe<StakePoolStakerActivitiesCountOrderByAggregateInput>;
  _max?: InputMaybe<StakePoolStakerActivitiesMaxOrderByAggregateInput>;
  _min?: InputMaybe<StakePoolStakerActivitiesMinOrderByAggregateInput>;
  _sum?: InputMaybe<StakePoolStakerActivitiesSumOrderByAggregateInput>;
  availableRewards?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakeRewards?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesOrderByWithRelationInput = {
  availableRewards?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  events?: InputMaybe<EventsOrderByWithRelationInput>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakePoolStakers?: InputMaybe<StakePoolStakersOrderByWithRelationInput>;
  stakeRewards?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum StakePoolStakerActivitiesScalarFieldEnum {
  AvailableRewards = 'availableRewards',
  BlockNumber = 'blockNumber',
  ClaimableRewards = 'claimableRewards',
  CreatedAt = 'createdAt',
  EventId = 'eventId',
  Id = 'id',
  InstantClaimableRewards = 'instantClaimableRewards',
  Locked = 'locked',
  PendingRewards = 'pendingRewards',
  RewardDebt = 'rewardDebt',
  Shares = 'shares',
  Stake = 'stake',
  StakePoolStakerId = 'stakePoolStakerId',
  StakeRewards = 'stakeRewards',
  Timestamp = 'timestamp',
  TokenomicVersion = 'tokenomicVersion',
  Type = 'type',
  UpdatedAt = 'updatedAt'
}

export type StakePoolStakerActivitiesScalarWhereInput = {
  AND?: InputMaybe<Array<StakePoolStakerActivitiesScalarWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolStakerActivitiesScalarWhereInput>>;
  OR?: InputMaybe<Array<StakePoolStakerActivitiesScalarWhereInput>>;
  availableRewards?: InputMaybe<DecimalFilter>;
  blockNumber?: InputMaybe<BigIntFilter>;
  claimableRewards?: InputMaybe<DecimalFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  eventId?: InputMaybe<BigIntNullableFilter>;
  id?: InputMaybe<BigIntFilter>;
  instantClaimableRewards?: InputMaybe<DecimalFilter>;
  locked?: InputMaybe<DecimalFilter>;
  pendingRewards?: InputMaybe<DecimalFilter>;
  rewardDebt?: InputMaybe<DecimalFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stake?: InputMaybe<DecimalFilter>;
  stakePoolStakerId?: InputMaybe<BigIntFilter>;
  stakeRewards?: InputMaybe<DecimalFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type StakePoolStakerActivitiesScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StakePoolStakerActivitiesScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StakePoolStakerActivitiesScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StakePoolStakerActivitiesScalarWhereWithAggregatesInput>>;
  availableRewards?: InputMaybe<DecimalWithAggregatesFilter>;
  blockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  claimableRewards?: InputMaybe<DecimalWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  eventId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  instantClaimableRewards?: InputMaybe<DecimalWithAggregatesFilter>;
  locked?: InputMaybe<DecimalWithAggregatesFilter>;
  pendingRewards?: InputMaybe<DecimalWithAggregatesFilter>;
  rewardDebt?: InputMaybe<DecimalWithAggregatesFilter>;
  shares?: InputMaybe<DecimalWithAggregatesFilter>;
  stake?: InputMaybe<DecimalWithAggregatesFilter>;
  stakePoolStakerId?: InputMaybe<BigIntWithAggregatesFilter>;
  stakeRewards?: InputMaybe<DecimalWithAggregatesFilter>;
  timestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  tokenomicVersion?: InputMaybe<IntWithAggregatesFilter>;
  type?: InputMaybe<StringWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type StakePoolStakerActivitiesSumAggregate = {
  __typename?: 'StakePoolStakerActivitiesSumAggregate';
  availableRewards?: Maybe<Scalars['Decimal']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  claimableRewards?: Maybe<Scalars['Decimal']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  instantClaimableRewards?: Maybe<Scalars['Decimal']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingRewards?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolStakerId?: Maybe<Scalars['BigInt']>;
  stakeRewards?: Maybe<Scalars['Decimal']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
};

export type StakePoolStakerActivitiesSumOrderByAggregateInput = {
  availableRewards?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakeRewards?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesUpdateInput = {
  availableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  claimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  events?: InputMaybe<EventsUpdateOneWithoutStakePoolStakerActivitiesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  instantClaimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  locked?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pendingRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  rewardDebt?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateOneRequiredWithoutStakePoolStakerActivitiesInput>;
  stakeRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StakePoolStakerActivitiesUpdateManyMutationInput = {
  availableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  claimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  instantClaimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  locked?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pendingRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  rewardDebt?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakeRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StakePoolStakerActivitiesUpdateManyWithWhereWithoutEventsInput = {
  data: StakePoolStakerActivitiesUpdateManyMutationInput;
  where: StakePoolStakerActivitiesScalarWhereInput;
};

export type StakePoolStakerActivitiesUpdateManyWithWhereWithoutStakePoolStakersInput = {
  data: StakePoolStakerActivitiesUpdateManyMutationInput;
  where: StakePoolStakerActivitiesScalarWhereInput;
};

export type StakePoolStakerActivitiesUpdateManyWithoutEventsInput = {
  connect?: InputMaybe<Array<StakePoolStakerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolStakerActivitiesCreateOrConnectWithoutEventsInput>>;
  create?: InputMaybe<Array<StakePoolStakerActivitiesCreateWithoutEventsInput>>;
  createMany?: InputMaybe<StakePoolStakerActivitiesCreateManyEventsInputEnvelope>;
  delete?: InputMaybe<Array<StakePoolStakerActivitiesWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StakePoolStakerActivitiesScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StakePoolStakerActivitiesWhereUniqueInput>>;
  set?: InputMaybe<Array<StakePoolStakerActivitiesWhereUniqueInput>>;
  update?: InputMaybe<Array<StakePoolStakerActivitiesUpdateWithWhereUniqueWithoutEventsInput>>;
  updateMany?: InputMaybe<Array<StakePoolStakerActivitiesUpdateManyWithWhereWithoutEventsInput>>;
  upsert?: InputMaybe<Array<StakePoolStakerActivitiesUpsertWithWhereUniqueWithoutEventsInput>>;
};

export type StakePoolStakerActivitiesUpdateManyWithoutStakePoolStakersInput = {
  connect?: InputMaybe<Array<StakePoolStakerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolStakerActivitiesCreateOrConnectWithoutStakePoolStakersInput>>;
  create?: InputMaybe<Array<StakePoolStakerActivitiesCreateWithoutStakePoolStakersInput>>;
  createMany?: InputMaybe<StakePoolStakerActivitiesCreateManyStakePoolStakersInputEnvelope>;
  delete?: InputMaybe<Array<StakePoolStakerActivitiesWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StakePoolStakerActivitiesScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StakePoolStakerActivitiesWhereUniqueInput>>;
  set?: InputMaybe<Array<StakePoolStakerActivitiesWhereUniqueInput>>;
  update?: InputMaybe<Array<StakePoolStakerActivitiesUpdateWithWhereUniqueWithoutStakePoolStakersInput>>;
  updateMany?: InputMaybe<Array<StakePoolStakerActivitiesUpdateManyWithWhereWithoutStakePoolStakersInput>>;
  upsert?: InputMaybe<Array<StakePoolStakerActivitiesUpsertWithWhereUniqueWithoutStakePoolStakersInput>>;
};

export type StakePoolStakerActivitiesUpdateWithWhereUniqueWithoutEventsInput = {
  data: StakePoolStakerActivitiesUpdateWithoutEventsInput;
  where: StakePoolStakerActivitiesWhereUniqueInput;
};

export type StakePoolStakerActivitiesUpdateWithWhereUniqueWithoutStakePoolStakersInput = {
  data: StakePoolStakerActivitiesUpdateWithoutStakePoolStakersInput;
  where: StakePoolStakerActivitiesWhereUniqueInput;
};

export type StakePoolStakerActivitiesUpdateWithoutEventsInput = {
  availableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  claimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  instantClaimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  locked?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pendingRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  rewardDebt?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateOneRequiredWithoutStakePoolStakerActivitiesInput>;
  stakeRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StakePoolStakerActivitiesUpdateWithoutStakePoolStakersInput = {
  availableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  claimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  events?: InputMaybe<EventsUpdateOneWithoutStakePoolStakerActivitiesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  instantClaimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  locked?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pendingRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  rewardDebt?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakeRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StakePoolStakerActivitiesUpsertWithWhereUniqueWithoutEventsInput = {
  create: StakePoolStakerActivitiesCreateWithoutEventsInput;
  update: StakePoolStakerActivitiesUpdateWithoutEventsInput;
  where: StakePoolStakerActivitiesWhereUniqueInput;
};

export type StakePoolStakerActivitiesUpsertWithWhereUniqueWithoutStakePoolStakersInput = {
  create: StakePoolStakerActivitiesCreateWithoutStakePoolStakersInput;
  update: StakePoolStakerActivitiesUpdateWithoutStakePoolStakersInput;
  where: StakePoolStakerActivitiesWhereUniqueInput;
};

export type StakePoolStakerActivitiesWhereInput = {
  AND?: InputMaybe<Array<StakePoolStakerActivitiesWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolStakerActivitiesWhereInput>>;
  OR?: InputMaybe<Array<StakePoolStakerActivitiesWhereInput>>;
  availableRewards?: InputMaybe<DecimalFilter>;
  blockNumber?: InputMaybe<BigIntFilter>;
  claimableRewards?: InputMaybe<DecimalFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  eventId?: InputMaybe<BigIntNullableFilter>;
  events?: InputMaybe<EventsRelationFilter>;
  id?: InputMaybe<BigIntFilter>;
  instantClaimableRewards?: InputMaybe<DecimalFilter>;
  locked?: InputMaybe<DecimalFilter>;
  pendingRewards?: InputMaybe<DecimalFilter>;
  rewardDebt?: InputMaybe<DecimalFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stake?: InputMaybe<DecimalFilter>;
  stakePoolStakerId?: InputMaybe<BigIntFilter>;
  stakePoolStakers?: InputMaybe<StakePoolStakersRelationFilter>;
  stakeRewards?: InputMaybe<DecimalFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type StakePoolStakerActivitiesWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type StakePoolStakers = {
  __typename?: 'StakePoolStakers';
  _count?: Maybe<StakePoolStakersCount>;
  accounts: Accounts;
  address?: Maybe<Scalars['String']>;
  availableRewards: Scalars['Decimal'];
  claimableRewards: Scalars['Decimal'];
  createdAt: Scalars['DateTime'];
  id: Scalars['BigInt'];
  instantClaimableRewards: Scalars['Decimal'];
  isOwner: Scalars['Boolean'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  locked: Scalars['Decimal'];
  pendingRewards: Scalars['Decimal'];
  rewardDebt: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stake: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakePoolStakerActivities: Array<StakePoolStakerActivities>;
  stakePools: StakePools;
  stakeRewards: Scalars['Decimal'];
  updatedAt: Scalars['DateTime'];
  userId: Scalars['BigInt'];
};


export type StakePoolStakersStakePoolStakerActivitiesArgs = {
  cursor?: InputMaybe<StakePoolStakerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};

export type StakePoolStakersAvgAggregate = {
  __typename?: 'StakePoolStakersAvgAggregate';
  availableRewards?: Maybe<Scalars['Decimal']>;
  claimableRewards?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['Float']>;
  instantClaimableRewards?: Maybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingRewards?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['Float']>;
  stakeRewards?: Maybe<Scalars['Decimal']>;
  userId?: Maybe<Scalars['Float']>;
};

export type StakePoolStakersAvgOrderByAggregateInput = {
  availableRewards?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakeRewards?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersCount = {
  __typename?: 'StakePoolStakersCount';
  stakePoolStakerActivities: Scalars['Int'];
};

export type StakePoolStakersCountAggregate = {
  __typename?: 'StakePoolStakersCountAggregate';
  _all: Scalars['Int'];
  address: Scalars['Int'];
  availableRewards: Scalars['Int'];
  claimableRewards: Scalars['Int'];
  createdAt: Scalars['Int'];
  id: Scalars['Int'];
  instantClaimableRewards: Scalars['Int'];
  isOwner: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['Int'];
  lastUpdatedTimestamp: Scalars['Int'];
  locked: Scalars['Int'];
  pendingRewards: Scalars['Int'];
  rewardDebt: Scalars['Int'];
  shares: Scalars['Int'];
  stake: Scalars['Int'];
  stakePoolId: Scalars['Int'];
  stakeRewards: Scalars['Int'];
  updatedAt: Scalars['Int'];
  userId: Scalars['Int'];
};

export type StakePoolStakersCountOrderByAggregateInput = {
  address?: InputMaybe<SortOrder>;
  availableRewards?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  isOwner?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakeRewards?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersCreateInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolStakersInput;
  address?: InputMaybe<Scalars['String']>;
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  isOwner?: InputMaybe<Scalars['Boolean']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesCreateNestedManyWithoutStakePoolStakersInput>;
  stakePools: StakePoolsCreateNestedOneWithoutStakePoolStakersInput;
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakersCreateManyAccountsInput = {
  address?: InputMaybe<Scalars['String']>;
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  isOwner?: InputMaybe<Scalars['Boolean']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolId: Scalars['BigInt'];
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakersCreateManyAccountsInputEnvelope = {
  data: Array<StakePoolStakersCreateManyAccountsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type StakePoolStakersCreateManyInput = {
  address?: InputMaybe<Scalars['String']>;
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  isOwner?: InputMaybe<Scalars['Boolean']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolId: Scalars['BigInt'];
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
  userId: Scalars['BigInt'];
};

export type StakePoolStakersCreateManyStakePoolsInput = {
  address?: InputMaybe<Scalars['String']>;
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  isOwner?: InputMaybe<Scalars['Boolean']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
  userId: Scalars['BigInt'];
};

export type StakePoolStakersCreateManyStakePoolsInputEnvelope = {
  data: Array<StakePoolStakersCreateManyStakePoolsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type StakePoolStakersCreateNestedManyWithoutAccountsInput = {
  connect?: InputMaybe<Array<StakePoolStakersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolStakersCreateOrConnectWithoutAccountsInput>>;
  create?: InputMaybe<Array<StakePoolStakersCreateWithoutAccountsInput>>;
  createMany?: InputMaybe<StakePoolStakersCreateManyAccountsInputEnvelope>;
};

export type StakePoolStakersCreateNestedManyWithoutStakePoolsInput = {
  connect?: InputMaybe<Array<StakePoolStakersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolStakersCreateOrConnectWithoutStakePoolsInput>>;
  create?: InputMaybe<Array<StakePoolStakersCreateWithoutStakePoolsInput>>;
  createMany?: InputMaybe<StakePoolStakersCreateManyStakePoolsInputEnvelope>;
};

export type StakePoolStakersCreateNestedOneWithoutStakePoolStakerActivitiesInput = {
  connect?: InputMaybe<StakePoolStakersWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolStakersCreateOrConnectWithoutStakePoolStakerActivitiesInput>;
  create?: InputMaybe<StakePoolStakersCreateWithoutStakePoolStakerActivitiesInput>;
};

export type StakePoolStakersCreateOrConnectWithoutAccountsInput = {
  create: StakePoolStakersCreateWithoutAccountsInput;
  where: StakePoolStakersWhereUniqueInput;
};

export type StakePoolStakersCreateOrConnectWithoutStakePoolStakerActivitiesInput = {
  create: StakePoolStakersCreateWithoutStakePoolStakerActivitiesInput;
  where: StakePoolStakersWhereUniqueInput;
};

export type StakePoolStakersCreateOrConnectWithoutStakePoolsInput = {
  create: StakePoolStakersCreateWithoutStakePoolsInput;
  where: StakePoolStakersWhereUniqueInput;
};

export type StakePoolStakersCreateWithoutAccountsInput = {
  address?: InputMaybe<Scalars['String']>;
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  isOwner?: InputMaybe<Scalars['Boolean']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesCreateNestedManyWithoutStakePoolStakersInput>;
  stakePools: StakePoolsCreateNestedOneWithoutStakePoolStakersInput;
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakersCreateWithoutStakePoolStakerActivitiesInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolStakersInput;
  address?: InputMaybe<Scalars['String']>;
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  isOwner?: InputMaybe<Scalars['Boolean']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePools: StakePoolsCreateNestedOneWithoutStakePoolStakersInput;
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakersCreateWithoutStakePoolsInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolStakersInput;
  address?: InputMaybe<Scalars['String']>;
  availableRewards?: InputMaybe<Scalars['Decimal']>;
  claimableRewards?: InputMaybe<Scalars['Decimal']>;
  createdAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['BigInt']>;
  instantClaimableRewards?: InputMaybe<Scalars['Decimal']>;
  isOwner?: InputMaybe<Scalars['Boolean']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  locked?: InputMaybe<Scalars['Decimal']>;
  pendingRewards?: InputMaybe<Scalars['Decimal']>;
  rewardDebt?: InputMaybe<Scalars['Decimal']>;
  shares?: InputMaybe<Scalars['Decimal']>;
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesCreateNestedManyWithoutStakePoolStakersInput>;
  stakeRewards?: InputMaybe<Scalars['Decimal']>;
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakersGroupBy = {
  __typename?: 'StakePoolStakersGroupBy';
  _avg?: Maybe<StakePoolStakersAvgAggregate>;
  _count?: Maybe<StakePoolStakersCountAggregate>;
  _max?: Maybe<StakePoolStakersMaxAggregate>;
  _min?: Maybe<StakePoolStakersMinAggregate>;
  _sum?: Maybe<StakePoolStakersSumAggregate>;
  address?: Maybe<Scalars['String']>;
  availableRewards: Scalars['Decimal'];
  claimableRewards: Scalars['Decimal'];
  createdAt: Scalars['DateTime'];
  id: Scalars['BigInt'];
  instantClaimableRewards: Scalars['Decimal'];
  isOwner: Scalars['Boolean'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  locked: Scalars['Decimal'];
  pendingRewards: Scalars['Decimal'];
  rewardDebt: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stake: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakeRewards: Scalars['Decimal'];
  updatedAt: Scalars['DateTime'];
  userId: Scalars['BigInt'];
};

export type StakePoolStakersListRelationFilter = {
  every?: InputMaybe<StakePoolStakersWhereInput>;
  none?: InputMaybe<StakePoolStakersWhereInput>;
  some?: InputMaybe<StakePoolStakersWhereInput>;
};

export type StakePoolStakersMaxAggregate = {
  __typename?: 'StakePoolStakersMaxAggregate';
  address?: Maybe<Scalars['String']>;
  availableRewards?: Maybe<Scalars['Decimal']>;
  claimableRewards?: Maybe<Scalars['Decimal']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  instantClaimableRewards?: Maybe<Scalars['Decimal']>;
  isOwner?: Maybe<Scalars['Boolean']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingRewards?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakeRewards?: Maybe<Scalars['Decimal']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolStakersMaxOrderByAggregateInput = {
  address?: InputMaybe<SortOrder>;
  availableRewards?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  isOwner?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakeRewards?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersMinAggregate = {
  __typename?: 'StakePoolStakersMinAggregate';
  address?: Maybe<Scalars['String']>;
  availableRewards?: Maybe<Scalars['Decimal']>;
  claimableRewards?: Maybe<Scalars['Decimal']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  instantClaimableRewards?: Maybe<Scalars['Decimal']>;
  isOwner?: Maybe<Scalars['Boolean']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingRewards?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakeRewards?: Maybe<Scalars['Decimal']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolStakersMinOrderByAggregateInput = {
  address?: InputMaybe<SortOrder>;
  availableRewards?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  isOwner?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakeRewards?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StakePoolStakersOrderByWithAggregationInput = {
  _avg?: InputMaybe<StakePoolStakersAvgOrderByAggregateInput>;
  _count?: InputMaybe<StakePoolStakersCountOrderByAggregateInput>;
  _max?: InputMaybe<StakePoolStakersMaxOrderByAggregateInput>;
  _min?: InputMaybe<StakePoolStakersMinOrderByAggregateInput>;
  _sum?: InputMaybe<StakePoolStakersSumOrderByAggregateInput>;
  address?: InputMaybe<SortOrder>;
  availableRewards?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  isOwner?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakeRewards?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersOrderByWithRelationInput = {
  accounts?: InputMaybe<AccountsOrderByWithRelationInput>;
  address?: InputMaybe<SortOrder>;
  availableRewards?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  isOwner?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesOrderByRelationAggregateInput>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  stakeRewards?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersRelationFilter = {
  is?: InputMaybe<StakePoolStakersWhereInput>;
  isNot?: InputMaybe<StakePoolStakersWhereInput>;
};

export enum StakePoolStakersScalarFieldEnum {
  Address = 'address',
  AvailableRewards = 'availableRewards',
  ClaimableRewards = 'claimableRewards',
  CreatedAt = 'createdAt',
  Id = 'id',
  InstantClaimableRewards = 'instantClaimableRewards',
  IsOwner = 'isOwner',
  LastUpdatedBlockNumber = 'lastUpdatedBlockNumber',
  LastUpdatedTimestamp = 'lastUpdatedTimestamp',
  Locked = 'locked',
  PendingRewards = 'pendingRewards',
  RewardDebt = 'rewardDebt',
  Shares = 'shares',
  Stake = 'stake',
  StakePoolId = 'stakePoolId',
  StakeRewards = 'stakeRewards',
  UpdatedAt = 'updatedAt',
  UserId = 'userId'
}

export type StakePoolStakersScalarWhereInput = {
  AND?: InputMaybe<Array<StakePoolStakersScalarWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolStakersScalarWhereInput>>;
  OR?: InputMaybe<Array<StakePoolStakersScalarWhereInput>>;
  address?: InputMaybe<StringNullableFilter>;
  availableRewards?: InputMaybe<DecimalFilter>;
  claimableRewards?: InputMaybe<DecimalFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<BigIntFilter>;
  instantClaimableRewards?: InputMaybe<DecimalFilter>;
  isOwner?: InputMaybe<BoolFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  locked?: InputMaybe<DecimalFilter>;
  pendingRewards?: InputMaybe<DecimalFilter>;
  rewardDebt?: InputMaybe<DecimalFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stake?: InputMaybe<DecimalFilter>;
  stakePoolId?: InputMaybe<BigIntFilter>;
  stakeRewards?: InputMaybe<DecimalFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  userId?: InputMaybe<BigIntFilter>;
};

export type StakePoolStakersScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StakePoolStakersScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StakePoolStakersScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StakePoolStakersScalarWhereWithAggregatesInput>>;
  address?: InputMaybe<StringNullableWithAggregatesFilter>;
  availableRewards?: InputMaybe<DecimalWithAggregatesFilter>;
  claimableRewards?: InputMaybe<DecimalWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  instantClaimableRewards?: InputMaybe<DecimalWithAggregatesFilter>;
  isOwner?: InputMaybe<BoolWithAggregatesFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  locked?: InputMaybe<DecimalWithAggregatesFilter>;
  pendingRewards?: InputMaybe<DecimalWithAggregatesFilter>;
  rewardDebt?: InputMaybe<DecimalWithAggregatesFilter>;
  shares?: InputMaybe<DecimalWithAggregatesFilter>;
  stake?: InputMaybe<DecimalWithAggregatesFilter>;
  stakePoolId?: InputMaybe<BigIntWithAggregatesFilter>;
  stakeRewards?: InputMaybe<DecimalWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  userId?: InputMaybe<BigIntWithAggregatesFilter>;
};

export type StakePoolStakersSumAggregate = {
  __typename?: 'StakePoolStakersSumAggregate';
  availableRewards?: Maybe<Scalars['Decimal']>;
  claimableRewards?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  instantClaimableRewards?: Maybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingRewards?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakeRewards?: Maybe<Scalars['Decimal']>;
  userId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolStakersSumOrderByAggregateInput = {
  availableRewards?: InputMaybe<SortOrder>;
  claimableRewards?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableRewards?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingRewards?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakeRewards?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersUpdateInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolStakersInput>;
  address?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  availableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  claimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  instantClaimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  isOwner?: InputMaybe<BoolFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  locked?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pendingRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  rewardDebt?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesUpdateManyWithoutStakePoolStakersInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutStakePoolStakersInput>;
  stakeRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StakePoolStakersUpdateManyMutationInput = {
  address?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  availableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  claimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  instantClaimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  isOwner?: InputMaybe<BoolFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  locked?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pendingRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  rewardDebt?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakeRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StakePoolStakersUpdateManyWithWhereWithoutAccountsInput = {
  data: StakePoolStakersUpdateManyMutationInput;
  where: StakePoolStakersScalarWhereInput;
};

export type StakePoolStakersUpdateManyWithWhereWithoutStakePoolsInput = {
  data: StakePoolStakersUpdateManyMutationInput;
  where: StakePoolStakersScalarWhereInput;
};

export type StakePoolStakersUpdateManyWithoutAccountsInput = {
  connect?: InputMaybe<Array<StakePoolStakersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolStakersCreateOrConnectWithoutAccountsInput>>;
  create?: InputMaybe<Array<StakePoolStakersCreateWithoutAccountsInput>>;
  createMany?: InputMaybe<StakePoolStakersCreateManyAccountsInputEnvelope>;
  delete?: InputMaybe<Array<StakePoolStakersWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StakePoolStakersScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StakePoolStakersWhereUniqueInput>>;
  set?: InputMaybe<Array<StakePoolStakersWhereUniqueInput>>;
  update?: InputMaybe<Array<StakePoolStakersUpdateWithWhereUniqueWithoutAccountsInput>>;
  updateMany?: InputMaybe<Array<StakePoolStakersUpdateManyWithWhereWithoutAccountsInput>>;
  upsert?: InputMaybe<Array<StakePoolStakersUpsertWithWhereUniqueWithoutAccountsInput>>;
};

export type StakePoolStakersUpdateManyWithoutStakePoolsInput = {
  connect?: InputMaybe<Array<StakePoolStakersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolStakersCreateOrConnectWithoutStakePoolsInput>>;
  create?: InputMaybe<Array<StakePoolStakersCreateWithoutStakePoolsInput>>;
  createMany?: InputMaybe<StakePoolStakersCreateManyStakePoolsInputEnvelope>;
  delete?: InputMaybe<Array<StakePoolStakersWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StakePoolStakersScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StakePoolStakersWhereUniqueInput>>;
  set?: InputMaybe<Array<StakePoolStakersWhereUniqueInput>>;
  update?: InputMaybe<Array<StakePoolStakersUpdateWithWhereUniqueWithoutStakePoolsInput>>;
  updateMany?: InputMaybe<Array<StakePoolStakersUpdateManyWithWhereWithoutStakePoolsInput>>;
  upsert?: InputMaybe<Array<StakePoolStakersUpsertWithWhereUniqueWithoutStakePoolsInput>>;
};

export type StakePoolStakersUpdateOneRequiredWithoutStakePoolStakerActivitiesInput = {
  connect?: InputMaybe<StakePoolStakersWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolStakersCreateOrConnectWithoutStakePoolStakerActivitiesInput>;
  create?: InputMaybe<StakePoolStakersCreateWithoutStakePoolStakerActivitiesInput>;
  update?: InputMaybe<StakePoolStakersUpdateWithoutStakePoolStakerActivitiesInput>;
  upsert?: InputMaybe<StakePoolStakersUpsertWithoutStakePoolStakerActivitiesInput>;
};

export type StakePoolStakersUpdateWithWhereUniqueWithoutAccountsInput = {
  data: StakePoolStakersUpdateWithoutAccountsInput;
  where: StakePoolStakersWhereUniqueInput;
};

export type StakePoolStakersUpdateWithWhereUniqueWithoutStakePoolsInput = {
  data: StakePoolStakersUpdateWithoutStakePoolsInput;
  where: StakePoolStakersWhereUniqueInput;
};

export type StakePoolStakersUpdateWithoutAccountsInput = {
  address?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  availableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  claimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  instantClaimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  isOwner?: InputMaybe<BoolFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  locked?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pendingRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  rewardDebt?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesUpdateManyWithoutStakePoolStakersInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutStakePoolStakersInput>;
  stakeRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StakePoolStakersUpdateWithoutStakePoolStakerActivitiesInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolStakersInput>;
  address?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  availableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  claimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  instantClaimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  isOwner?: InputMaybe<BoolFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  locked?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pendingRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  rewardDebt?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutStakePoolStakersInput>;
  stakeRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StakePoolStakersUpdateWithoutStakePoolsInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolStakersInput>;
  address?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  availableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  claimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  instantClaimableRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  isOwner?: InputMaybe<BoolFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  locked?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pendingRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  rewardDebt?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesUpdateManyWithoutStakePoolStakersInput>;
  stakeRewards?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StakePoolStakersUpsertWithWhereUniqueWithoutAccountsInput = {
  create: StakePoolStakersCreateWithoutAccountsInput;
  update: StakePoolStakersUpdateWithoutAccountsInput;
  where: StakePoolStakersWhereUniqueInput;
};

export type StakePoolStakersUpsertWithWhereUniqueWithoutStakePoolsInput = {
  create: StakePoolStakersCreateWithoutStakePoolsInput;
  update: StakePoolStakersUpdateWithoutStakePoolsInput;
  where: StakePoolStakersWhereUniqueInput;
};

export type StakePoolStakersUpsertWithoutStakePoolStakerActivitiesInput = {
  create: StakePoolStakersCreateWithoutStakePoolStakerActivitiesInput;
  update: StakePoolStakersUpdateWithoutStakePoolStakerActivitiesInput;
};

export type StakePoolStakersWhereInput = {
  AND?: InputMaybe<Array<StakePoolStakersWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolStakersWhereInput>>;
  OR?: InputMaybe<Array<StakePoolStakersWhereInput>>;
  accounts?: InputMaybe<AccountsRelationFilter>;
  address?: InputMaybe<StringNullableFilter>;
  availableRewards?: InputMaybe<DecimalFilter>;
  claimableRewards?: InputMaybe<DecimalFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<BigIntFilter>;
  instantClaimableRewards?: InputMaybe<DecimalFilter>;
  isOwner?: InputMaybe<BoolFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  locked?: InputMaybe<DecimalFilter>;
  pendingRewards?: InputMaybe<DecimalFilter>;
  rewardDebt?: InputMaybe<DecimalFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stake?: InputMaybe<DecimalFilter>;
  stakePoolId?: InputMaybe<BigIntFilter>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesListRelationFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  stakeRewards?: InputMaybe<DecimalFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  userId?: InputMaybe<BigIntFilter>;
};

export type StakePoolStakersWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type StakePoolWithdrawals = {
  __typename?: 'StakePoolWithdrawals';
  accounts: Accounts;
  createdAt: Scalars['DateTime'];
  endBlockNumber?: Maybe<Scalars['BigInt']>;
  endEventId?: Maybe<Scalars['BigInt']>;
  endTimestamp?: Maybe<Scalars['DateTime']>;
  estimatesEndTime: Scalars['DateTime'];
  eventsEventsToStakePoolWithdrawalsEndEventId?: Maybe<Events>;
  eventsEventsToStakePoolWithdrawalsStartEventId?: Maybe<Events>;
  id: Scalars['BigInt'];
  shares: Scalars['Decimal'];
  stake: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakePools: StakePools;
  startBlockNumber?: Maybe<Scalars['BigInt']>;
  startEventId?: Maybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: Maybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: Maybe<Scalars['String']>;
  userId: Scalars['BigInt'];
};

export type StakePoolWithdrawalsAvgAggregate = {
  __typename?: 'StakePoolWithdrawalsAvgAggregate';
  endBlockNumber?: Maybe<Scalars['Float']>;
  endEventId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['Float']>;
  startBlockNumber?: Maybe<Scalars['Float']>;
  startEventId?: Maybe<Scalars['Float']>;
  userId?: Maybe<Scalars['Float']>;
};

export type StakePoolWithdrawalsAvgOrderByAggregateInput = {
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsCountAggregate = {
  __typename?: 'StakePoolWithdrawalsCountAggregate';
  _all: Scalars['Int'];
  createdAt: Scalars['Int'];
  endBlockNumber: Scalars['Int'];
  endEventId: Scalars['Int'];
  endTimestamp: Scalars['Int'];
  estimatesEndTime: Scalars['Int'];
  id: Scalars['Int'];
  shares: Scalars['Int'];
  stake: Scalars['Int'];
  stakePoolId: Scalars['Int'];
  startBlockNumber: Scalars['Int'];
  startEventId: Scalars['Int'];
  startTime: Scalars['Int'];
  startTimestamp: Scalars['Int'];
  updatedAt: Scalars['Int'];
  userAddress: Scalars['Int'];
  userId: Scalars['Int'];
};

export type StakePoolWithdrawalsCountOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  endTimestamp?: InputMaybe<SortOrder>;
  estimatesEndTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  startTime?: InputMaybe<SortOrder>;
  startTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAddress?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsCreateInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolWithdrawalsInput;
  createdAt: Scalars['DateTime'];
  endBlockNumber?: InputMaybe<Scalars['BigInt']>;
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  estimatesEndTime?: InputMaybe<Scalars['DateTime']>;
  eventsEventsToStakePoolWithdrawalsEndEventId?: InputMaybe<EventsCreateNestedOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
  eventsEventsToStakePoolWithdrawalsStartEventId?: InputMaybe<EventsCreateNestedOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  shares: Scalars['Decimal'];
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePools: StakePoolsCreateNestedOneWithoutStakePoolWithdrawalsInput;
  startBlockNumber?: InputMaybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: InputMaybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: InputMaybe<Scalars['String']>;
};

export type StakePoolWithdrawalsCreateManyAccountsInput = {
  createdAt: Scalars['DateTime'];
  endBlockNumber?: InputMaybe<Scalars['BigInt']>;
  endEventId?: InputMaybe<Scalars['BigInt']>;
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  estimatesEndTime?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  shares: Scalars['Decimal'];
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolId: Scalars['BigInt'];
  startBlockNumber?: InputMaybe<Scalars['BigInt']>;
  startEventId?: InputMaybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: InputMaybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: InputMaybe<Scalars['String']>;
};

export type StakePoolWithdrawalsCreateManyAccountsInputEnvelope = {
  data: Array<StakePoolWithdrawalsCreateManyAccountsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type StakePoolWithdrawalsCreateManyEventsEventsToStakePoolWithdrawalsEndEventIdInput = {
  createdAt: Scalars['DateTime'];
  endBlockNumber?: InputMaybe<Scalars['BigInt']>;
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  estimatesEndTime?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  shares: Scalars['Decimal'];
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolId: Scalars['BigInt'];
  startBlockNumber?: InputMaybe<Scalars['BigInt']>;
  startEventId?: InputMaybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: InputMaybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: InputMaybe<Scalars['String']>;
  userId: Scalars['BigInt'];
};

export type StakePoolWithdrawalsCreateManyEventsEventsToStakePoolWithdrawalsEndEventIdInputEnvelope = {
  data: Array<StakePoolWithdrawalsCreateManyEventsEventsToStakePoolWithdrawalsEndEventIdInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type StakePoolWithdrawalsCreateManyEventsEventsToStakePoolWithdrawalsStartEventIdInput = {
  createdAt: Scalars['DateTime'];
  endBlockNumber?: InputMaybe<Scalars['BigInt']>;
  endEventId?: InputMaybe<Scalars['BigInt']>;
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  estimatesEndTime?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  shares: Scalars['Decimal'];
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolId: Scalars['BigInt'];
  startBlockNumber?: InputMaybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: InputMaybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: InputMaybe<Scalars['String']>;
  userId: Scalars['BigInt'];
};

export type StakePoolWithdrawalsCreateManyEventsEventsToStakePoolWithdrawalsStartEventIdInputEnvelope = {
  data: Array<StakePoolWithdrawalsCreateManyEventsEventsToStakePoolWithdrawalsStartEventIdInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type StakePoolWithdrawalsCreateManyInput = {
  createdAt: Scalars['DateTime'];
  endBlockNumber?: InputMaybe<Scalars['BigInt']>;
  endEventId?: InputMaybe<Scalars['BigInt']>;
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  estimatesEndTime?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  shares: Scalars['Decimal'];
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePoolId: Scalars['BigInt'];
  startBlockNumber?: InputMaybe<Scalars['BigInt']>;
  startEventId?: InputMaybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: InputMaybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: InputMaybe<Scalars['String']>;
  userId: Scalars['BigInt'];
};

export type StakePoolWithdrawalsCreateManyStakePoolsInput = {
  createdAt: Scalars['DateTime'];
  endBlockNumber?: InputMaybe<Scalars['BigInt']>;
  endEventId?: InputMaybe<Scalars['BigInt']>;
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  estimatesEndTime?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  shares: Scalars['Decimal'];
  stake?: InputMaybe<Scalars['Decimal']>;
  startBlockNumber?: InputMaybe<Scalars['BigInt']>;
  startEventId?: InputMaybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: InputMaybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: InputMaybe<Scalars['String']>;
  userId: Scalars['BigInt'];
};

export type StakePoolWithdrawalsCreateManyStakePoolsInputEnvelope = {
  data: Array<StakePoolWithdrawalsCreateManyStakePoolsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type StakePoolWithdrawalsCreateNestedManyWithoutAccountsInput = {
  connect?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolWithdrawalsCreateOrConnectWithoutAccountsInput>>;
  create?: InputMaybe<Array<StakePoolWithdrawalsCreateWithoutAccountsInput>>;
  createMany?: InputMaybe<StakePoolWithdrawalsCreateManyAccountsInputEnvelope>;
};

export type StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput = {
  connect?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolWithdrawalsCreateOrConnectWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>>;
  create?: InputMaybe<Array<StakePoolWithdrawalsCreateWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>>;
  createMany?: InputMaybe<StakePoolWithdrawalsCreateManyEventsEventsToStakePoolWithdrawalsEndEventIdInputEnvelope>;
};

export type StakePoolWithdrawalsCreateNestedManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput = {
  connect?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolWithdrawalsCreateOrConnectWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>>;
  create?: InputMaybe<Array<StakePoolWithdrawalsCreateWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>>;
  createMany?: InputMaybe<StakePoolWithdrawalsCreateManyEventsEventsToStakePoolWithdrawalsStartEventIdInputEnvelope>;
};

export type StakePoolWithdrawalsCreateNestedManyWithoutStakePoolsInput = {
  connect?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolWithdrawalsCreateOrConnectWithoutStakePoolsInput>>;
  create?: InputMaybe<Array<StakePoolWithdrawalsCreateWithoutStakePoolsInput>>;
  createMany?: InputMaybe<StakePoolWithdrawalsCreateManyStakePoolsInputEnvelope>;
};

export type StakePoolWithdrawalsCreateOrConnectWithoutAccountsInput = {
  create: StakePoolWithdrawalsCreateWithoutAccountsInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};

export type StakePoolWithdrawalsCreateOrConnectWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput = {
  create: StakePoolWithdrawalsCreateWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};

export type StakePoolWithdrawalsCreateOrConnectWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput = {
  create: StakePoolWithdrawalsCreateWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};

export type StakePoolWithdrawalsCreateOrConnectWithoutStakePoolsInput = {
  create: StakePoolWithdrawalsCreateWithoutStakePoolsInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};

export type StakePoolWithdrawalsCreateWithoutAccountsInput = {
  createdAt: Scalars['DateTime'];
  endBlockNumber?: InputMaybe<Scalars['BigInt']>;
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  estimatesEndTime?: InputMaybe<Scalars['DateTime']>;
  eventsEventsToStakePoolWithdrawalsEndEventId?: InputMaybe<EventsCreateNestedOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
  eventsEventsToStakePoolWithdrawalsStartEventId?: InputMaybe<EventsCreateNestedOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  shares: Scalars['Decimal'];
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePools: StakePoolsCreateNestedOneWithoutStakePoolWithdrawalsInput;
  startBlockNumber?: InputMaybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: InputMaybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: InputMaybe<Scalars['String']>;
};

export type StakePoolWithdrawalsCreateWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolWithdrawalsInput;
  createdAt: Scalars['DateTime'];
  endBlockNumber?: InputMaybe<Scalars['BigInt']>;
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  estimatesEndTime?: InputMaybe<Scalars['DateTime']>;
  eventsEventsToStakePoolWithdrawalsStartEventId?: InputMaybe<EventsCreateNestedOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  shares: Scalars['Decimal'];
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePools: StakePoolsCreateNestedOneWithoutStakePoolWithdrawalsInput;
  startBlockNumber?: InputMaybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: InputMaybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: InputMaybe<Scalars['String']>;
};

export type StakePoolWithdrawalsCreateWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolWithdrawalsInput;
  createdAt: Scalars['DateTime'];
  endBlockNumber?: InputMaybe<Scalars['BigInt']>;
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  estimatesEndTime?: InputMaybe<Scalars['DateTime']>;
  eventsEventsToStakePoolWithdrawalsEndEventId?: InputMaybe<EventsCreateNestedOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  shares: Scalars['Decimal'];
  stake?: InputMaybe<Scalars['Decimal']>;
  stakePools: StakePoolsCreateNestedOneWithoutStakePoolWithdrawalsInput;
  startBlockNumber?: InputMaybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: InputMaybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: InputMaybe<Scalars['String']>;
};

export type StakePoolWithdrawalsCreateWithoutStakePoolsInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolWithdrawalsInput;
  createdAt: Scalars['DateTime'];
  endBlockNumber?: InputMaybe<Scalars['BigInt']>;
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  estimatesEndTime?: InputMaybe<Scalars['DateTime']>;
  eventsEventsToStakePoolWithdrawalsEndEventId?: InputMaybe<EventsCreateNestedOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
  eventsEventsToStakePoolWithdrawalsStartEventId?: InputMaybe<EventsCreateNestedOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  shares: Scalars['Decimal'];
  stake?: InputMaybe<Scalars['Decimal']>;
  startBlockNumber?: InputMaybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: InputMaybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: InputMaybe<Scalars['String']>;
};

export type StakePoolWithdrawalsGroupBy = {
  __typename?: 'StakePoolWithdrawalsGroupBy';
  _avg?: Maybe<StakePoolWithdrawalsAvgAggregate>;
  _count?: Maybe<StakePoolWithdrawalsCountAggregate>;
  _max?: Maybe<StakePoolWithdrawalsMaxAggregate>;
  _min?: Maybe<StakePoolWithdrawalsMinAggregate>;
  _sum?: Maybe<StakePoolWithdrawalsSumAggregate>;
  createdAt: Scalars['DateTime'];
  endBlockNumber?: Maybe<Scalars['BigInt']>;
  endEventId?: Maybe<Scalars['BigInt']>;
  endTimestamp?: Maybe<Scalars['DateTime']>;
  estimatesEndTime: Scalars['DateTime'];
  id: Scalars['BigInt'];
  shares: Scalars['Decimal'];
  stake: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  startBlockNumber?: Maybe<Scalars['BigInt']>;
  startEventId?: Maybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: Maybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: Maybe<Scalars['String']>;
  userId: Scalars['BigInt'];
};

export type StakePoolWithdrawalsListRelationFilter = {
  every?: InputMaybe<StakePoolWithdrawalsWhereInput>;
  none?: InputMaybe<StakePoolWithdrawalsWhereInput>;
  some?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};

export type StakePoolWithdrawalsMaxAggregate = {
  __typename?: 'StakePoolWithdrawalsMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']>;
  endBlockNumber?: Maybe<Scalars['BigInt']>;
  endEventId?: Maybe<Scalars['BigInt']>;
  endTimestamp?: Maybe<Scalars['DateTime']>;
  estimatesEndTime?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  startBlockNumber?: Maybe<Scalars['BigInt']>;
  startEventId?: Maybe<Scalars['BigInt']>;
  startTime?: Maybe<Scalars['DateTime']>;
  startTimestamp?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userAddress?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolWithdrawalsMaxOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  endTimestamp?: InputMaybe<SortOrder>;
  estimatesEndTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  startTime?: InputMaybe<SortOrder>;
  startTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAddress?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsMinAggregate = {
  __typename?: 'StakePoolWithdrawalsMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']>;
  endBlockNumber?: Maybe<Scalars['BigInt']>;
  endEventId?: Maybe<Scalars['BigInt']>;
  endTimestamp?: Maybe<Scalars['DateTime']>;
  estimatesEndTime?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  startBlockNumber?: Maybe<Scalars['BigInt']>;
  startEventId?: Maybe<Scalars['BigInt']>;
  startTime?: Maybe<Scalars['DateTime']>;
  startTimestamp?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userAddress?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolWithdrawalsMinOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  endTimestamp?: InputMaybe<SortOrder>;
  estimatesEndTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  startTime?: InputMaybe<SortOrder>;
  startTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAddress?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsOrderByWithAggregationInput = {
  _avg?: InputMaybe<StakePoolWithdrawalsAvgOrderByAggregateInput>;
  _count?: InputMaybe<StakePoolWithdrawalsCountOrderByAggregateInput>;
  _max?: InputMaybe<StakePoolWithdrawalsMaxOrderByAggregateInput>;
  _min?: InputMaybe<StakePoolWithdrawalsMinOrderByAggregateInput>;
  _sum?: InputMaybe<StakePoolWithdrawalsSumOrderByAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  endTimestamp?: InputMaybe<SortOrder>;
  estimatesEndTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  startTime?: InputMaybe<SortOrder>;
  startTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAddress?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsOrderByWithRelationInput = {
  accounts?: InputMaybe<AccountsOrderByWithRelationInput>;
  createdAt?: InputMaybe<SortOrder>;
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  endTimestamp?: InputMaybe<SortOrder>;
  estimatesEndTime?: InputMaybe<SortOrder>;
  eventsEventsToStakePoolWithdrawalsEndEventId?: InputMaybe<EventsOrderByWithRelationInput>;
  eventsEventsToStakePoolWithdrawalsStartEventId?: InputMaybe<EventsOrderByWithRelationInput>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  startTime?: InputMaybe<SortOrder>;
  startTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAddress?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export enum StakePoolWithdrawalsScalarFieldEnum {
  CreatedAt = 'createdAt',
  EndBlockNumber = 'endBlockNumber',
  EndEventId = 'endEventId',
  EndTimestamp = 'endTimestamp',
  EstimatesEndTime = 'estimatesEndTime',
  Id = 'id',
  Shares = 'shares',
  Stake = 'stake',
  StakePoolId = 'stakePoolId',
  StartBlockNumber = 'startBlockNumber',
  StartEventId = 'startEventId',
  StartTime = 'startTime',
  StartTimestamp = 'startTimestamp',
  UpdatedAt = 'updatedAt',
  UserAddress = 'userAddress',
  UserId = 'userId'
}

export type StakePoolWithdrawalsScalarWhereInput = {
  AND?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereInput>>;
  OR?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  endBlockNumber?: InputMaybe<BigIntNullableFilter>;
  endEventId?: InputMaybe<BigIntNullableFilter>;
  endTimestamp?: InputMaybe<DateTimeNullableFilter>;
  estimatesEndTime?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<BigIntFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stake?: InputMaybe<DecimalFilter>;
  stakePoolId?: InputMaybe<BigIntFilter>;
  startBlockNumber?: InputMaybe<BigIntNullableFilter>;
  startEventId?: InputMaybe<BigIntNullableFilter>;
  startTime?: InputMaybe<DateTimeFilter>;
  startTimestamp?: InputMaybe<DateTimeNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  userAddress?: InputMaybe<StringNullableFilter>;
  userId?: InputMaybe<BigIntFilter>;
};

export type StakePoolWithdrawalsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereWithAggregatesInput>>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  endBlockNumber?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  endEventId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  endTimestamp?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  estimatesEndTime?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  shares?: InputMaybe<DecimalWithAggregatesFilter>;
  stake?: InputMaybe<DecimalWithAggregatesFilter>;
  stakePoolId?: InputMaybe<BigIntWithAggregatesFilter>;
  startBlockNumber?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  startEventId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  startTime?: InputMaybe<DateTimeWithAggregatesFilter>;
  startTimestamp?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  userAddress?: InputMaybe<StringNullableWithAggregatesFilter>;
  userId?: InputMaybe<BigIntWithAggregatesFilter>;
};

export type StakePoolWithdrawalsSumAggregate = {
  __typename?: 'StakePoolWithdrawalsSumAggregate';
  endBlockNumber?: Maybe<Scalars['BigInt']>;
  endEventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  startBlockNumber?: Maybe<Scalars['BigInt']>;
  startEventId?: Maybe<Scalars['BigInt']>;
  userId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolWithdrawalsSumOrderByAggregateInput = {
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsUpdateInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolWithdrawalsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  endBlockNumber?: InputMaybe<NullableBigIntFieldUpdateOperationsInput>;
  endTimestamp?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  estimatesEndTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  eventsEventsToStakePoolWithdrawalsEndEventId?: InputMaybe<EventsUpdateOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
  eventsEventsToStakePoolWithdrawalsStartEventId?: InputMaybe<EventsUpdateOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutStakePoolWithdrawalsInput>;
  startBlockNumber?: InputMaybe<NullableBigIntFieldUpdateOperationsInput>;
  startTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  startTimestamp?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  userAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StakePoolWithdrawalsUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  endBlockNumber?: InputMaybe<NullableBigIntFieldUpdateOperationsInput>;
  endTimestamp?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  estimatesEndTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  startBlockNumber?: InputMaybe<NullableBigIntFieldUpdateOperationsInput>;
  startTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  startTimestamp?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  userAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StakePoolWithdrawalsUpdateManyWithWhereWithoutAccountsInput = {
  data: StakePoolWithdrawalsUpdateManyMutationInput;
  where: StakePoolWithdrawalsScalarWhereInput;
};

export type StakePoolWithdrawalsUpdateManyWithWhereWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput = {
  data: StakePoolWithdrawalsUpdateManyMutationInput;
  where: StakePoolWithdrawalsScalarWhereInput;
};

export type StakePoolWithdrawalsUpdateManyWithWhereWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput = {
  data: StakePoolWithdrawalsUpdateManyMutationInput;
  where: StakePoolWithdrawalsScalarWhereInput;
};

export type StakePoolWithdrawalsUpdateManyWithWhereWithoutStakePoolsInput = {
  data: StakePoolWithdrawalsUpdateManyMutationInput;
  where: StakePoolWithdrawalsScalarWhereInput;
};

export type StakePoolWithdrawalsUpdateManyWithoutAccountsInput = {
  connect?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolWithdrawalsCreateOrConnectWithoutAccountsInput>>;
  create?: InputMaybe<Array<StakePoolWithdrawalsCreateWithoutAccountsInput>>;
  createMany?: InputMaybe<StakePoolWithdrawalsCreateManyAccountsInputEnvelope>;
  delete?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  set?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  update?: InputMaybe<Array<StakePoolWithdrawalsUpdateWithWhereUniqueWithoutAccountsInput>>;
  updateMany?: InputMaybe<Array<StakePoolWithdrawalsUpdateManyWithWhereWithoutAccountsInput>>;
  upsert?: InputMaybe<Array<StakePoolWithdrawalsUpsertWithWhereUniqueWithoutAccountsInput>>;
};

export type StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput = {
  connect?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolWithdrawalsCreateOrConnectWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>>;
  create?: InputMaybe<Array<StakePoolWithdrawalsCreateWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>>;
  createMany?: InputMaybe<StakePoolWithdrawalsCreateManyEventsEventsToStakePoolWithdrawalsEndEventIdInputEnvelope>;
  delete?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  set?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  update?: InputMaybe<Array<StakePoolWithdrawalsUpdateWithWhereUniqueWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>>;
  updateMany?: InputMaybe<Array<StakePoolWithdrawalsUpdateManyWithWhereWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>>;
  upsert?: InputMaybe<Array<StakePoolWithdrawalsUpsertWithWhereUniqueWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput>>;
};

export type StakePoolWithdrawalsUpdateManyWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput = {
  connect?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolWithdrawalsCreateOrConnectWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>>;
  create?: InputMaybe<Array<StakePoolWithdrawalsCreateWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>>;
  createMany?: InputMaybe<StakePoolWithdrawalsCreateManyEventsEventsToStakePoolWithdrawalsStartEventIdInputEnvelope>;
  delete?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  set?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  update?: InputMaybe<Array<StakePoolWithdrawalsUpdateWithWhereUniqueWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>>;
  updateMany?: InputMaybe<Array<StakePoolWithdrawalsUpdateManyWithWhereWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>>;
  upsert?: InputMaybe<Array<StakePoolWithdrawalsUpsertWithWhereUniqueWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput>>;
};

export type StakePoolWithdrawalsUpdateManyWithoutStakePoolsInput = {
  connect?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolWithdrawalsCreateOrConnectWithoutStakePoolsInput>>;
  create?: InputMaybe<Array<StakePoolWithdrawalsCreateWithoutStakePoolsInput>>;
  createMany?: InputMaybe<StakePoolWithdrawalsCreateManyStakePoolsInputEnvelope>;
  delete?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  set?: InputMaybe<Array<StakePoolWithdrawalsWhereUniqueInput>>;
  update?: InputMaybe<Array<StakePoolWithdrawalsUpdateWithWhereUniqueWithoutStakePoolsInput>>;
  updateMany?: InputMaybe<Array<StakePoolWithdrawalsUpdateManyWithWhereWithoutStakePoolsInput>>;
  upsert?: InputMaybe<Array<StakePoolWithdrawalsUpsertWithWhereUniqueWithoutStakePoolsInput>>;
};

export type StakePoolWithdrawalsUpdateWithWhereUniqueWithoutAccountsInput = {
  data: StakePoolWithdrawalsUpdateWithoutAccountsInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};

export type StakePoolWithdrawalsUpdateWithWhereUniqueWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput = {
  data: StakePoolWithdrawalsUpdateWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};

export type StakePoolWithdrawalsUpdateWithWhereUniqueWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput = {
  data: StakePoolWithdrawalsUpdateWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};

export type StakePoolWithdrawalsUpdateWithWhereUniqueWithoutStakePoolsInput = {
  data: StakePoolWithdrawalsUpdateWithoutStakePoolsInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};

export type StakePoolWithdrawalsUpdateWithoutAccountsInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  endBlockNumber?: InputMaybe<NullableBigIntFieldUpdateOperationsInput>;
  endTimestamp?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  estimatesEndTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  eventsEventsToStakePoolWithdrawalsEndEventId?: InputMaybe<EventsUpdateOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
  eventsEventsToStakePoolWithdrawalsStartEventId?: InputMaybe<EventsUpdateOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutStakePoolWithdrawalsInput>;
  startBlockNumber?: InputMaybe<NullableBigIntFieldUpdateOperationsInput>;
  startTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  startTimestamp?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  userAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StakePoolWithdrawalsUpdateWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolWithdrawalsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  endBlockNumber?: InputMaybe<NullableBigIntFieldUpdateOperationsInput>;
  endTimestamp?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  estimatesEndTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  eventsEventsToStakePoolWithdrawalsStartEventId?: InputMaybe<EventsUpdateOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutStakePoolWithdrawalsInput>;
  startBlockNumber?: InputMaybe<NullableBigIntFieldUpdateOperationsInput>;
  startTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  startTimestamp?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  userAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StakePoolWithdrawalsUpdateWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolWithdrawalsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  endBlockNumber?: InputMaybe<NullableBigIntFieldUpdateOperationsInput>;
  endTimestamp?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  estimatesEndTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  eventsEventsToStakePoolWithdrawalsEndEventId?: InputMaybe<EventsUpdateOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneRequiredWithoutStakePoolWithdrawalsInput>;
  startBlockNumber?: InputMaybe<NullableBigIntFieldUpdateOperationsInput>;
  startTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  startTimestamp?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  userAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StakePoolWithdrawalsUpdateWithoutStakePoolsInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolWithdrawalsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  endBlockNumber?: InputMaybe<NullableBigIntFieldUpdateOperationsInput>;
  endTimestamp?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  estimatesEndTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  eventsEventsToStakePoolWithdrawalsEndEventId?: InputMaybe<EventsUpdateOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsEndEventIdsInput>;
  eventsEventsToStakePoolWithdrawalsStartEventId?: InputMaybe<EventsUpdateOneWithoutStakePoolWithdrawalsEventsToStakePoolWithdrawalsStartEventIdsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  shares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  startBlockNumber?: InputMaybe<NullableBigIntFieldUpdateOperationsInput>;
  startTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  startTimestamp?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  userAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StakePoolWithdrawalsUpsertWithWhereUniqueWithoutAccountsInput = {
  create: StakePoolWithdrawalsCreateWithoutAccountsInput;
  update: StakePoolWithdrawalsUpdateWithoutAccountsInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};

export type StakePoolWithdrawalsUpsertWithWhereUniqueWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput = {
  create: StakePoolWithdrawalsCreateWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput;
  update: StakePoolWithdrawalsUpdateWithoutEventsEventsToStakePoolWithdrawalsEndEventIdInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};

export type StakePoolWithdrawalsUpsertWithWhereUniqueWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput = {
  create: StakePoolWithdrawalsCreateWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput;
  update: StakePoolWithdrawalsUpdateWithoutEventsEventsToStakePoolWithdrawalsStartEventIdInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};

export type StakePoolWithdrawalsUpsertWithWhereUniqueWithoutStakePoolsInput = {
  create: StakePoolWithdrawalsCreateWithoutStakePoolsInput;
  update: StakePoolWithdrawalsUpdateWithoutStakePoolsInput;
  where: StakePoolWithdrawalsWhereUniqueInput;
};

export type StakePoolWithdrawalsWhereInput = {
  AND?: InputMaybe<Array<StakePoolWithdrawalsWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolWithdrawalsWhereInput>>;
  OR?: InputMaybe<Array<StakePoolWithdrawalsWhereInput>>;
  accounts?: InputMaybe<AccountsRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  endBlockNumber?: InputMaybe<BigIntNullableFilter>;
  endEventId?: InputMaybe<BigIntNullableFilter>;
  endTimestamp?: InputMaybe<DateTimeNullableFilter>;
  estimatesEndTime?: InputMaybe<DateTimeFilter>;
  eventsEventsToStakePoolWithdrawalsEndEventId?: InputMaybe<EventsRelationFilter>;
  eventsEventsToStakePoolWithdrawalsStartEventId?: InputMaybe<EventsRelationFilter>;
  id?: InputMaybe<BigIntFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stake?: InputMaybe<DecimalFilter>;
  stakePoolId?: InputMaybe<BigIntFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  startBlockNumber?: InputMaybe<BigIntNullableFilter>;
  startEventId?: InputMaybe<BigIntNullableFilter>;
  startTime?: InputMaybe<DateTimeFilter>;
  startTimestamp?: InputMaybe<DateTimeNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  userAddress?: InputMaybe<StringNullableFilter>;
  userId?: InputMaybe<BigIntFilter>;
};

export type StakePoolWithdrawalsWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type StakePools = {
  __typename?: 'StakePools';
  _count?: Maybe<StakePoolsCount>;
  accounts: Accounts;
  cap?: Maybe<Scalars['Decimal']>;
  commission: Scalars['Decimal'];
  coolingDownMinersCount: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  freeStake: Scalars['Decimal'];
  id: Scalars['BigInt'];
  idleMinersCount: Scalars['Int'];
  instantApr: Scalars['Decimal'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  miners: Array<Miners>;
  minersCount: Scalars['Int'];
  ownerAddress: Scalars['String'];
  ownerId: Scalars['BigInt'];
  ownerReward: Scalars['Decimal'];
  pid: Scalars['Int'];
  readyMinersCount: Scalars['Int'];
  releasingStake: Scalars['Decimal'];
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc: Scalars['Decimal'];
  stakePoolActivities: Array<StakePoolActivities>;
  stakePoolStakers: Array<StakePoolStakers>;
  stakePoolWithdrawals: Array<StakePoolWithdrawals>;
  stakersCount: Scalars['Int'];
  totalShares: Scalars['Decimal'];
  totalStake: Scalars['Decimal'];
  unresponsiveMinersCount: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
  usedStake: Scalars['Decimal'];
  withdrawalsCount: Scalars['Int'];
  workerActivities: Array<WorkerActivities>;
  workers: Array<Workers>;
};


export type StakePoolsMinersArgs = {
  cursor?: InputMaybe<MinersWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinersWhereInput>;
};


export type StakePoolsStakePoolActivitiesArgs = {
  cursor?: InputMaybe<StakePoolActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type StakePoolsStakePoolStakersArgs = {
  cursor?: InputMaybe<StakePoolStakersWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type StakePoolsStakePoolWithdrawalsArgs = {
  cursor?: InputMaybe<StakePoolWithdrawalsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolWithdrawalsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type StakePoolsWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type StakePoolsWorkersArgs = {
  cursor?: InputMaybe<WorkersWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};

export type StakePoolsAvgAggregate = {
  __typename?: 'StakePoolsAvgAggregate';
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Float']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['Float']>;
  idleMinersCount?: Maybe<Scalars['Float']>;
  instantApr?: Maybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  minersCount?: Maybe<Scalars['Float']>;
  ownerId?: Maybe<Scalars['Float']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  pid?: Maybe<Scalars['Float']>;
  readyMinersCount?: Maybe<Scalars['Float']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakersCount?: Maybe<Scalars['Float']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: Maybe<Scalars['Float']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Float']>;
};

export type StakePoolsAvgOrderByAggregateInput = {
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolsCount = {
  __typename?: 'StakePoolsCount';
  miners: Scalars['Int'];
  stakePoolActivities: Scalars['Int'];
  stakePoolStakers: Scalars['Int'];
  stakePoolWithdrawals: Scalars['Int'];
  workerActivities: Scalars['Int'];
  workers: Scalars['Int'];
};

export type StakePoolsCountAggregate = {
  __typename?: 'StakePoolsCountAggregate';
  _all: Scalars['Int'];
  cap: Scalars['Int'];
  commission: Scalars['Int'];
  coolingDownMinersCount: Scalars['Int'];
  createdAt: Scalars['Int'];
  freeStake: Scalars['Int'];
  id: Scalars['Int'];
  idleMinersCount: Scalars['Int'];
  instantApr: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['Int'];
  lastUpdatedTimestamp: Scalars['Int'];
  minersCount: Scalars['Int'];
  ownerAddress: Scalars['Int'];
  ownerId: Scalars['Int'];
  ownerReward: Scalars['Int'];
  pid: Scalars['Int'];
  readyMinersCount: Scalars['Int'];
  releasingStake: Scalars['Int'];
  remainingStake: Scalars['Int'];
  rewardAcc: Scalars['Int'];
  stakersCount: Scalars['Int'];
  totalShares: Scalars['Int'];
  totalStake: Scalars['Int'];
  unresponsiveMinersCount: Scalars['Int'];
  updatedAt: Scalars['Int'];
  usedStake: Scalars['Int'];
  withdrawalsCount: Scalars['Int'];
};

export type StakePoolsCountOrderByAggregateInput = {
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerAddress?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolsCreateInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolsInput;
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: InputMaybe<Scalars['BigInt']>;
  lastUpdatedTimestamp: Scalars['DateTime'];
  miners?: InputMaybe<MinersCreateNestedManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerAddress: Scalars['String'];
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  pid: Scalars['Int'];
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutStakePoolsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersCreateNestedManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<Scalars['Int']>;
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutStakePoolsInput>;
  workers?: InputMaybe<WorkersCreateNestedManyWithoutStakePoolsInput>;
};

export type StakePoolsCreateManyAccountsInput = {
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: InputMaybe<Scalars['BigInt']>;
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerAddress: Scalars['String'];
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  pid: Scalars['Int'];
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakersCount?: InputMaybe<Scalars['Int']>;
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
};

export type StakePoolsCreateManyAccountsInputEnvelope = {
  data: Array<StakePoolsCreateManyAccountsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type StakePoolsCreateManyInput = {
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: InputMaybe<Scalars['BigInt']>;
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerAddress: Scalars['String'];
  ownerId: Scalars['BigInt'];
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  pid: Scalars['Int'];
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakersCount?: InputMaybe<Scalars['Int']>;
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
};

export type StakePoolsCreateNestedManyWithoutAccountsInput = {
  connect?: InputMaybe<Array<StakePoolsWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolsCreateOrConnectWithoutAccountsInput>>;
  create?: InputMaybe<Array<StakePoolsCreateWithoutAccountsInput>>;
  createMany?: InputMaybe<StakePoolsCreateManyAccountsInputEnvelope>;
};

export type StakePoolsCreateNestedOneWithoutMinersInput = {
  connect?: InputMaybe<StakePoolsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolsCreateOrConnectWithoutMinersInput>;
  create?: InputMaybe<StakePoolsCreateWithoutMinersInput>;
};

export type StakePoolsCreateNestedOneWithoutStakePoolActivitiesInput = {
  connect?: InputMaybe<StakePoolsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolsCreateOrConnectWithoutStakePoolActivitiesInput>;
  create?: InputMaybe<StakePoolsCreateWithoutStakePoolActivitiesInput>;
};

export type StakePoolsCreateNestedOneWithoutStakePoolStakersInput = {
  connect?: InputMaybe<StakePoolsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolsCreateOrConnectWithoutStakePoolStakersInput>;
  create?: InputMaybe<StakePoolsCreateWithoutStakePoolStakersInput>;
};

export type StakePoolsCreateNestedOneWithoutStakePoolWithdrawalsInput = {
  connect?: InputMaybe<StakePoolsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolsCreateOrConnectWithoutStakePoolWithdrawalsInput>;
  create?: InputMaybe<StakePoolsCreateWithoutStakePoolWithdrawalsInput>;
};

export type StakePoolsCreateNestedOneWithoutWorkerActivitiesInput = {
  connect?: InputMaybe<StakePoolsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolsCreateOrConnectWithoutWorkerActivitiesInput>;
  create?: InputMaybe<StakePoolsCreateWithoutWorkerActivitiesInput>;
};

export type StakePoolsCreateNestedOneWithoutWorkersInput = {
  connect?: InputMaybe<StakePoolsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolsCreateOrConnectWithoutWorkersInput>;
  create?: InputMaybe<StakePoolsCreateWithoutWorkersInput>;
};

export type StakePoolsCreateOrConnectWithoutAccountsInput = {
  create: StakePoolsCreateWithoutAccountsInput;
  where: StakePoolsWhereUniqueInput;
};

export type StakePoolsCreateOrConnectWithoutMinersInput = {
  create: StakePoolsCreateWithoutMinersInput;
  where: StakePoolsWhereUniqueInput;
};

export type StakePoolsCreateOrConnectWithoutStakePoolActivitiesInput = {
  create: StakePoolsCreateWithoutStakePoolActivitiesInput;
  where: StakePoolsWhereUniqueInput;
};

export type StakePoolsCreateOrConnectWithoutStakePoolStakersInput = {
  create: StakePoolsCreateWithoutStakePoolStakersInput;
  where: StakePoolsWhereUniqueInput;
};

export type StakePoolsCreateOrConnectWithoutStakePoolWithdrawalsInput = {
  create: StakePoolsCreateWithoutStakePoolWithdrawalsInput;
  where: StakePoolsWhereUniqueInput;
};

export type StakePoolsCreateOrConnectWithoutWorkerActivitiesInput = {
  create: StakePoolsCreateWithoutWorkerActivitiesInput;
  where: StakePoolsWhereUniqueInput;
};

export type StakePoolsCreateOrConnectWithoutWorkersInput = {
  create: StakePoolsCreateWithoutWorkersInput;
  where: StakePoolsWhereUniqueInput;
};

export type StakePoolsCreateWithoutAccountsInput = {
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: InputMaybe<Scalars['BigInt']>;
  lastUpdatedTimestamp: Scalars['DateTime'];
  miners?: InputMaybe<MinersCreateNestedManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerAddress: Scalars['String'];
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  pid: Scalars['Int'];
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutStakePoolsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersCreateNestedManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<Scalars['Int']>;
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutStakePoolsInput>;
  workers?: InputMaybe<WorkersCreateNestedManyWithoutStakePoolsInput>;
};

export type StakePoolsCreateWithoutMinersInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolsInput;
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: InputMaybe<Scalars['BigInt']>;
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerAddress: Scalars['String'];
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  pid: Scalars['Int'];
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutStakePoolsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersCreateNestedManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<Scalars['Int']>;
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutStakePoolsInput>;
  workers?: InputMaybe<WorkersCreateNestedManyWithoutStakePoolsInput>;
};

export type StakePoolsCreateWithoutStakePoolActivitiesInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolsInput;
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: InputMaybe<Scalars['BigInt']>;
  lastUpdatedTimestamp: Scalars['DateTime'];
  miners?: InputMaybe<MinersCreateNestedManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerAddress: Scalars['String'];
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  pid: Scalars['Int'];
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakePoolStakers?: InputMaybe<StakePoolStakersCreateNestedManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<Scalars['Int']>;
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutStakePoolsInput>;
  workers?: InputMaybe<WorkersCreateNestedManyWithoutStakePoolsInput>;
};

export type StakePoolsCreateWithoutStakePoolStakersInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolsInput;
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: InputMaybe<Scalars['BigInt']>;
  lastUpdatedTimestamp: Scalars['DateTime'];
  miners?: InputMaybe<MinersCreateNestedManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerAddress: Scalars['String'];
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  pid: Scalars['Int'];
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<Scalars['Int']>;
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutStakePoolsInput>;
  workers?: InputMaybe<WorkersCreateNestedManyWithoutStakePoolsInput>;
};

export type StakePoolsCreateWithoutStakePoolWithdrawalsInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolsInput;
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: InputMaybe<Scalars['BigInt']>;
  lastUpdatedTimestamp: Scalars['DateTime'];
  miners?: InputMaybe<MinersCreateNestedManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerAddress: Scalars['String'];
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  pid: Scalars['Int'];
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutStakePoolsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersCreateNestedManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<Scalars['Int']>;
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutStakePoolsInput>;
  workers?: InputMaybe<WorkersCreateNestedManyWithoutStakePoolsInput>;
};

export type StakePoolsCreateWithoutWorkerActivitiesInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolsInput;
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: InputMaybe<Scalars['BigInt']>;
  lastUpdatedTimestamp: Scalars['DateTime'];
  miners?: InputMaybe<MinersCreateNestedManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerAddress: Scalars['String'];
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  pid: Scalars['Int'];
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutStakePoolsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersCreateNestedManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<Scalars['Int']>;
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
  workers?: InputMaybe<WorkersCreateNestedManyWithoutStakePoolsInput>;
};

export type StakePoolsCreateWithoutWorkersInput = {
  accounts: AccountsCreateNestedOneWithoutStakePoolsInput;
  cap?: InputMaybe<Scalars['Decimal']>;
  commission?: InputMaybe<Scalars['Decimal']>;
  coolingDownMinersCount?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  freeStake?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  idleMinersCount?: InputMaybe<Scalars['Int']>;
  instantApr?: InputMaybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: InputMaybe<Scalars['BigInt']>;
  lastUpdatedTimestamp: Scalars['DateTime'];
  miners?: InputMaybe<MinersCreateNestedManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<Scalars['Int']>;
  ownerAddress: Scalars['String'];
  ownerReward?: InputMaybe<Scalars['Decimal']>;
  pid: Scalars['Int'];
  readyMinersCount?: InputMaybe<Scalars['Int']>;
  releasingStake?: InputMaybe<Scalars['Decimal']>;
  remainingStake?: InputMaybe<Scalars['Decimal']>;
  rewardAcc?: InputMaybe<Scalars['Decimal']>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesCreateNestedManyWithoutStakePoolsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersCreateNestedManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsCreateNestedManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<Scalars['Int']>;
  totalShares?: InputMaybe<Scalars['Decimal']>;
  totalStake?: InputMaybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  usedStake?: InputMaybe<Scalars['Decimal']>;
  withdrawalsCount?: InputMaybe<Scalars['Int']>;
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutStakePoolsInput>;
};

export type StakePoolsGroupBy = {
  __typename?: 'StakePoolsGroupBy';
  _avg?: Maybe<StakePoolsAvgAggregate>;
  _count?: Maybe<StakePoolsCountAggregate>;
  _max?: Maybe<StakePoolsMaxAggregate>;
  _min?: Maybe<StakePoolsMinAggregate>;
  _sum?: Maybe<StakePoolsSumAggregate>;
  cap?: Maybe<Scalars['Decimal']>;
  commission: Scalars['Decimal'];
  coolingDownMinersCount: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  freeStake: Scalars['Decimal'];
  id: Scalars['BigInt'];
  idleMinersCount: Scalars['Int'];
  instantApr: Scalars['Decimal'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersCount: Scalars['Int'];
  ownerAddress: Scalars['String'];
  ownerId: Scalars['BigInt'];
  ownerReward: Scalars['Decimal'];
  pid: Scalars['Int'];
  readyMinersCount: Scalars['Int'];
  releasingStake: Scalars['Decimal'];
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc: Scalars['Decimal'];
  stakersCount: Scalars['Int'];
  totalShares: Scalars['Decimal'];
  totalStake: Scalars['Decimal'];
  unresponsiveMinersCount: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
  usedStake: Scalars['Decimal'];
  withdrawalsCount: Scalars['Int'];
};

export type StakePoolsListRelationFilter = {
  every?: InputMaybe<StakePoolsWhereInput>;
  none?: InputMaybe<StakePoolsWhereInput>;
  some?: InputMaybe<StakePoolsWhereInput>;
};

export type StakePoolsMaxAggregate = {
  __typename?: 'StakePoolsMaxAggregate';
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  idleMinersCount?: Maybe<Scalars['Int']>;
  instantApr?: Maybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  minersCount?: Maybe<Scalars['Int']>;
  ownerAddress?: Maybe<Scalars['String']>;
  ownerId?: Maybe<Scalars['BigInt']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  pid?: Maybe<Scalars['Int']>;
  readyMinersCount?: Maybe<Scalars['Int']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakersCount?: Maybe<Scalars['Int']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Int']>;
};

export type StakePoolsMaxOrderByAggregateInput = {
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerAddress?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolsMinAggregate = {
  __typename?: 'StakePoolsMinAggregate';
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  idleMinersCount?: Maybe<Scalars['Int']>;
  instantApr?: Maybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  minersCount?: Maybe<Scalars['Int']>;
  ownerAddress?: Maybe<Scalars['String']>;
  ownerId?: Maybe<Scalars['BigInt']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  pid?: Maybe<Scalars['Int']>;
  readyMinersCount?: Maybe<Scalars['Int']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakersCount?: Maybe<Scalars['Int']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Int']>;
};

export type StakePoolsMinOrderByAggregateInput = {
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerAddress?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolsOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StakePoolsOrderByWithAggregationInput = {
  _avg?: InputMaybe<StakePoolsAvgOrderByAggregateInput>;
  _count?: InputMaybe<StakePoolsCountOrderByAggregateInput>;
  _max?: InputMaybe<StakePoolsMaxOrderByAggregateInput>;
  _min?: InputMaybe<StakePoolsMinOrderByAggregateInput>;
  _sum?: InputMaybe<StakePoolsSumOrderByAggregateInput>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerAddress?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolsOrderByWithRelationInput = {
  accounts?: InputMaybe<AccountsOrderByWithRelationInput>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  miners?: InputMaybe<MinersOrderByRelationAggregateInput>;
  minersCount?: InputMaybe<SortOrder>;
  ownerAddress?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesOrderByRelationAggregateInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersOrderByRelationAggregateInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsOrderByRelationAggregateInput>;
  stakersCount?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
  workerActivities?: InputMaybe<WorkerActivitiesOrderByRelationAggregateInput>;
  workers?: InputMaybe<WorkersOrderByRelationAggregateInput>;
};

export type StakePoolsRelationFilter = {
  is?: InputMaybe<StakePoolsWhereInput>;
  isNot?: InputMaybe<StakePoolsWhereInput>;
};

export enum StakePoolsScalarFieldEnum {
  Cap = 'cap',
  Commission = 'commission',
  CoolingDownMinersCount = 'coolingDownMinersCount',
  CreatedAt = 'createdAt',
  FreeStake = 'freeStake',
  Id = 'id',
  IdleMinersCount = 'idleMinersCount',
  InstantApr = 'instantApr',
  LastUpdatedBlockNumber = 'lastUpdatedBlockNumber',
  LastUpdatedTimestamp = 'lastUpdatedTimestamp',
  MinersCount = 'minersCount',
  OwnerAddress = 'ownerAddress',
  OwnerId = 'ownerId',
  OwnerReward = 'ownerReward',
  Pid = 'pid',
  ReadyMinersCount = 'readyMinersCount',
  ReleasingStake = 'releasingStake',
  RemainingStake = 'remainingStake',
  RewardAcc = 'rewardAcc',
  StakersCount = 'stakersCount',
  TotalShares = 'totalShares',
  TotalStake = 'totalStake',
  UnresponsiveMinersCount = 'unresponsiveMinersCount',
  UpdatedAt = 'updatedAt',
  UsedStake = 'usedStake',
  WithdrawalsCount = 'withdrawalsCount'
}

export type StakePoolsScalarWhereInput = {
  AND?: InputMaybe<Array<StakePoolsScalarWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolsScalarWhereInput>>;
  OR?: InputMaybe<Array<StakePoolsScalarWhereInput>>;
  cap?: InputMaybe<DecimalNullableFilter>;
  commission?: InputMaybe<DecimalFilter>;
  coolingDownMinersCount?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  freeStake?: InputMaybe<DecimalFilter>;
  id?: InputMaybe<BigIntFilter>;
  idleMinersCount?: InputMaybe<IntFilter>;
  instantApr?: InputMaybe<DecimalFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  minersCount?: InputMaybe<IntFilter>;
  ownerAddress?: InputMaybe<StringFilter>;
  ownerId?: InputMaybe<BigIntFilter>;
  ownerReward?: InputMaybe<DecimalFilter>;
  pid?: InputMaybe<IntFilter>;
  readyMinersCount?: InputMaybe<IntFilter>;
  releasingStake?: InputMaybe<DecimalFilter>;
  remainingStake?: InputMaybe<DecimalNullableFilter>;
  rewardAcc?: InputMaybe<DecimalFilter>;
  stakersCount?: InputMaybe<IntFilter>;
  totalShares?: InputMaybe<DecimalFilter>;
  totalStake?: InputMaybe<DecimalFilter>;
  unresponsiveMinersCount?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  usedStake?: InputMaybe<DecimalFilter>;
  withdrawalsCount?: InputMaybe<IntFilter>;
};

export type StakePoolsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StakePoolsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StakePoolsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StakePoolsScalarWhereWithAggregatesInput>>;
  cap?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  commission?: InputMaybe<DecimalWithAggregatesFilter>;
  coolingDownMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  freeStake?: InputMaybe<DecimalWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  idleMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  instantApr?: InputMaybe<DecimalWithAggregatesFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  minersCount?: InputMaybe<IntWithAggregatesFilter>;
  ownerAddress?: InputMaybe<StringWithAggregatesFilter>;
  ownerId?: InputMaybe<BigIntWithAggregatesFilter>;
  ownerReward?: InputMaybe<DecimalWithAggregatesFilter>;
  pid?: InputMaybe<IntWithAggregatesFilter>;
  readyMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  releasingStake?: InputMaybe<DecimalWithAggregatesFilter>;
  remainingStake?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  rewardAcc?: InputMaybe<DecimalWithAggregatesFilter>;
  stakersCount?: InputMaybe<IntWithAggregatesFilter>;
  totalShares?: InputMaybe<DecimalWithAggregatesFilter>;
  totalStake?: InputMaybe<DecimalWithAggregatesFilter>;
  unresponsiveMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  usedStake?: InputMaybe<DecimalWithAggregatesFilter>;
  withdrawalsCount?: InputMaybe<IntWithAggregatesFilter>;
};

export type StakePoolsSumAggregate = {
  __typename?: 'StakePoolsSumAggregate';
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Int']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  idleMinersCount?: Maybe<Scalars['Int']>;
  instantApr?: Maybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  minersCount?: Maybe<Scalars['Int']>;
  ownerId?: Maybe<Scalars['BigInt']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  pid?: Maybe<Scalars['Int']>;
  readyMinersCount?: Maybe<Scalars['Int']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakersCount?: Maybe<Scalars['Int']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: Maybe<Scalars['Int']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Int']>;
};

export type StakePoolsSumOrderByAggregateInput = {
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  instantApr?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolsUpdateInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolsInput>;
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutStakePoolsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutStakePoolsInput>;
  workers?: InputMaybe<WorkersUpdateManyWithoutStakePoolsInput>;
};

export type StakePoolsUpdateManyMutationInput = {
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StakePoolsUpdateManyWithWhereWithoutAccountsInput = {
  data: StakePoolsUpdateManyMutationInput;
  where: StakePoolsScalarWhereInput;
};

export type StakePoolsUpdateManyWithoutAccountsInput = {
  connect?: InputMaybe<Array<StakePoolsWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StakePoolsCreateOrConnectWithoutAccountsInput>>;
  create?: InputMaybe<Array<StakePoolsCreateWithoutAccountsInput>>;
  createMany?: InputMaybe<StakePoolsCreateManyAccountsInputEnvelope>;
  delete?: InputMaybe<Array<StakePoolsWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StakePoolsScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StakePoolsWhereUniqueInput>>;
  set?: InputMaybe<Array<StakePoolsWhereUniqueInput>>;
  update?: InputMaybe<Array<StakePoolsUpdateWithWhereUniqueWithoutAccountsInput>>;
  updateMany?: InputMaybe<Array<StakePoolsUpdateManyWithWhereWithoutAccountsInput>>;
  upsert?: InputMaybe<Array<StakePoolsUpsertWithWhereUniqueWithoutAccountsInput>>;
};

export type StakePoolsUpdateOneRequiredWithoutMinersInput = {
  connect?: InputMaybe<StakePoolsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolsCreateOrConnectWithoutMinersInput>;
  create?: InputMaybe<StakePoolsCreateWithoutMinersInput>;
  update?: InputMaybe<StakePoolsUpdateWithoutMinersInput>;
  upsert?: InputMaybe<StakePoolsUpsertWithoutMinersInput>;
};

export type StakePoolsUpdateOneRequiredWithoutStakePoolActivitiesInput = {
  connect?: InputMaybe<StakePoolsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolsCreateOrConnectWithoutStakePoolActivitiesInput>;
  create?: InputMaybe<StakePoolsCreateWithoutStakePoolActivitiesInput>;
  update?: InputMaybe<StakePoolsUpdateWithoutStakePoolActivitiesInput>;
  upsert?: InputMaybe<StakePoolsUpsertWithoutStakePoolActivitiesInput>;
};

export type StakePoolsUpdateOneRequiredWithoutStakePoolStakersInput = {
  connect?: InputMaybe<StakePoolsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolsCreateOrConnectWithoutStakePoolStakersInput>;
  create?: InputMaybe<StakePoolsCreateWithoutStakePoolStakersInput>;
  update?: InputMaybe<StakePoolsUpdateWithoutStakePoolStakersInput>;
  upsert?: InputMaybe<StakePoolsUpsertWithoutStakePoolStakersInput>;
};

export type StakePoolsUpdateOneRequiredWithoutStakePoolWithdrawalsInput = {
  connect?: InputMaybe<StakePoolsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolsCreateOrConnectWithoutStakePoolWithdrawalsInput>;
  create?: InputMaybe<StakePoolsCreateWithoutStakePoolWithdrawalsInput>;
  update?: InputMaybe<StakePoolsUpdateWithoutStakePoolWithdrawalsInput>;
  upsert?: InputMaybe<StakePoolsUpsertWithoutStakePoolWithdrawalsInput>;
};

export type StakePoolsUpdateOneWithoutWorkerActivitiesInput = {
  connect?: InputMaybe<StakePoolsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolsCreateOrConnectWithoutWorkerActivitiesInput>;
  create?: InputMaybe<StakePoolsCreateWithoutWorkerActivitiesInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<StakePoolsUpdateWithoutWorkerActivitiesInput>;
  upsert?: InputMaybe<StakePoolsUpsertWithoutWorkerActivitiesInput>;
};

export type StakePoolsUpdateOneWithoutWorkersInput = {
  connect?: InputMaybe<StakePoolsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StakePoolsCreateOrConnectWithoutWorkersInput>;
  create?: InputMaybe<StakePoolsCreateWithoutWorkersInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<StakePoolsUpdateWithoutWorkersInput>;
  upsert?: InputMaybe<StakePoolsUpsertWithoutWorkersInput>;
};

export type StakePoolsUpdateWithWhereUniqueWithoutAccountsInput = {
  data: StakePoolsUpdateWithoutAccountsInput;
  where: StakePoolsWhereUniqueInput;
};

export type StakePoolsUpdateWithoutAccountsInput = {
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutStakePoolsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutStakePoolsInput>;
  workers?: InputMaybe<WorkersUpdateManyWithoutStakePoolsInput>;
};

export type StakePoolsUpdateWithoutMinersInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolsInput>;
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutStakePoolsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutStakePoolsInput>;
  workers?: InputMaybe<WorkersUpdateManyWithoutStakePoolsInput>;
};

export type StakePoolsUpdateWithoutStakePoolActivitiesInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolsInput>;
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutStakePoolsInput>;
  workers?: InputMaybe<WorkersUpdateManyWithoutStakePoolsInput>;
};

export type StakePoolsUpdateWithoutStakePoolStakersInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolsInput>;
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutStakePoolsInput>;
  workers?: InputMaybe<WorkersUpdateManyWithoutStakePoolsInput>;
};

export type StakePoolsUpdateWithoutStakePoolWithdrawalsInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolsInput>;
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutStakePoolsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutStakePoolsInput>;
  workers?: InputMaybe<WorkersUpdateManyWithoutStakePoolsInput>;
};

export type StakePoolsUpdateWithoutWorkerActivitiesInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolsInput>;
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutStakePoolsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  workers?: InputMaybe<WorkersUpdateManyWithoutStakePoolsInput>;
};

export type StakePoolsUpdateWithoutWorkersInput = {
  accounts?: InputMaybe<AccountsUpdateOneRequiredWithoutStakePoolsInput>;
  cap?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  commission?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  coolingDownMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  freeStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  idleMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  instantApr?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateManyWithoutStakePoolsInput>;
  minersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  ownerAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  ownerReward?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  pid?: InputMaybe<IntFieldUpdateOperationsInput>;
  readyMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  releasingStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  remainingStake?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  rewardAcc?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesUpdateManyWithoutStakePoolsInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersUpdateManyWithoutStakePoolsInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsUpdateManyWithoutStakePoolsInput>;
  stakersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalShares?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  totalStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  unresponsiveMinersCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  usedStake?: InputMaybe<DecimalFieldUpdateOperationsInput>;
  withdrawalsCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutStakePoolsInput>;
};

export type StakePoolsUpsertWithWhereUniqueWithoutAccountsInput = {
  create: StakePoolsCreateWithoutAccountsInput;
  update: StakePoolsUpdateWithoutAccountsInput;
  where: StakePoolsWhereUniqueInput;
};

export type StakePoolsUpsertWithoutMinersInput = {
  create: StakePoolsCreateWithoutMinersInput;
  update: StakePoolsUpdateWithoutMinersInput;
};

export type StakePoolsUpsertWithoutStakePoolActivitiesInput = {
  create: StakePoolsCreateWithoutStakePoolActivitiesInput;
  update: StakePoolsUpdateWithoutStakePoolActivitiesInput;
};

export type StakePoolsUpsertWithoutStakePoolStakersInput = {
  create: StakePoolsCreateWithoutStakePoolStakersInput;
  update: StakePoolsUpdateWithoutStakePoolStakersInput;
};

export type StakePoolsUpsertWithoutStakePoolWithdrawalsInput = {
  create: StakePoolsCreateWithoutStakePoolWithdrawalsInput;
  update: StakePoolsUpdateWithoutStakePoolWithdrawalsInput;
};

export type StakePoolsUpsertWithoutWorkerActivitiesInput = {
  create: StakePoolsCreateWithoutWorkerActivitiesInput;
  update: StakePoolsUpdateWithoutWorkerActivitiesInput;
};

export type StakePoolsUpsertWithoutWorkersInput = {
  create: StakePoolsCreateWithoutWorkersInput;
  update: StakePoolsUpdateWithoutWorkersInput;
};

export type StakePoolsWhereInput = {
  AND?: InputMaybe<Array<StakePoolsWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolsWhereInput>>;
  OR?: InputMaybe<Array<StakePoolsWhereInput>>;
  accounts?: InputMaybe<AccountsRelationFilter>;
  cap?: InputMaybe<DecimalNullableFilter>;
  commission?: InputMaybe<DecimalFilter>;
  coolingDownMinersCount?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  freeStake?: InputMaybe<DecimalFilter>;
  id?: InputMaybe<BigIntFilter>;
  idleMinersCount?: InputMaybe<IntFilter>;
  instantApr?: InputMaybe<DecimalFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  miners?: InputMaybe<MinersListRelationFilter>;
  minersCount?: InputMaybe<IntFilter>;
  ownerAddress?: InputMaybe<StringFilter>;
  ownerId?: InputMaybe<BigIntFilter>;
  ownerReward?: InputMaybe<DecimalFilter>;
  pid?: InputMaybe<IntFilter>;
  readyMinersCount?: InputMaybe<IntFilter>;
  releasingStake?: InputMaybe<DecimalFilter>;
  remainingStake?: InputMaybe<DecimalNullableFilter>;
  rewardAcc?: InputMaybe<DecimalFilter>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesListRelationFilter>;
  stakePoolStakers?: InputMaybe<StakePoolStakersListRelationFilter>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsListRelationFilter>;
  stakersCount?: InputMaybe<IntFilter>;
  totalShares?: InputMaybe<DecimalFilter>;
  totalStake?: InputMaybe<DecimalFilter>;
  unresponsiveMinersCount?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  usedStake?: InputMaybe<DecimalFilter>;
  withdrawalsCount?: InputMaybe<IntFilter>;
  workerActivities?: InputMaybe<WorkerActivitiesListRelationFilter>;
  workers?: InputMaybe<WorkersListRelationFilter>;
};

export type StakePoolsWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  pid?: InputMaybe<Scalars['Int']>;
};

export type States = {
  __typename?: 'States';
  createdAt: Scalars['DateTime'];
  datetimeValue?: Maybe<Scalars['DateTime']>;
  decimalValue?: Maybe<Scalars['Decimal']>;
  id: Scalars['BigInt'];
  integerValue?: Maybe<Scalars['Int']>;
  key?: Maybe<Scalars['String']>;
  stringValue?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  visible?: Maybe<Scalars['Boolean']>;
};

export type StatesAvgAggregate = {
  __typename?: 'StatesAvgAggregate';
  decimalValue?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['Float']>;
  integerValue?: Maybe<Scalars['Float']>;
};

export type StatesAvgOrderByAggregateInput = {
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
};

export type StatesCountAggregate = {
  __typename?: 'StatesCountAggregate';
  _all: Scalars['Int'];
  createdAt: Scalars['Int'];
  datetimeValue: Scalars['Int'];
  decimalValue: Scalars['Int'];
  id: Scalars['Int'];
  integerValue: Scalars['Int'];
  key: Scalars['Int'];
  stringValue: Scalars['Int'];
  updatedAt: Scalars['Int'];
  visible: Scalars['Int'];
};

export type StatesCountOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  datetimeValue?: InputMaybe<SortOrder>;
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  stringValue?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  visible?: InputMaybe<SortOrder>;
};

export type StatesCreateInput = {
  createdAt: Scalars['DateTime'];
  datetimeValue?: InputMaybe<Scalars['DateTime']>;
  decimalValue?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  integerValue?: InputMaybe<Scalars['Int']>;
  key?: InputMaybe<Scalars['String']>;
  stringValue?: InputMaybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  visible?: InputMaybe<Scalars['Boolean']>;
};

export type StatesCreateManyInput = {
  createdAt: Scalars['DateTime'];
  datetimeValue?: InputMaybe<Scalars['DateTime']>;
  decimalValue?: InputMaybe<Scalars['Decimal']>;
  id?: InputMaybe<Scalars['BigInt']>;
  integerValue?: InputMaybe<Scalars['Int']>;
  key?: InputMaybe<Scalars['String']>;
  stringValue?: InputMaybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  visible?: InputMaybe<Scalars['Boolean']>;
};

export type StatesGroupBy = {
  __typename?: 'StatesGroupBy';
  _avg?: Maybe<StatesAvgAggregate>;
  _count?: Maybe<StatesCountAggregate>;
  _max?: Maybe<StatesMaxAggregate>;
  _min?: Maybe<StatesMinAggregate>;
  _sum?: Maybe<StatesSumAggregate>;
  createdAt: Scalars['DateTime'];
  datetimeValue?: Maybe<Scalars['DateTime']>;
  decimalValue?: Maybe<Scalars['Decimal']>;
  id: Scalars['BigInt'];
  integerValue?: Maybe<Scalars['Int']>;
  key?: Maybe<Scalars['String']>;
  stringValue?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  visible?: Maybe<Scalars['Boolean']>;
};

export type StatesMaxAggregate = {
  __typename?: 'StatesMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']>;
  datetimeValue?: Maybe<Scalars['DateTime']>;
  decimalValue?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  integerValue?: Maybe<Scalars['Int']>;
  key?: Maybe<Scalars['String']>;
  stringValue?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  visible?: Maybe<Scalars['Boolean']>;
};

export type StatesMaxOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  datetimeValue?: InputMaybe<SortOrder>;
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  stringValue?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  visible?: InputMaybe<SortOrder>;
};

export type StatesMinAggregate = {
  __typename?: 'StatesMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']>;
  datetimeValue?: Maybe<Scalars['DateTime']>;
  decimalValue?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  integerValue?: Maybe<Scalars['Int']>;
  key?: Maybe<Scalars['String']>;
  stringValue?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  visible?: Maybe<Scalars['Boolean']>;
};

export type StatesMinOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  datetimeValue?: InputMaybe<SortOrder>;
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  stringValue?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  visible?: InputMaybe<SortOrder>;
};

export type StatesOrderByWithAggregationInput = {
  _avg?: InputMaybe<StatesAvgOrderByAggregateInput>;
  _count?: InputMaybe<StatesCountOrderByAggregateInput>;
  _max?: InputMaybe<StatesMaxOrderByAggregateInput>;
  _min?: InputMaybe<StatesMinOrderByAggregateInput>;
  _sum?: InputMaybe<StatesSumOrderByAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  datetimeValue?: InputMaybe<SortOrder>;
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  stringValue?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  visible?: InputMaybe<SortOrder>;
};

export type StatesOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  datetimeValue?: InputMaybe<SortOrder>;
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  stringValue?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  visible?: InputMaybe<SortOrder>;
};

export enum StatesScalarFieldEnum {
  CreatedAt = 'createdAt',
  DatetimeValue = 'datetimeValue',
  DecimalValue = 'decimalValue',
  Id = 'id',
  IntegerValue = 'integerValue',
  Key = 'key',
  StringValue = 'stringValue',
  UpdatedAt = 'updatedAt',
  Visible = 'visible'
}

export type StatesScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StatesScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StatesScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StatesScalarWhereWithAggregatesInput>>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  datetimeValue?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  decimalValue?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  integerValue?: InputMaybe<IntNullableWithAggregatesFilter>;
  key?: InputMaybe<StringNullableWithAggregatesFilter>;
  stringValue?: InputMaybe<StringNullableWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  visible?: InputMaybe<BoolNullableWithAggregatesFilter>;
};

export type StatesSumAggregate = {
  __typename?: 'StatesSumAggregate';
  decimalValue?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  integerValue?: Maybe<Scalars['Int']>;
};

export type StatesSumOrderByAggregateInput = {
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
};

export type StatesUpdateInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  datetimeValue?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  decimalValue?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  integerValue?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  key?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  stringValue?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  visible?: InputMaybe<NullableBoolFieldUpdateOperationsInput>;
};

export type StatesUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  datetimeValue?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  decimalValue?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  integerValue?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  key?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  stringValue?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  visible?: InputMaybe<NullableBoolFieldUpdateOperationsInput>;
};

export type StatesWhereInput = {
  AND?: InputMaybe<Array<StatesWhereInput>>;
  NOT?: InputMaybe<Array<StatesWhereInput>>;
  OR?: InputMaybe<Array<StatesWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  datetimeValue?: InputMaybe<DateTimeNullableFilter>;
  decimalValue?: InputMaybe<DecimalNullableFilter>;
  id?: InputMaybe<BigIntFilter>;
  integerValue?: InputMaybe<IntNullableFilter>;
  key?: InputMaybe<StringNullableFilter>;
  stringValue?: InputMaybe<StringNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  visible?: InputMaybe<BoolNullableFilter>;
};

export type StatesWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type StringFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['String']>;
};

export type StringFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type StringNullableFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type StringNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedStringNullableFilter>;
  _min?: InputMaybe<NestedStringNullableFilter>;
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type StringWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedStringFilter>;
  _min?: InputMaybe<NestedStringFilter>;
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type WorkerActivities = {
  __typename?: 'WorkerActivities';
  accounts?: Maybe<Accounts>;
  blockNumber: Scalars['BigInt'];
  confidenceLevel: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['BigInt']>;
  events?: Maybe<Events>;
  features: Array<Scalars['Int']>;
  id: Scalars['BigInt'];
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore: Scalars['Int'];
  miners?: Maybe<Miners>;
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  runtimeVersion: Scalars['Int'];
  stakePools?: Maybe<StakePools>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workerId: Scalars['BigInt'];
  workers: Workers;
};

export type WorkerActivitiesAvgAggregate = {
  __typename?: 'WorkerActivitiesAvgAggregate';
  blockNumber?: Maybe<Scalars['Float']>;
  confidenceLevel?: Maybe<Scalars['Float']>;
  currentMinerId?: Maybe<Scalars['Float']>;
  currentPid?: Maybe<Scalars['Float']>;
  currentStakePoolId?: Maybe<Scalars['Float']>;
  eventId?: Maybe<Scalars['Float']>;
  features?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  initialScore?: Maybe<Scalars['Float']>;
  operatorId?: Maybe<Scalars['Float']>;
  runtimeVersion?: Maybe<Scalars['Float']>;
  tokenomicVersion?: Maybe<Scalars['Float']>;
  workerId?: Maybe<Scalars['Float']>;
};

export type WorkerActivitiesAvgOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesCountAggregate = {
  __typename?: 'WorkerActivitiesCountAggregate';
  _all: Scalars['Int'];
  blockNumber: Scalars['Int'];
  confidenceLevel: Scalars['Int'];
  createdAt: Scalars['Int'];
  currentMinerAccountAddress: Scalars['Int'];
  currentMinerId: Scalars['Int'];
  currentPid: Scalars['Int'];
  currentStakePoolId: Scalars['Int'];
  ecdhPublicKey: Scalars['Int'];
  eventId: Scalars['Int'];
  features: Scalars['Int'];
  id: Scalars['Int'];
  infoLastUpdatedAt: Scalars['Int'];
  initialScore: Scalars['Int'];
  operatorAddress: Scalars['Int'];
  operatorId: Scalars['Int'];
  runtimeVersion: Scalars['Int'];
  timestamp: Scalars['Int'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['Int'];
  updatedAt: Scalars['Int'];
  workerId: Scalars['Int'];
};

export type WorkerActivitiesCountOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesCreateInput = {
  accounts?: InputMaybe<AccountsCreateNestedOneWithoutWorkerActivitiesInput>;
  blockNumber: Scalars['BigInt'];
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  events?: InputMaybe<EventsCreateNestedOneWithoutWorkerActivitiesInput>;
  features?: InputMaybe<WorkerActivitiesCreatefeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  miners?: InputMaybe<MinersCreateNestedOneWithoutWorkerActivitiesInput>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  stakePools?: InputMaybe<StakePoolsCreateNestedOneWithoutWorkerActivitiesInput>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workers: WorkersCreateNestedOneWithoutWorkerActivitiesInput;
};

export type WorkerActivitiesCreateManyAccountsInput = {
  blockNumber: Scalars['BigInt'];
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentMinerId?: InputMaybe<Scalars['BigInt']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  currentStakePoolId?: InputMaybe<Scalars['BigInt']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  eventId?: InputMaybe<Scalars['BigInt']>;
  features?: InputMaybe<WorkerActivitiesCreateManyfeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workerId: Scalars['BigInt'];
};

export type WorkerActivitiesCreateManyAccountsInputEnvelope = {
  data: Array<WorkerActivitiesCreateManyAccountsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type WorkerActivitiesCreateManyEventsInput = {
  blockNumber: Scalars['BigInt'];
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentMinerId?: InputMaybe<Scalars['BigInt']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  currentStakePoolId?: InputMaybe<Scalars['BigInt']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  features?: InputMaybe<WorkerActivitiesCreateManyfeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  operatorId?: InputMaybe<Scalars['BigInt']>;
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workerId: Scalars['BigInt'];
};

export type WorkerActivitiesCreateManyEventsInputEnvelope = {
  data: Array<WorkerActivitiesCreateManyEventsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type WorkerActivitiesCreateManyInput = {
  blockNumber: Scalars['BigInt'];
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentMinerId?: InputMaybe<Scalars['BigInt']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  currentStakePoolId?: InputMaybe<Scalars['BigInt']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  eventId?: InputMaybe<Scalars['BigInt']>;
  features?: InputMaybe<WorkerActivitiesCreateManyfeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  operatorId?: InputMaybe<Scalars['BigInt']>;
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workerId: Scalars['BigInt'];
};

export type WorkerActivitiesCreateManyMinersInput = {
  blockNumber: Scalars['BigInt'];
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  currentStakePoolId?: InputMaybe<Scalars['BigInt']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  eventId?: InputMaybe<Scalars['BigInt']>;
  features?: InputMaybe<WorkerActivitiesCreateManyfeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  operatorId?: InputMaybe<Scalars['BigInt']>;
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workerId: Scalars['BigInt'];
};

export type WorkerActivitiesCreateManyMinersInputEnvelope = {
  data: Array<WorkerActivitiesCreateManyMinersInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type WorkerActivitiesCreateManyStakePoolsInput = {
  blockNumber: Scalars['BigInt'];
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentMinerId?: InputMaybe<Scalars['BigInt']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  eventId?: InputMaybe<Scalars['BigInt']>;
  features?: InputMaybe<WorkerActivitiesCreateManyfeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  operatorId?: InputMaybe<Scalars['BigInt']>;
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workerId: Scalars['BigInt'];
};

export type WorkerActivitiesCreateManyStakePoolsInputEnvelope = {
  data: Array<WorkerActivitiesCreateManyStakePoolsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type WorkerActivitiesCreateManyWorkersInput = {
  blockNumber: Scalars['BigInt'];
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentMinerId?: InputMaybe<Scalars['BigInt']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  currentStakePoolId?: InputMaybe<Scalars['BigInt']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  eventId?: InputMaybe<Scalars['BigInt']>;
  features?: InputMaybe<WorkerActivitiesCreateManyfeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  operatorId?: InputMaybe<Scalars['BigInt']>;
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type WorkerActivitiesCreateManyWorkersInputEnvelope = {
  data: Array<WorkerActivitiesCreateManyWorkersInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type WorkerActivitiesCreateManyfeaturesInput = {
  set: Array<Scalars['Int']>;
};

export type WorkerActivitiesCreateNestedManyWithoutAccountsInput = {
  connect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkerActivitiesCreateOrConnectWithoutAccountsInput>>;
  create?: InputMaybe<Array<WorkerActivitiesCreateWithoutAccountsInput>>;
  createMany?: InputMaybe<WorkerActivitiesCreateManyAccountsInputEnvelope>;
};

export type WorkerActivitiesCreateNestedManyWithoutEventsInput = {
  connect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkerActivitiesCreateOrConnectWithoutEventsInput>>;
  create?: InputMaybe<Array<WorkerActivitiesCreateWithoutEventsInput>>;
  createMany?: InputMaybe<WorkerActivitiesCreateManyEventsInputEnvelope>;
};

export type WorkerActivitiesCreateNestedManyWithoutMinersInput = {
  connect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkerActivitiesCreateOrConnectWithoutMinersInput>>;
  create?: InputMaybe<Array<WorkerActivitiesCreateWithoutMinersInput>>;
  createMany?: InputMaybe<WorkerActivitiesCreateManyMinersInputEnvelope>;
};

export type WorkerActivitiesCreateNestedManyWithoutStakePoolsInput = {
  connect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkerActivitiesCreateOrConnectWithoutStakePoolsInput>>;
  create?: InputMaybe<Array<WorkerActivitiesCreateWithoutStakePoolsInput>>;
  createMany?: InputMaybe<WorkerActivitiesCreateManyStakePoolsInputEnvelope>;
};

export type WorkerActivitiesCreateNestedManyWithoutWorkersInput = {
  connect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkerActivitiesCreateOrConnectWithoutWorkersInput>>;
  create?: InputMaybe<Array<WorkerActivitiesCreateWithoutWorkersInput>>;
  createMany?: InputMaybe<WorkerActivitiesCreateManyWorkersInputEnvelope>;
};

export type WorkerActivitiesCreateOrConnectWithoutAccountsInput = {
  create: WorkerActivitiesCreateWithoutAccountsInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesCreateOrConnectWithoutEventsInput = {
  create: WorkerActivitiesCreateWithoutEventsInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesCreateOrConnectWithoutMinersInput = {
  create: WorkerActivitiesCreateWithoutMinersInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesCreateOrConnectWithoutStakePoolsInput = {
  create: WorkerActivitiesCreateWithoutStakePoolsInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesCreateOrConnectWithoutWorkersInput = {
  create: WorkerActivitiesCreateWithoutWorkersInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesCreateWithoutAccountsInput = {
  blockNumber: Scalars['BigInt'];
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  events?: InputMaybe<EventsCreateNestedOneWithoutWorkerActivitiesInput>;
  features?: InputMaybe<WorkerActivitiesCreatefeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  miners?: InputMaybe<MinersCreateNestedOneWithoutWorkerActivitiesInput>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  stakePools?: InputMaybe<StakePoolsCreateNestedOneWithoutWorkerActivitiesInput>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workers: WorkersCreateNestedOneWithoutWorkerActivitiesInput;
};

export type WorkerActivitiesCreateWithoutEventsInput = {
  accounts?: InputMaybe<AccountsCreateNestedOneWithoutWorkerActivitiesInput>;
  blockNumber: Scalars['BigInt'];
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  features?: InputMaybe<WorkerActivitiesCreatefeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  miners?: InputMaybe<MinersCreateNestedOneWithoutWorkerActivitiesInput>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  stakePools?: InputMaybe<StakePoolsCreateNestedOneWithoutWorkerActivitiesInput>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workers: WorkersCreateNestedOneWithoutWorkerActivitiesInput;
};

export type WorkerActivitiesCreateWithoutMinersInput = {
  accounts?: InputMaybe<AccountsCreateNestedOneWithoutWorkerActivitiesInput>;
  blockNumber: Scalars['BigInt'];
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  events?: InputMaybe<EventsCreateNestedOneWithoutWorkerActivitiesInput>;
  features?: InputMaybe<WorkerActivitiesCreatefeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  stakePools?: InputMaybe<StakePoolsCreateNestedOneWithoutWorkerActivitiesInput>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workers: WorkersCreateNestedOneWithoutWorkerActivitiesInput;
};

export type WorkerActivitiesCreateWithoutStakePoolsInput = {
  accounts?: InputMaybe<AccountsCreateNestedOneWithoutWorkerActivitiesInput>;
  blockNumber: Scalars['BigInt'];
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  events?: InputMaybe<EventsCreateNestedOneWithoutWorkerActivitiesInput>;
  features?: InputMaybe<WorkerActivitiesCreatefeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  miners?: InputMaybe<MinersCreateNestedOneWithoutWorkerActivitiesInput>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workers: WorkersCreateNestedOneWithoutWorkerActivitiesInput;
};

export type WorkerActivitiesCreateWithoutWorkersInput = {
  accounts?: InputMaybe<AccountsCreateNestedOneWithoutWorkerActivitiesInput>;
  blockNumber: Scalars['BigInt'];
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  events?: InputMaybe<EventsCreateNestedOneWithoutWorkerActivitiesInput>;
  features?: InputMaybe<WorkerActivitiesCreatefeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  miners?: InputMaybe<MinersCreateNestedOneWithoutWorkerActivitiesInput>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  stakePools?: InputMaybe<StakePoolsCreateNestedOneWithoutWorkerActivitiesInput>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type WorkerActivitiesCreatefeaturesInput = {
  set: Array<Scalars['Int']>;
};

export type WorkerActivitiesGroupBy = {
  __typename?: 'WorkerActivitiesGroupBy';
  _avg?: Maybe<WorkerActivitiesAvgAggregate>;
  _count?: Maybe<WorkerActivitiesCountAggregate>;
  _max?: Maybe<WorkerActivitiesMaxAggregate>;
  _min?: Maybe<WorkerActivitiesMinAggregate>;
  _sum?: Maybe<WorkerActivitiesSumAggregate>;
  blockNumber: Scalars['BigInt'];
  confidenceLevel: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['BigInt']>;
  features?: Maybe<Array<Scalars['Int']>>;
  id: Scalars['BigInt'];
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore: Scalars['Int'];
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  runtimeVersion: Scalars['Int'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workerId: Scalars['BigInt'];
};

export type WorkerActivitiesListRelationFilter = {
  every?: InputMaybe<WorkerActivitiesWhereInput>;
  none?: InputMaybe<WorkerActivitiesWhereInput>;
  some?: InputMaybe<WorkerActivitiesWhereInput>;
};

export type WorkerActivitiesMaxAggregate = {
  __typename?: 'WorkerActivitiesMaxAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  confidenceLevel?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  infoLastUpdatedAt?: Maybe<Scalars['DateTime']>;
  initialScore?: Maybe<Scalars['Int']>;
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  runtimeVersion?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  workerId?: Maybe<Scalars['BigInt']>;
};

export type WorkerActivitiesMaxOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesMinAggregate = {
  __typename?: 'WorkerActivitiesMinAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  confidenceLevel?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  infoLastUpdatedAt?: Maybe<Scalars['DateTime']>;
  initialScore?: Maybe<Scalars['Int']>;
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  runtimeVersion?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  workerId?: Maybe<Scalars['BigInt']>;
};

export type WorkerActivitiesMinOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesOrderByWithAggregationInput = {
  _avg?: InputMaybe<WorkerActivitiesAvgOrderByAggregateInput>;
  _count?: InputMaybe<WorkerActivitiesCountOrderByAggregateInput>;
  _max?: InputMaybe<WorkerActivitiesMaxOrderByAggregateInput>;
  _min?: InputMaybe<WorkerActivitiesMinOrderByAggregateInput>;
  _sum?: InputMaybe<WorkerActivitiesSumOrderByAggregateInput>;
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesOrderByWithRelationInput = {
  accounts?: InputMaybe<AccountsOrderByWithRelationInput>;
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  events?: InputMaybe<EventsOrderByWithRelationInput>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  miners?: InputMaybe<MinersOrderByWithRelationInput>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
  workers?: InputMaybe<WorkersOrderByWithRelationInput>;
};

export enum WorkerActivitiesScalarFieldEnum {
  BlockNumber = 'blockNumber',
  ConfidenceLevel = 'confidenceLevel',
  CreatedAt = 'createdAt',
  CurrentMinerAccountAddress = 'currentMinerAccountAddress',
  CurrentMinerId = 'currentMinerId',
  CurrentPid = 'currentPid',
  CurrentStakePoolId = 'currentStakePoolId',
  EcdhPublicKey = 'ecdhPublicKey',
  EventId = 'eventId',
  Features = 'features',
  Id = 'id',
  InfoLastUpdatedAt = 'infoLastUpdatedAt',
  InitialScore = 'initialScore',
  OperatorAddress = 'operatorAddress',
  OperatorId = 'operatorId',
  RuntimeVersion = 'runtimeVersion',
  Timestamp = 'timestamp',
  TokenomicVersion = 'tokenomicVersion',
  Type = 'type',
  UpdatedAt = 'updatedAt',
  WorkerId = 'workerId'
}

export type WorkerActivitiesScalarWhereInput = {
  AND?: InputMaybe<Array<WorkerActivitiesScalarWhereInput>>;
  NOT?: InputMaybe<Array<WorkerActivitiesScalarWhereInput>>;
  OR?: InputMaybe<Array<WorkerActivitiesScalarWhereInput>>;
  blockNumber?: InputMaybe<BigIntFilter>;
  confidenceLevel?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  currentMinerAccountAddress?: InputMaybe<StringNullableFilter>;
  currentMinerId?: InputMaybe<BigIntNullableFilter>;
  currentPid?: InputMaybe<IntNullableFilter>;
  currentStakePoolId?: InputMaybe<BigIntNullableFilter>;
  ecdhPublicKey?: InputMaybe<StringNullableFilter>;
  eventId?: InputMaybe<BigIntNullableFilter>;
  features?: InputMaybe<IntNullableListFilter>;
  id?: InputMaybe<BigIntFilter>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFilter>;
  initialScore?: InputMaybe<IntFilter>;
  operatorAddress?: InputMaybe<StringNullableFilter>;
  operatorId?: InputMaybe<BigIntNullableFilter>;
  runtimeVersion?: InputMaybe<IntFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  workerId?: InputMaybe<BigIntFilter>;
};

export type WorkerActivitiesScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<WorkerActivitiesScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<WorkerActivitiesScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<WorkerActivitiesScalarWhereWithAggregatesInput>>;
  blockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  confidenceLevel?: InputMaybe<IntWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  currentMinerAccountAddress?: InputMaybe<StringNullableWithAggregatesFilter>;
  currentMinerId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  currentPid?: InputMaybe<IntNullableWithAggregatesFilter>;
  currentStakePoolId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  ecdhPublicKey?: InputMaybe<StringNullableWithAggregatesFilter>;
  eventId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  features?: InputMaybe<IntNullableListFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  infoLastUpdatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  initialScore?: InputMaybe<IntWithAggregatesFilter>;
  operatorAddress?: InputMaybe<StringNullableWithAggregatesFilter>;
  operatorId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  runtimeVersion?: InputMaybe<IntWithAggregatesFilter>;
  timestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  tokenomicVersion?: InputMaybe<IntWithAggregatesFilter>;
  type?: InputMaybe<StringWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  workerId?: InputMaybe<BigIntWithAggregatesFilter>;
};

export type WorkerActivitiesSumAggregate = {
  __typename?: 'WorkerActivitiesSumAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  confidenceLevel?: Maybe<Scalars['Int']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  eventId?: Maybe<Scalars['BigInt']>;
  features?: Maybe<Array<Scalars['Int']>>;
  id?: Maybe<Scalars['BigInt']>;
  initialScore?: Maybe<Scalars['Int']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  runtimeVersion?: Maybe<Scalars['Int']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  workerId?: Maybe<Scalars['BigInt']>;
};

export type WorkerActivitiesSumOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesUpdateInput = {
  accounts?: InputMaybe<AccountsUpdateOneWithoutWorkerActivitiesInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  events?: InputMaybe<EventsUpdateOneWithoutWorkerActivitiesInput>;
  features?: InputMaybe<WorkerActivitiesUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateOneWithoutWorkerActivitiesInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneWithoutWorkerActivitiesInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workers?: InputMaybe<WorkersUpdateOneRequiredWithoutWorkerActivitiesInput>;
};

export type WorkerActivitiesUpdateManyMutationInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  features?: InputMaybe<WorkerActivitiesUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type WorkerActivitiesUpdateManyWithWhereWithoutAccountsInput = {
  data: WorkerActivitiesUpdateManyMutationInput;
  where: WorkerActivitiesScalarWhereInput;
};

export type WorkerActivitiesUpdateManyWithWhereWithoutEventsInput = {
  data: WorkerActivitiesUpdateManyMutationInput;
  where: WorkerActivitiesScalarWhereInput;
};

export type WorkerActivitiesUpdateManyWithWhereWithoutMinersInput = {
  data: WorkerActivitiesUpdateManyMutationInput;
  where: WorkerActivitiesScalarWhereInput;
};

export type WorkerActivitiesUpdateManyWithWhereWithoutStakePoolsInput = {
  data: WorkerActivitiesUpdateManyMutationInput;
  where: WorkerActivitiesScalarWhereInput;
};

export type WorkerActivitiesUpdateManyWithWhereWithoutWorkersInput = {
  data: WorkerActivitiesUpdateManyMutationInput;
  where: WorkerActivitiesScalarWhereInput;
};

export type WorkerActivitiesUpdateManyWithoutAccountsInput = {
  connect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkerActivitiesCreateOrConnectWithoutAccountsInput>>;
  create?: InputMaybe<Array<WorkerActivitiesCreateWithoutAccountsInput>>;
  createMany?: InputMaybe<WorkerActivitiesCreateManyAccountsInputEnvelope>;
  delete?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<WorkerActivitiesScalarWhereInput>>;
  disconnect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  set?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  update?: InputMaybe<Array<WorkerActivitiesUpdateWithWhereUniqueWithoutAccountsInput>>;
  updateMany?: InputMaybe<Array<WorkerActivitiesUpdateManyWithWhereWithoutAccountsInput>>;
  upsert?: InputMaybe<Array<WorkerActivitiesUpsertWithWhereUniqueWithoutAccountsInput>>;
};

export type WorkerActivitiesUpdateManyWithoutEventsInput = {
  connect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkerActivitiesCreateOrConnectWithoutEventsInput>>;
  create?: InputMaybe<Array<WorkerActivitiesCreateWithoutEventsInput>>;
  createMany?: InputMaybe<WorkerActivitiesCreateManyEventsInputEnvelope>;
  delete?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<WorkerActivitiesScalarWhereInput>>;
  disconnect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  set?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  update?: InputMaybe<Array<WorkerActivitiesUpdateWithWhereUniqueWithoutEventsInput>>;
  updateMany?: InputMaybe<Array<WorkerActivitiesUpdateManyWithWhereWithoutEventsInput>>;
  upsert?: InputMaybe<Array<WorkerActivitiesUpsertWithWhereUniqueWithoutEventsInput>>;
};

export type WorkerActivitiesUpdateManyWithoutMinersInput = {
  connect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkerActivitiesCreateOrConnectWithoutMinersInput>>;
  create?: InputMaybe<Array<WorkerActivitiesCreateWithoutMinersInput>>;
  createMany?: InputMaybe<WorkerActivitiesCreateManyMinersInputEnvelope>;
  delete?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<WorkerActivitiesScalarWhereInput>>;
  disconnect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  set?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  update?: InputMaybe<Array<WorkerActivitiesUpdateWithWhereUniqueWithoutMinersInput>>;
  updateMany?: InputMaybe<Array<WorkerActivitiesUpdateManyWithWhereWithoutMinersInput>>;
  upsert?: InputMaybe<Array<WorkerActivitiesUpsertWithWhereUniqueWithoutMinersInput>>;
};

export type WorkerActivitiesUpdateManyWithoutStakePoolsInput = {
  connect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkerActivitiesCreateOrConnectWithoutStakePoolsInput>>;
  create?: InputMaybe<Array<WorkerActivitiesCreateWithoutStakePoolsInput>>;
  createMany?: InputMaybe<WorkerActivitiesCreateManyStakePoolsInputEnvelope>;
  delete?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<WorkerActivitiesScalarWhereInput>>;
  disconnect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  set?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  update?: InputMaybe<Array<WorkerActivitiesUpdateWithWhereUniqueWithoutStakePoolsInput>>;
  updateMany?: InputMaybe<Array<WorkerActivitiesUpdateManyWithWhereWithoutStakePoolsInput>>;
  upsert?: InputMaybe<Array<WorkerActivitiesUpsertWithWhereUniqueWithoutStakePoolsInput>>;
};

export type WorkerActivitiesUpdateManyWithoutWorkersInput = {
  connect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkerActivitiesCreateOrConnectWithoutWorkersInput>>;
  create?: InputMaybe<Array<WorkerActivitiesCreateWithoutWorkersInput>>;
  createMany?: InputMaybe<WorkerActivitiesCreateManyWorkersInputEnvelope>;
  delete?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<WorkerActivitiesScalarWhereInput>>;
  disconnect?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  set?: InputMaybe<Array<WorkerActivitiesWhereUniqueInput>>;
  update?: InputMaybe<Array<WorkerActivitiesUpdateWithWhereUniqueWithoutWorkersInput>>;
  updateMany?: InputMaybe<Array<WorkerActivitiesUpdateManyWithWhereWithoutWorkersInput>>;
  upsert?: InputMaybe<Array<WorkerActivitiesUpsertWithWhereUniqueWithoutWorkersInput>>;
};

export type WorkerActivitiesUpdateWithWhereUniqueWithoutAccountsInput = {
  data: WorkerActivitiesUpdateWithoutAccountsInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesUpdateWithWhereUniqueWithoutEventsInput = {
  data: WorkerActivitiesUpdateWithoutEventsInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesUpdateWithWhereUniqueWithoutMinersInput = {
  data: WorkerActivitiesUpdateWithoutMinersInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesUpdateWithWhereUniqueWithoutStakePoolsInput = {
  data: WorkerActivitiesUpdateWithoutStakePoolsInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesUpdateWithWhereUniqueWithoutWorkersInput = {
  data: WorkerActivitiesUpdateWithoutWorkersInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesUpdateWithoutAccountsInput = {
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  events?: InputMaybe<EventsUpdateOneWithoutWorkerActivitiesInput>;
  features?: InputMaybe<WorkerActivitiesUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateOneWithoutWorkerActivitiesInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneWithoutWorkerActivitiesInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workers?: InputMaybe<WorkersUpdateOneRequiredWithoutWorkerActivitiesInput>;
};

export type WorkerActivitiesUpdateWithoutEventsInput = {
  accounts?: InputMaybe<AccountsUpdateOneWithoutWorkerActivitiesInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  features?: InputMaybe<WorkerActivitiesUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateOneWithoutWorkerActivitiesInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneWithoutWorkerActivitiesInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workers?: InputMaybe<WorkersUpdateOneRequiredWithoutWorkerActivitiesInput>;
};

export type WorkerActivitiesUpdateWithoutMinersInput = {
  accounts?: InputMaybe<AccountsUpdateOneWithoutWorkerActivitiesInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  events?: InputMaybe<EventsUpdateOneWithoutWorkerActivitiesInput>;
  features?: InputMaybe<WorkerActivitiesUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneWithoutWorkerActivitiesInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workers?: InputMaybe<WorkersUpdateOneRequiredWithoutWorkerActivitiesInput>;
};

export type WorkerActivitiesUpdateWithoutStakePoolsInput = {
  accounts?: InputMaybe<AccountsUpdateOneWithoutWorkerActivitiesInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  events?: InputMaybe<EventsUpdateOneWithoutWorkerActivitiesInput>;
  features?: InputMaybe<WorkerActivitiesUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateOneWithoutWorkerActivitiesInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workers?: InputMaybe<WorkersUpdateOneRequiredWithoutWorkerActivitiesInput>;
};

export type WorkerActivitiesUpdateWithoutWorkersInput = {
  accounts?: InputMaybe<AccountsUpdateOneWithoutWorkerActivitiesInput>;
  blockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  events?: InputMaybe<EventsUpdateOneWithoutWorkerActivitiesInput>;
  features?: InputMaybe<WorkerActivitiesUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  miners?: InputMaybe<MinersUpdateOneWithoutWorkerActivitiesInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneWithoutWorkerActivitiesInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tokenomicVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type WorkerActivitiesUpdatefeaturesInput = {
  push?: InputMaybe<Array<Scalars['Int']>>;
  set?: InputMaybe<Array<Scalars['Int']>>;
};

export type WorkerActivitiesUpsertWithWhereUniqueWithoutAccountsInput = {
  create: WorkerActivitiesCreateWithoutAccountsInput;
  update: WorkerActivitiesUpdateWithoutAccountsInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesUpsertWithWhereUniqueWithoutEventsInput = {
  create: WorkerActivitiesCreateWithoutEventsInput;
  update: WorkerActivitiesUpdateWithoutEventsInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesUpsertWithWhereUniqueWithoutMinersInput = {
  create: WorkerActivitiesCreateWithoutMinersInput;
  update: WorkerActivitiesUpdateWithoutMinersInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesUpsertWithWhereUniqueWithoutStakePoolsInput = {
  create: WorkerActivitiesCreateWithoutStakePoolsInput;
  update: WorkerActivitiesUpdateWithoutStakePoolsInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesUpsertWithWhereUniqueWithoutWorkersInput = {
  create: WorkerActivitiesCreateWithoutWorkersInput;
  update: WorkerActivitiesUpdateWithoutWorkersInput;
  where: WorkerActivitiesWhereUniqueInput;
};

export type WorkerActivitiesWhereInput = {
  AND?: InputMaybe<Array<WorkerActivitiesWhereInput>>;
  NOT?: InputMaybe<Array<WorkerActivitiesWhereInput>>;
  OR?: InputMaybe<Array<WorkerActivitiesWhereInput>>;
  accounts?: InputMaybe<AccountsRelationFilter>;
  blockNumber?: InputMaybe<BigIntFilter>;
  confidenceLevel?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  currentMinerAccountAddress?: InputMaybe<StringNullableFilter>;
  currentMinerId?: InputMaybe<BigIntNullableFilter>;
  currentPid?: InputMaybe<IntNullableFilter>;
  currentStakePoolId?: InputMaybe<BigIntNullableFilter>;
  ecdhPublicKey?: InputMaybe<StringNullableFilter>;
  eventId?: InputMaybe<BigIntNullableFilter>;
  events?: InputMaybe<EventsRelationFilter>;
  features?: InputMaybe<IntNullableListFilter>;
  id?: InputMaybe<BigIntFilter>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFilter>;
  initialScore?: InputMaybe<IntFilter>;
  miners?: InputMaybe<MinersRelationFilter>;
  operatorAddress?: InputMaybe<StringNullableFilter>;
  operatorId?: InputMaybe<BigIntNullableFilter>;
  runtimeVersion?: InputMaybe<IntFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  workerId?: InputMaybe<BigIntFilter>;
  workers?: InputMaybe<WorkersRelationFilter>;
};

export type WorkerActivitiesWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type Workers = {
  __typename?: 'Workers';
  _count?: Maybe<WorkersCount>;
  accounts?: Maybe<Accounts>;
  confidenceLevel: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  features: Array<Scalars['Int']>;
  id: Scalars['BigInt'];
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersMinersToWorkersCurrentMinerId?: Maybe<Miners>;
  minersMinersWorkerIdToWorkers: Array<Miners>;
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  publicKey: Scalars['String'];
  runtimeVersion: Scalars['Int'];
  stakePools?: Maybe<StakePools>;
  updatedAt: Scalars['DateTime'];
  workerActivities: Array<WorkerActivities>;
};


export type WorkersMinersMinersWorkerIdToWorkersArgs = {
  cursor?: InputMaybe<MinersWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinersWhereInput>;
};


export type WorkersWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};

export type WorkersAvgAggregate = {
  __typename?: 'WorkersAvgAggregate';
  confidenceLevel?: Maybe<Scalars['Float']>;
  currentMinerId?: Maybe<Scalars['Float']>;
  currentPid?: Maybe<Scalars['Float']>;
  currentStakePoolId?: Maybe<Scalars['Float']>;
  features?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  initialScore?: Maybe<Scalars['Float']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  operatorId?: Maybe<Scalars['Float']>;
  runtimeVersion?: Maybe<Scalars['Float']>;
};

export type WorkersAvgOrderByAggregateInput = {
  confidenceLevel?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
};

export type WorkersCount = {
  __typename?: 'WorkersCount';
  minersMinersWorkerIdToWorkers: Scalars['Int'];
  workerActivities: Scalars['Int'];
};

export type WorkersCountAggregate = {
  __typename?: 'WorkersCountAggregate';
  _all: Scalars['Int'];
  confidenceLevel: Scalars['Int'];
  createdAt: Scalars['Int'];
  currentMinerAccountAddress: Scalars['Int'];
  currentMinerId: Scalars['Int'];
  currentPid: Scalars['Int'];
  currentStakePoolId: Scalars['Int'];
  ecdhPublicKey: Scalars['Int'];
  features: Scalars['Int'];
  id: Scalars['Int'];
  infoLastUpdatedAt: Scalars['Int'];
  initialScore: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['Int'];
  lastUpdatedTimestamp: Scalars['Int'];
  operatorAddress: Scalars['Int'];
  operatorId: Scalars['Int'];
  publicKey: Scalars['Int'];
  runtimeVersion: Scalars['Int'];
  updatedAt: Scalars['Int'];
};

export type WorkersCountOrderByAggregateInput = {
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  publicKey?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type WorkersCreateInput = {
  accounts?: InputMaybe<AccountsCreateNestedOneWithoutWorkersInput>;
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  features?: InputMaybe<WorkersCreatefeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersCreateNestedOneWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersCreateNestedManyWithoutWorkersMinersWorkerIdToWorkersInput>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  publicKey: Scalars['String'];
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  stakePools?: InputMaybe<StakePoolsCreateNestedOneWithoutWorkersInput>;
  updatedAt: Scalars['DateTime'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutWorkersInput>;
};

export type WorkersCreateManyAccountsInput = {
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentMinerId?: InputMaybe<Scalars['BigInt']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  currentStakePoolId?: InputMaybe<Scalars['BigInt']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  features?: InputMaybe<WorkersCreateManyfeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  operatorAddress?: InputMaybe<Scalars['String']>;
  publicKey: Scalars['String'];
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
};

export type WorkersCreateManyAccountsInputEnvelope = {
  data: Array<WorkersCreateManyAccountsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type WorkersCreateManyInput = {
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentMinerId?: InputMaybe<Scalars['BigInt']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  currentStakePoolId?: InputMaybe<Scalars['BigInt']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  features?: InputMaybe<WorkersCreateManyfeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  operatorAddress?: InputMaybe<Scalars['String']>;
  operatorId?: InputMaybe<Scalars['BigInt']>;
  publicKey: Scalars['String'];
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
};

export type WorkersCreateManyMinersMinersToWorkersCurrentMinerIdInput = {
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  currentStakePoolId?: InputMaybe<Scalars['BigInt']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  features?: InputMaybe<WorkersCreateManyfeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  operatorAddress?: InputMaybe<Scalars['String']>;
  operatorId?: InputMaybe<Scalars['BigInt']>;
  publicKey: Scalars['String'];
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
};

export type WorkersCreateManyMinersMinersToWorkersCurrentMinerIdInputEnvelope = {
  data: Array<WorkersCreateManyMinersMinersToWorkersCurrentMinerIdInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type WorkersCreateManyStakePoolsInput = {
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentMinerId?: InputMaybe<Scalars['BigInt']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  features?: InputMaybe<WorkersCreateManyfeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  operatorAddress?: InputMaybe<Scalars['String']>;
  operatorId?: InputMaybe<Scalars['BigInt']>;
  publicKey: Scalars['String'];
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
};

export type WorkersCreateManyStakePoolsInputEnvelope = {
  data: Array<WorkersCreateManyStakePoolsInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type WorkersCreateManyfeaturesInput = {
  set: Array<Scalars['Int']>;
};

export type WorkersCreateNestedManyWithoutAccountsInput = {
  connect?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkersCreateOrConnectWithoutAccountsInput>>;
  create?: InputMaybe<Array<WorkersCreateWithoutAccountsInput>>;
  createMany?: InputMaybe<WorkersCreateManyAccountsInputEnvelope>;
};

export type WorkersCreateNestedManyWithoutMinersMinersToWorkersCurrentMinerIdInput = {
  connect?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkersCreateOrConnectWithoutMinersMinersToWorkersCurrentMinerIdInput>>;
  create?: InputMaybe<Array<WorkersCreateWithoutMinersMinersToWorkersCurrentMinerIdInput>>;
  createMany?: InputMaybe<WorkersCreateManyMinersMinersToWorkersCurrentMinerIdInputEnvelope>;
};

export type WorkersCreateNestedManyWithoutStakePoolsInput = {
  connect?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkersCreateOrConnectWithoutStakePoolsInput>>;
  create?: InputMaybe<Array<WorkersCreateWithoutStakePoolsInput>>;
  createMany?: InputMaybe<WorkersCreateManyStakePoolsInputEnvelope>;
};

export type WorkersCreateNestedOneWithoutMinersMinersWorkerIdToWorkersInput = {
  connect?: InputMaybe<WorkersWhereUniqueInput>;
  connectOrCreate?: InputMaybe<WorkersCreateOrConnectWithoutMinersMinersWorkerIdToWorkersInput>;
  create?: InputMaybe<WorkersCreateWithoutMinersMinersWorkerIdToWorkersInput>;
};

export type WorkersCreateNestedOneWithoutWorkerActivitiesInput = {
  connect?: InputMaybe<WorkersWhereUniqueInput>;
  connectOrCreate?: InputMaybe<WorkersCreateOrConnectWithoutWorkerActivitiesInput>;
  create?: InputMaybe<WorkersCreateWithoutWorkerActivitiesInput>;
};

export type WorkersCreateOrConnectWithoutAccountsInput = {
  create: WorkersCreateWithoutAccountsInput;
  where: WorkersWhereUniqueInput;
};

export type WorkersCreateOrConnectWithoutMinersMinersToWorkersCurrentMinerIdInput = {
  create: WorkersCreateWithoutMinersMinersToWorkersCurrentMinerIdInput;
  where: WorkersWhereUniqueInput;
};

export type WorkersCreateOrConnectWithoutMinersMinersWorkerIdToWorkersInput = {
  create: WorkersCreateWithoutMinersMinersWorkerIdToWorkersInput;
  where: WorkersWhereUniqueInput;
};

export type WorkersCreateOrConnectWithoutStakePoolsInput = {
  create: WorkersCreateWithoutStakePoolsInput;
  where: WorkersWhereUniqueInput;
};

export type WorkersCreateOrConnectWithoutWorkerActivitiesInput = {
  create: WorkersCreateWithoutWorkerActivitiesInput;
  where: WorkersWhereUniqueInput;
};

export type WorkersCreateWithoutAccountsInput = {
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  features?: InputMaybe<WorkersCreatefeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersCreateNestedOneWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersCreateNestedManyWithoutWorkersMinersWorkerIdToWorkersInput>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  publicKey: Scalars['String'];
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  stakePools?: InputMaybe<StakePoolsCreateNestedOneWithoutWorkersInput>;
  updatedAt: Scalars['DateTime'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutWorkersInput>;
};

export type WorkersCreateWithoutMinersMinersToWorkersCurrentMinerIdInput = {
  accounts?: InputMaybe<AccountsCreateNestedOneWithoutWorkersInput>;
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  features?: InputMaybe<WorkersCreatefeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersCreateNestedManyWithoutWorkersMinersWorkerIdToWorkersInput>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  publicKey: Scalars['String'];
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  stakePools?: InputMaybe<StakePoolsCreateNestedOneWithoutWorkersInput>;
  updatedAt: Scalars['DateTime'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutWorkersInput>;
};

export type WorkersCreateWithoutMinersMinersWorkerIdToWorkersInput = {
  accounts?: InputMaybe<AccountsCreateNestedOneWithoutWorkersInput>;
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  features?: InputMaybe<WorkersCreatefeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersCreateNestedOneWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  publicKey: Scalars['String'];
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  stakePools?: InputMaybe<StakePoolsCreateNestedOneWithoutWorkersInput>;
  updatedAt: Scalars['DateTime'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutWorkersInput>;
};

export type WorkersCreateWithoutStakePoolsInput = {
  accounts?: InputMaybe<AccountsCreateNestedOneWithoutWorkersInput>;
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  features?: InputMaybe<WorkersCreatefeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersCreateNestedOneWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersCreateNestedManyWithoutWorkersMinersWorkerIdToWorkersInput>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  publicKey: Scalars['String'];
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  workerActivities?: InputMaybe<WorkerActivitiesCreateNestedManyWithoutWorkersInput>;
};

export type WorkersCreateWithoutWorkerActivitiesInput = {
  accounts?: InputMaybe<AccountsCreateNestedOneWithoutWorkersInput>;
  confidenceLevel?: InputMaybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: InputMaybe<Scalars['String']>;
  currentPid?: InputMaybe<Scalars['Int']>;
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  features?: InputMaybe<WorkersCreatefeaturesInput>;
  id?: InputMaybe<Scalars['BigInt']>;
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore?: InputMaybe<Scalars['Int']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersCreateNestedOneWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersCreateNestedManyWithoutWorkersMinersWorkerIdToWorkersInput>;
  operatorAddress?: InputMaybe<Scalars['String']>;
  publicKey: Scalars['String'];
  runtimeVersion?: InputMaybe<Scalars['Int']>;
  stakePools?: InputMaybe<StakePoolsCreateNestedOneWithoutWorkersInput>;
  updatedAt: Scalars['DateTime'];
};

export type WorkersCreatefeaturesInput = {
  set: Array<Scalars['Int']>;
};

export type WorkersGroupBy = {
  __typename?: 'WorkersGroupBy';
  _avg?: Maybe<WorkersAvgAggregate>;
  _count?: Maybe<WorkersCountAggregate>;
  _max?: Maybe<WorkersMaxAggregate>;
  _min?: Maybe<WorkersMinAggregate>;
  _sum?: Maybe<WorkersSumAggregate>;
  confidenceLevel: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  features?: Maybe<Array<Scalars['Int']>>;
  id: Scalars['BigInt'];
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  publicKey: Scalars['String'];
  runtimeVersion: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
};

export type WorkersListRelationFilter = {
  every?: InputMaybe<WorkersWhereInput>;
  none?: InputMaybe<WorkersWhereInput>;
  some?: InputMaybe<WorkersWhereInput>;
};

export type WorkersMaxAggregate = {
  __typename?: 'WorkersMaxAggregate';
  confidenceLevel?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['BigInt']>;
  infoLastUpdatedAt?: Maybe<Scalars['DateTime']>;
  initialScore?: Maybe<Scalars['Int']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  publicKey?: Maybe<Scalars['String']>;
  runtimeVersion?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type WorkersMaxOrderByAggregateInput = {
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  publicKey?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type WorkersMinAggregate = {
  __typename?: 'WorkersMinAggregate';
  confidenceLevel?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['BigInt']>;
  infoLastUpdatedAt?: Maybe<Scalars['DateTime']>;
  initialScore?: Maybe<Scalars['Int']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  publicKey?: Maybe<Scalars['String']>;
  runtimeVersion?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type WorkersMinOrderByAggregateInput = {
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  publicKey?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type WorkersOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type WorkersOrderByWithAggregationInput = {
  _avg?: InputMaybe<WorkersAvgOrderByAggregateInput>;
  _count?: InputMaybe<WorkersCountOrderByAggregateInput>;
  _max?: InputMaybe<WorkersMaxOrderByAggregateInput>;
  _min?: InputMaybe<WorkersMinOrderByAggregateInput>;
  _sum?: InputMaybe<WorkersSumOrderByAggregateInput>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  publicKey?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type WorkersOrderByWithRelationInput = {
  accounts?: InputMaybe<AccountsOrderByWithRelationInput>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersOrderByWithRelationInput>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersOrderByRelationAggregateInput>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  publicKey?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  updatedAt?: InputMaybe<SortOrder>;
  workerActivities?: InputMaybe<WorkerActivitiesOrderByRelationAggregateInput>;
};

export type WorkersRelationFilter = {
  is?: InputMaybe<WorkersWhereInput>;
  isNot?: InputMaybe<WorkersWhereInput>;
};

export enum WorkersScalarFieldEnum {
  ConfidenceLevel = 'confidenceLevel',
  CreatedAt = 'createdAt',
  CurrentMinerAccountAddress = 'currentMinerAccountAddress',
  CurrentMinerId = 'currentMinerId',
  CurrentPid = 'currentPid',
  CurrentStakePoolId = 'currentStakePoolId',
  EcdhPublicKey = 'ecdhPublicKey',
  Features = 'features',
  Id = 'id',
  InfoLastUpdatedAt = 'infoLastUpdatedAt',
  InitialScore = 'initialScore',
  LastUpdatedBlockNumber = 'lastUpdatedBlockNumber',
  LastUpdatedTimestamp = 'lastUpdatedTimestamp',
  OperatorAddress = 'operatorAddress',
  OperatorId = 'operatorId',
  PublicKey = 'publicKey',
  RuntimeVersion = 'runtimeVersion',
  UpdatedAt = 'updatedAt'
}

export type WorkersScalarWhereInput = {
  AND?: InputMaybe<Array<WorkersScalarWhereInput>>;
  NOT?: InputMaybe<Array<WorkersScalarWhereInput>>;
  OR?: InputMaybe<Array<WorkersScalarWhereInput>>;
  confidenceLevel?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  currentMinerAccountAddress?: InputMaybe<StringNullableFilter>;
  currentMinerId?: InputMaybe<BigIntNullableFilter>;
  currentPid?: InputMaybe<IntNullableFilter>;
  currentStakePoolId?: InputMaybe<BigIntNullableFilter>;
  ecdhPublicKey?: InputMaybe<StringNullableFilter>;
  features?: InputMaybe<IntNullableListFilter>;
  id?: InputMaybe<BigIntFilter>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFilter>;
  initialScore?: InputMaybe<IntFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  operatorAddress?: InputMaybe<StringNullableFilter>;
  operatorId?: InputMaybe<BigIntNullableFilter>;
  publicKey?: InputMaybe<StringFilter>;
  runtimeVersion?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type WorkersScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<WorkersScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<WorkersScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<WorkersScalarWhereWithAggregatesInput>>;
  confidenceLevel?: InputMaybe<IntWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  currentMinerAccountAddress?: InputMaybe<StringNullableWithAggregatesFilter>;
  currentMinerId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  currentPid?: InputMaybe<IntNullableWithAggregatesFilter>;
  currentStakePoolId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  ecdhPublicKey?: InputMaybe<StringNullableWithAggregatesFilter>;
  features?: InputMaybe<IntNullableListFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  infoLastUpdatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  initialScore?: InputMaybe<IntWithAggregatesFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  operatorAddress?: InputMaybe<StringNullableWithAggregatesFilter>;
  operatorId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  publicKey?: InputMaybe<StringWithAggregatesFilter>;
  runtimeVersion?: InputMaybe<IntWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type WorkersSumAggregate = {
  __typename?: 'WorkersSumAggregate';
  confidenceLevel?: Maybe<Scalars['Int']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  features?: Maybe<Array<Scalars['Int']>>;
  id?: Maybe<Scalars['BigInt']>;
  initialScore?: Maybe<Scalars['Int']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  runtimeVersion?: Maybe<Scalars['Int']>;
};

export type WorkersSumOrderByAggregateInput = {
  confidenceLevel?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
};

export type WorkersUpdateInput = {
  accounts?: InputMaybe<AccountsUpdateOneWithoutWorkersInput>;
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  features?: InputMaybe<WorkersUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersUpdateOneWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersUpdateManyWithoutWorkersMinersWorkerIdToWorkersInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  publicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneWithoutWorkersInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutWorkersInput>;
};

export type WorkersUpdateManyMutationInput = {
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  features?: InputMaybe<WorkersUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  publicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type WorkersUpdateManyWithWhereWithoutAccountsInput = {
  data: WorkersUpdateManyMutationInput;
  where: WorkersScalarWhereInput;
};

export type WorkersUpdateManyWithWhereWithoutMinersMinersToWorkersCurrentMinerIdInput = {
  data: WorkersUpdateManyMutationInput;
  where: WorkersScalarWhereInput;
};

export type WorkersUpdateManyWithWhereWithoutStakePoolsInput = {
  data: WorkersUpdateManyMutationInput;
  where: WorkersScalarWhereInput;
};

export type WorkersUpdateManyWithoutAccountsInput = {
  connect?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkersCreateOrConnectWithoutAccountsInput>>;
  create?: InputMaybe<Array<WorkersCreateWithoutAccountsInput>>;
  createMany?: InputMaybe<WorkersCreateManyAccountsInputEnvelope>;
  delete?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<WorkersScalarWhereInput>>;
  disconnect?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  set?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  update?: InputMaybe<Array<WorkersUpdateWithWhereUniqueWithoutAccountsInput>>;
  updateMany?: InputMaybe<Array<WorkersUpdateManyWithWhereWithoutAccountsInput>>;
  upsert?: InputMaybe<Array<WorkersUpsertWithWhereUniqueWithoutAccountsInput>>;
};

export type WorkersUpdateManyWithoutMinersMinersToWorkersCurrentMinerIdInput = {
  connect?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkersCreateOrConnectWithoutMinersMinersToWorkersCurrentMinerIdInput>>;
  create?: InputMaybe<Array<WorkersCreateWithoutMinersMinersToWorkersCurrentMinerIdInput>>;
  createMany?: InputMaybe<WorkersCreateManyMinersMinersToWorkersCurrentMinerIdInputEnvelope>;
  delete?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<WorkersScalarWhereInput>>;
  disconnect?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  set?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  update?: InputMaybe<Array<WorkersUpdateWithWhereUniqueWithoutMinersMinersToWorkersCurrentMinerIdInput>>;
  updateMany?: InputMaybe<Array<WorkersUpdateManyWithWhereWithoutMinersMinersToWorkersCurrentMinerIdInput>>;
  upsert?: InputMaybe<Array<WorkersUpsertWithWhereUniqueWithoutMinersMinersToWorkersCurrentMinerIdInput>>;
};

export type WorkersUpdateManyWithoutStakePoolsInput = {
  connect?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<WorkersCreateOrConnectWithoutStakePoolsInput>>;
  create?: InputMaybe<Array<WorkersCreateWithoutStakePoolsInput>>;
  createMany?: InputMaybe<WorkersCreateManyStakePoolsInputEnvelope>;
  delete?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<WorkersScalarWhereInput>>;
  disconnect?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  set?: InputMaybe<Array<WorkersWhereUniqueInput>>;
  update?: InputMaybe<Array<WorkersUpdateWithWhereUniqueWithoutStakePoolsInput>>;
  updateMany?: InputMaybe<Array<WorkersUpdateManyWithWhereWithoutStakePoolsInput>>;
  upsert?: InputMaybe<Array<WorkersUpsertWithWhereUniqueWithoutStakePoolsInput>>;
};

export type WorkersUpdateOneRequiredWithoutMinersMinersWorkerIdToWorkersInput = {
  connect?: InputMaybe<WorkersWhereUniqueInput>;
  connectOrCreate?: InputMaybe<WorkersCreateOrConnectWithoutMinersMinersWorkerIdToWorkersInput>;
  create?: InputMaybe<WorkersCreateWithoutMinersMinersWorkerIdToWorkersInput>;
  update?: InputMaybe<WorkersUpdateWithoutMinersMinersWorkerIdToWorkersInput>;
  upsert?: InputMaybe<WorkersUpsertWithoutMinersMinersWorkerIdToWorkersInput>;
};

export type WorkersUpdateOneRequiredWithoutWorkerActivitiesInput = {
  connect?: InputMaybe<WorkersWhereUniqueInput>;
  connectOrCreate?: InputMaybe<WorkersCreateOrConnectWithoutWorkerActivitiesInput>;
  create?: InputMaybe<WorkersCreateWithoutWorkerActivitiesInput>;
  update?: InputMaybe<WorkersUpdateWithoutWorkerActivitiesInput>;
  upsert?: InputMaybe<WorkersUpsertWithoutWorkerActivitiesInput>;
};

export type WorkersUpdateWithWhereUniqueWithoutAccountsInput = {
  data: WorkersUpdateWithoutAccountsInput;
  where: WorkersWhereUniqueInput;
};

export type WorkersUpdateWithWhereUniqueWithoutMinersMinersToWorkersCurrentMinerIdInput = {
  data: WorkersUpdateWithoutMinersMinersToWorkersCurrentMinerIdInput;
  where: WorkersWhereUniqueInput;
};

export type WorkersUpdateWithWhereUniqueWithoutStakePoolsInput = {
  data: WorkersUpdateWithoutStakePoolsInput;
  where: WorkersWhereUniqueInput;
};

export type WorkersUpdateWithoutAccountsInput = {
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  features?: InputMaybe<WorkersUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersUpdateOneWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersUpdateManyWithoutWorkersMinersWorkerIdToWorkersInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  publicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneWithoutWorkersInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutWorkersInput>;
};

export type WorkersUpdateWithoutMinersMinersToWorkersCurrentMinerIdInput = {
  accounts?: InputMaybe<AccountsUpdateOneWithoutWorkersInput>;
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  features?: InputMaybe<WorkersUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersUpdateManyWithoutWorkersMinersWorkerIdToWorkersInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  publicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneWithoutWorkersInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutWorkersInput>;
};

export type WorkersUpdateWithoutMinersMinersWorkerIdToWorkersInput = {
  accounts?: InputMaybe<AccountsUpdateOneWithoutWorkersInput>;
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  features?: InputMaybe<WorkersUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersUpdateOneWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  publicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneWithoutWorkersInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutWorkersInput>;
};

export type WorkersUpdateWithoutStakePoolsInput = {
  accounts?: InputMaybe<AccountsUpdateOneWithoutWorkersInput>;
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  features?: InputMaybe<WorkersUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersUpdateOneWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersUpdateManyWithoutWorkersMinersWorkerIdToWorkersInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  publicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  workerActivities?: InputMaybe<WorkerActivitiesUpdateManyWithoutWorkersInput>;
};

export type WorkersUpdateWithoutWorkerActivitiesInput = {
  accounts?: InputMaybe<AccountsUpdateOneWithoutWorkersInput>;
  confidenceLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  currentMinerAccountAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  currentPid?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  ecdhPublicKey?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  features?: InputMaybe<WorkersUpdatefeaturesInput>;
  id?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  initialScore?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersUpdateOneWithoutWorkersMinersToWorkersCurrentMinerIdsInput>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersUpdateManyWithoutWorkersMinersWorkerIdToWorkersInput>;
  operatorAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  publicKey?: InputMaybe<StringFieldUpdateOperationsInput>;
  runtimeVersion?: InputMaybe<IntFieldUpdateOperationsInput>;
  stakePools?: InputMaybe<StakePoolsUpdateOneWithoutWorkersInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type WorkersUpdatefeaturesInput = {
  push?: InputMaybe<Array<Scalars['Int']>>;
  set?: InputMaybe<Array<Scalars['Int']>>;
};

export type WorkersUpsertWithWhereUniqueWithoutAccountsInput = {
  create: WorkersCreateWithoutAccountsInput;
  update: WorkersUpdateWithoutAccountsInput;
  where: WorkersWhereUniqueInput;
};

export type WorkersUpsertWithWhereUniqueWithoutMinersMinersToWorkersCurrentMinerIdInput = {
  create: WorkersCreateWithoutMinersMinersToWorkersCurrentMinerIdInput;
  update: WorkersUpdateWithoutMinersMinersToWorkersCurrentMinerIdInput;
  where: WorkersWhereUniqueInput;
};

export type WorkersUpsertWithWhereUniqueWithoutStakePoolsInput = {
  create: WorkersCreateWithoutStakePoolsInput;
  update: WorkersUpdateWithoutStakePoolsInput;
  where: WorkersWhereUniqueInput;
};

export type WorkersUpsertWithoutMinersMinersWorkerIdToWorkersInput = {
  create: WorkersCreateWithoutMinersMinersWorkerIdToWorkersInput;
  update: WorkersUpdateWithoutMinersMinersWorkerIdToWorkersInput;
};

export type WorkersUpsertWithoutWorkerActivitiesInput = {
  create: WorkersCreateWithoutWorkerActivitiesInput;
  update: WorkersUpdateWithoutWorkerActivitiesInput;
};

export type WorkersWhereInput = {
  AND?: InputMaybe<Array<WorkersWhereInput>>;
  NOT?: InputMaybe<Array<WorkersWhereInput>>;
  OR?: InputMaybe<Array<WorkersWhereInput>>;
  accounts?: InputMaybe<AccountsRelationFilter>;
  confidenceLevel?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  currentMinerAccountAddress?: InputMaybe<StringNullableFilter>;
  currentMinerId?: InputMaybe<BigIntNullableFilter>;
  currentPid?: InputMaybe<IntNullableFilter>;
  currentStakePoolId?: InputMaybe<BigIntNullableFilter>;
  ecdhPublicKey?: InputMaybe<StringNullableFilter>;
  features?: InputMaybe<IntNullableListFilter>;
  id?: InputMaybe<BigIntFilter>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFilter>;
  initialScore?: InputMaybe<IntFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersRelationFilter>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersListRelationFilter>;
  operatorAddress?: InputMaybe<StringNullableFilter>;
  operatorId?: InputMaybe<BigIntNullableFilter>;
  publicKey?: InputMaybe<StringFilter>;
  runtimeVersion?: InputMaybe<IntFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  workerActivities?: InputMaybe<WorkerActivitiesListRelationFilter>;
};

export type WorkersWhereUniqueInput = {
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  publicKey?: InputMaybe<Scalars['String']>;
};

export type StakePoolsQueryVariables = Exact<{
  where?: InputMaybe<StakePoolsWhereInput>;
  orderBy?: InputMaybe<Array<StakePoolsOrderByWithRelationInput> | StakePoolsOrderByWithRelationInput>;
  take?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  withStakePoolStakers?: InputMaybe<Scalars['Boolean']>;
  stakePoolStakersWhere?: InputMaybe<StakePoolStakersWhereInput>;
  withStakePoolWithdrawals?: InputMaybe<Scalars['Boolean']>;
  stakePoolWithdrawalsWhere?: InputMaybe<StakePoolWithdrawalsWhereInput>;
  withMiners?: InputMaybe<Scalars['Boolean']>;
  minersWhere?: InputMaybe<MinersWhereInput>;
}>;


export type StakePoolsQuery = { __typename?: 'Query', findManyStakePools: Array<{ __typename?: 'StakePools', pid: number, ownerAddress: string, commission: string, ownerReward: string, cap?: string | null | undefined, rewardAcc: string, totalShares: string, totalStake: string, freeStake: string, releasingStake: string, usedStake: string, remainingStake?: string | null | undefined, stakersCount: number, minersCount: number, instantApr: string, stakePoolStakers?: Array<{ __typename?: 'StakePoolStakers', address?: string | null | undefined, shares: string, locked: string, availableRewards: string, rewardDebt: string, stake: string, pendingRewards: string, stakeRewards: string, claimableRewards: string, instantClaimableRewards: string, isOwner: boolean }>, accounts: { __typename?: 'Accounts', identity?: string | null | undefined, identityVerified: boolean }, stakePoolWithdrawals?: Array<{ __typename?: 'StakePoolWithdrawals', shares: string, startTime: any, estimatesEndTime: any, stake: string, userAddress?: string | null | undefined }>, miners?: Array<{ __typename?: 'Miners', estimatesReclaimableAt?: any | null | undefined, workerPublicKey: string, stakes: string }> }>, aggregateStakePools: { __typename?: 'AggregateStakePools', _count?: { __typename?: 'StakePoolsCountAggregate', _all: number } | null | undefined } };

export type TotalStakeQueryVariables = Exact<{ [key: string]: never; }>;


export type TotalStakeQuery = { __typename?: 'Query', aggregateStakePools: { __typename?: 'AggregateStakePools', _sum?: { __typename?: 'StakePoolsSumAggregate', totalStake?: string | null | undefined } | null | undefined } };

export type StatesQueryVariables = Exact<{ [key: string]: never; }>;


export type StatesQuery = { __typename?: 'Query', findManyStates: Array<{ __typename?: 'States', integerValue?: number | null | undefined, datetimeValue?: any | null | undefined }> };

export type MinersQueryVariables = Exact<{
  where?: InputMaybe<MinersWhereInput>;
  orderBy?: InputMaybe<Array<MinersOrderByWithRelationInput> | MinersOrderByWithRelationInput>;
  take?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
}>;


export type MinersQuery = { __typename?: 'Query', findManyMiners: Array<{ __typename?: 'Miners', workerPublicKey: string, pid: number, state: string, v: string, ve: string, pInit: number, pInstant: number, totalReward: string, shares: string, sMin: string, sMax: string, stakes: string, estimatesReclaimableAt?: any | null | undefined, stakePools: { __typename?: 'StakePools', freeStake: string } }>, aggregateMiners: { __typename?: 'AggregateMiners', _count?: { __typename?: 'MinersCountAggregate', _all: number } | null | undefined } };

export type StakePoolQueryVariables = Exact<{
  where: StakePoolsWhereUniqueInput;
}>;


export type StakePoolQuery = { __typename?: 'Query', findUniqueStakePools?: { __typename?: 'StakePools', pid: number, ownerAddress: string, commission: string, ownerReward: string, cap?: string | null | undefined, rewardAcc: string, totalShares: string, totalStake: string, freeStake: string, releasingStake: string, remainingStake?: string | null | undefined, instantApr: string, stakersCount: number, withdrawalsCount: number, minersCount: number } | null | undefined };


export const StakePoolsDocument = `
    query StakePools($where: StakePoolsWhereInput, $orderBy: [StakePoolsOrderByWithRelationInput!], $take: Int, $skip: Int, $withStakePoolStakers: Boolean = false, $stakePoolStakersWhere: StakePoolStakersWhereInput, $withStakePoolWithdrawals: Boolean = false, $stakePoolWithdrawalsWhere: StakePoolWithdrawalsWhereInput, $withMiners: Boolean = false, $minersWhere: MinersWhereInput) {
  findManyStakePools(where: $where, orderBy: $orderBy, take: $take, skip: $skip) {
    pid
    ownerAddress
    commission
    ownerReward
    cap
    rewardAcc
    totalShares
    totalStake
    freeStake
    releasingStake
    usedStake
    remainingStake
    stakersCount
    minersCount
    instantApr
    stakePoolStakers(where: $stakePoolStakersWhere) @include(if: $withStakePoolStakers) {
      address
      shares
      locked
      availableRewards
      rewardDebt
      stake
      pendingRewards
      stakeRewards
      claimableRewards
      instantClaimableRewards
      isOwner
    }
    accounts {
      identity
      identityVerified
    }
    stakePoolWithdrawals(where: $stakePoolWithdrawalsWhere) @include(if: $withStakePoolWithdrawals) {
      shares
      startTime
      estimatesEndTime
      stake
      userAddress
    }
    miners(where: $minersWhere) @include(if: $withMiners) {
      estimatesReclaimableAt
      workerPublicKey
      stakes
    }
  }
  aggregateStakePools(where: $where) {
    _count {
      _all
    }
  }
}
    `;
export const useStakePoolsQuery = <
      TData = StakePoolsQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: StakePoolsQueryVariables,
      options?: UseQueryOptions<StakePoolsQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<StakePoolsQuery, TError, TData>(
      variables === undefined ? ['StakePools'] : ['StakePools', variables],
      fetcher<StakePoolsQuery, StakePoolsQueryVariables>(client, StakePoolsDocument, variables, headers),
      options
    );
export const TotalStakeDocument = `
    query TotalStake {
  aggregateStakePools {
    _sum {
      totalStake
    }
  }
}
    `;
export const useTotalStakeQuery = <
      TData = TotalStakeQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: TotalStakeQueryVariables,
      options?: UseQueryOptions<TotalStakeQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<TotalStakeQuery, TError, TData>(
      variables === undefined ? ['TotalStake'] : ['TotalStake', variables],
      fetcher<TotalStakeQuery, TotalStakeQueryVariables>(client, TotalStakeDocument, variables, headers),
      options
    );
export const StatesDocument = `
    query States {
  findManyStates {
    integerValue
    datetimeValue
  }
}
    `;
export const useStatesQuery = <
      TData = StatesQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: StatesQueryVariables,
      options?: UseQueryOptions<StatesQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<StatesQuery, TError, TData>(
      variables === undefined ? ['States'] : ['States', variables],
      fetcher<StatesQuery, StatesQueryVariables>(client, StatesDocument, variables, headers),
      options
    );
export const MinersDocument = `
    query Miners($where: MinersWhereInput, $orderBy: [MinersOrderByWithRelationInput!], $take: Int, $skip: Int) {
  findManyMiners(where: $where, orderBy: $orderBy, take: $take, skip: $skip) {
    workerPublicKey
    pid
    state
    v
    ve
    pInit
    pInstant
    totalReward
    shares
    sMin
    sMax
    stakes
    estimatesReclaimableAt
    stakePools {
      freeStake
    }
  }
  aggregateMiners(where: $where) {
    _count {
      _all
    }
  }
}
    `;
export const useMinersQuery = <
      TData = MinersQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: MinersQueryVariables,
      options?: UseQueryOptions<MinersQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<MinersQuery, TError, TData>(
      variables === undefined ? ['Miners'] : ['Miners', variables],
      fetcher<MinersQuery, MinersQueryVariables>(client, MinersDocument, variables, headers),
      options
    );
export const StakePoolDocument = `
    query StakePool($where: StakePoolsWhereUniqueInput!) {
  findUniqueStakePools(where: $where) {
    pid
    ownerAddress
    commission
    ownerReward
    cap
    rewardAcc
    totalShares
    totalStake
    freeStake
    releasingStake
    remainingStake
    instantApr
    stakersCount
    withdrawalsCount
    minersCount
  }
}
    `;
export const useStakePoolQuery = <
      TData = StakePoolQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables: StakePoolQueryVariables,
      options?: UseQueryOptions<StakePoolQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<StakePoolQuery, TError, TData>(
      ['StakePool', variables],
      fetcher<StakePoolQuery, StakePoolQueryVariables>(client, StakePoolDocument, variables, headers),
      options
    );