/* eslint-disable */
/* This file is generated by graphql-codegen, don't edit it directly. */
import { GraphQLClient } from 'graphql-request';
import { RequestInit } from 'graphql-request/dist/types.dom';
import { useQuery, UseQueryOptions } from 'react-query';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

function fetcher<TData, TVariables>(client: GraphQLClient, query: string, variables?: TVariables, headers?: RequestInit['headers']) {
  return async (): Promise<TData> => client.request<TData, TVariables>(query, variables, headers);
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** The `BigInt` scalar type represents non-fractional signed whole numeric values. */
  BigInt: string;
  /** The javascript `Date` as string. Type represents date and time as the ISO Date string. */
  DateTime: any;
  /** GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library. */
  Decimal: string;
};

export type AccountStats = {
  __typename?: 'AccountStats';
  accountId?: Maybe<Scalars['BigInt']>;
  accumulatedOwnedPoolReward: Scalars['Decimal'];
  accumulatedOwnedPoolStakes: Scalars['Decimal'];
  accumulatedOwnedPoolWorkers: Scalars['Decimal'];
  accumulatedPoolStakes: Scalars['Decimal'];
  address: Scalars['String'];
  createdAt: Scalars['DateTime'];
  id: Scalars['BigInt'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
};

export type AccountStatsAvgAggregate = {
  __typename?: 'AccountStatsAvgAggregate';
  accountId?: Maybe<Scalars['Float']>;
  accumulatedOwnedPoolReward?: Maybe<Scalars['Decimal']>;
  accumulatedOwnedPoolStakes?: Maybe<Scalars['Decimal']>;
  accumulatedOwnedPoolWorkers?: Maybe<Scalars['Decimal']>;
  accumulatedPoolStakes?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['Float']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['Float']>;
};

export type AccountStatsAvgOrderByAggregateInput = {
  accountId?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolReward?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolStakes?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolWorkers?: InputMaybe<SortOrder>;
  accumulatedPoolStakes?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
};

export type AccountStatsCountAggregate = {
  __typename?: 'AccountStatsCountAggregate';
  _all: Scalars['Int'];
  accountId: Scalars['Int'];
  accumulatedOwnedPoolReward: Scalars['Int'];
  accumulatedOwnedPoolStakes: Scalars['Int'];
  accumulatedOwnedPoolWorkers: Scalars['Int'];
  accumulatedPoolStakes: Scalars['Int'];
  address: Scalars['Int'];
  createdAt: Scalars['Int'];
  id: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['Int'];
  lastUpdatedTimestamp: Scalars['Int'];
  updatedAt: Scalars['Int'];
};

export type AccountStatsCountOrderByAggregateInput = {
  accountId?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolReward?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolStakes?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolWorkers?: InputMaybe<SortOrder>;
  accumulatedPoolStakes?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AccountStatsGroupBy = {
  __typename?: 'AccountStatsGroupBy';
  _avg?: Maybe<AccountStatsAvgAggregate>;
  _count?: Maybe<AccountStatsCountAggregate>;
  _max?: Maybe<AccountStatsMaxAggregate>;
  _min?: Maybe<AccountStatsMinAggregate>;
  _sum?: Maybe<AccountStatsSumAggregate>;
  accountId?: Maybe<Scalars['BigInt']>;
  accumulatedOwnedPoolReward: Scalars['Decimal'];
  accumulatedOwnedPoolStakes: Scalars['Decimal'];
  accumulatedOwnedPoolWorkers: Scalars['Decimal'];
  accumulatedPoolStakes: Scalars['Decimal'];
  address: Scalars['String'];
  createdAt: Scalars['DateTime'];
  id: Scalars['BigInt'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
};

export type AccountStatsMaxAggregate = {
  __typename?: 'AccountStatsMaxAggregate';
  accountId?: Maybe<Scalars['BigInt']>;
  accumulatedOwnedPoolReward?: Maybe<Scalars['Decimal']>;
  accumulatedOwnedPoolStakes?: Maybe<Scalars['Decimal']>;
  accumulatedOwnedPoolWorkers?: Maybe<Scalars['Decimal']>;
  accumulatedPoolStakes?: Maybe<Scalars['Decimal']>;
  address?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AccountStatsMaxOrderByAggregateInput = {
  accountId?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolReward?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolStakes?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolWorkers?: InputMaybe<SortOrder>;
  accumulatedPoolStakes?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AccountStatsMinAggregate = {
  __typename?: 'AccountStatsMinAggregate';
  accountId?: Maybe<Scalars['BigInt']>;
  accumulatedOwnedPoolReward?: Maybe<Scalars['Decimal']>;
  accumulatedOwnedPoolStakes?: Maybe<Scalars['Decimal']>;
  accumulatedOwnedPoolWorkers?: Maybe<Scalars['Decimal']>;
  accumulatedPoolStakes?: Maybe<Scalars['Decimal']>;
  address?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AccountStatsMinOrderByAggregateInput = {
  accountId?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolReward?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolStakes?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolWorkers?: InputMaybe<SortOrder>;
  accumulatedPoolStakes?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AccountStatsOrderByWithAggregationInput = {
  _avg?: InputMaybe<AccountStatsAvgOrderByAggregateInput>;
  _count?: InputMaybe<AccountStatsCountOrderByAggregateInput>;
  _max?: InputMaybe<AccountStatsMaxOrderByAggregateInput>;
  _min?: InputMaybe<AccountStatsMinOrderByAggregateInput>;
  _sum?: InputMaybe<AccountStatsSumOrderByAggregateInput>;
  accountId?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolReward?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolStakes?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolWorkers?: InputMaybe<SortOrder>;
  accumulatedPoolStakes?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AccountStatsOrderByWithRelationInput = {
  accountId?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolReward?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolStakes?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolWorkers?: InputMaybe<SortOrder>;
  accumulatedPoolStakes?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum AccountStatsScalarFieldEnum {
  AccountId = 'accountId',
  AccumulatedOwnedPoolReward = 'accumulatedOwnedPoolReward',
  AccumulatedOwnedPoolStakes = 'accumulatedOwnedPoolStakes',
  AccumulatedOwnedPoolWorkers = 'accumulatedOwnedPoolWorkers',
  AccumulatedPoolStakes = 'accumulatedPoolStakes',
  Address = 'address',
  CreatedAt = 'createdAt',
  Id = 'id',
  LastUpdatedBlockNumber = 'lastUpdatedBlockNumber',
  LastUpdatedTimestamp = 'lastUpdatedTimestamp',
  UpdatedAt = 'updatedAt'
}

export type AccountStatsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<AccountStatsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<AccountStatsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<AccountStatsScalarWhereWithAggregatesInput>>;
  accountId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  accumulatedOwnedPoolReward?: InputMaybe<DecimalWithAggregatesFilter>;
  accumulatedOwnedPoolStakes?: InputMaybe<DecimalWithAggregatesFilter>;
  accumulatedOwnedPoolWorkers?: InputMaybe<DecimalWithAggregatesFilter>;
  accumulatedPoolStakes?: InputMaybe<DecimalWithAggregatesFilter>;
  address?: InputMaybe<StringWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type AccountStatsSumAggregate = {
  __typename?: 'AccountStatsSumAggregate';
  accountId?: Maybe<Scalars['BigInt']>;
  accumulatedOwnedPoolReward?: Maybe<Scalars['Decimal']>;
  accumulatedOwnedPoolStakes?: Maybe<Scalars['Decimal']>;
  accumulatedOwnedPoolWorkers?: Maybe<Scalars['Decimal']>;
  accumulatedPoolStakes?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
};

export type AccountStatsSumOrderByAggregateInput = {
  accountId?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolReward?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolStakes?: InputMaybe<SortOrder>;
  accumulatedOwnedPoolWorkers?: InputMaybe<SortOrder>;
  accumulatedPoolStakes?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
};

export type AccountStatsWhereInput = {
  AND?: InputMaybe<Array<AccountStatsWhereInput>>;
  NOT?: InputMaybe<Array<AccountStatsWhereInput>>;
  OR?: InputMaybe<Array<AccountStatsWhereInput>>;
  accountId?: InputMaybe<BigIntNullableFilter>;
  accumulatedOwnedPoolReward?: InputMaybe<DecimalFilter>;
  accumulatedOwnedPoolStakes?: InputMaybe<DecimalFilter>;
  accumulatedOwnedPoolWorkers?: InputMaybe<DecimalFilter>;
  accumulatedPoolStakes?: InputMaybe<DecimalFilter>;
  address?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<BigIntFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type AccountStatsWhereUniqueInput = {
  address?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

export type Accounts = {
  __typename?: 'Accounts';
  _count?: Maybe<AccountsCount>;
  address: Scalars['String'];
  createdAt: Scalars['DateTime'];
  id: Scalars['BigInt'];
  identity?: Maybe<Scalars['String']>;
  identityVerified: Scalars['Boolean'];
  stakePoolStakers: Array<StakePoolStakers>;
  stakePoolWithdrawals: Array<StakePoolWithdrawals>;
  stakePools: Array<StakePools>;
  updatedAt: Scalars['DateTime'];
  workerActivities: Array<WorkerActivities>;
  workers: Array<Workers>;
};


export type AccountsStakePoolStakersArgs = {
  cursor?: InputMaybe<StakePoolStakersWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type AccountsStakePoolWithdrawalsArgs = {
  cursor?: InputMaybe<StakePoolWithdrawalsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolWithdrawalsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type AccountsStakePoolsArgs = {
  cursor?: InputMaybe<StakePoolsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolsWhereInput>;
};


export type AccountsWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type AccountsWorkersArgs = {
  cursor?: InputMaybe<WorkersWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};

export type AccountsAvgAggregate = {
  __typename?: 'AccountsAvgAggregate';
  id?: Maybe<Scalars['Float']>;
};

export type AccountsAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
};

export type AccountsCount = {
  __typename?: 'AccountsCount';
  stakePoolStakers: Scalars['Int'];
  stakePoolWithdrawals: Scalars['Int'];
  stakePools: Scalars['Int'];
  workerActivities: Scalars['Int'];
  workers: Scalars['Int'];
};

export type AccountsCountAggregate = {
  __typename?: 'AccountsCountAggregate';
  _all: Scalars['Int'];
  address: Scalars['Int'];
  createdAt: Scalars['Int'];
  id: Scalars['Int'];
  identity: Scalars['Int'];
  identityVerified: Scalars['Int'];
  updatedAt: Scalars['Int'];
};

export type AccountsCountOrderByAggregateInput = {
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identity?: InputMaybe<SortOrder>;
  identityVerified?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AccountsGroupBy = {
  __typename?: 'AccountsGroupBy';
  _avg?: Maybe<AccountsAvgAggregate>;
  _count?: Maybe<AccountsCountAggregate>;
  _max?: Maybe<AccountsMaxAggregate>;
  _min?: Maybe<AccountsMinAggregate>;
  _sum?: Maybe<AccountsSumAggregate>;
  address: Scalars['String'];
  createdAt: Scalars['DateTime'];
  id: Scalars['BigInt'];
  identity?: Maybe<Scalars['String']>;
  identityVerified: Scalars['Boolean'];
  updatedAt: Scalars['DateTime'];
};

export type AccountsMaxAggregate = {
  __typename?: 'AccountsMaxAggregate';
  address?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  identity?: Maybe<Scalars['String']>;
  identityVerified?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AccountsMaxOrderByAggregateInput = {
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identity?: InputMaybe<SortOrder>;
  identityVerified?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AccountsMinAggregate = {
  __typename?: 'AccountsMinAggregate';
  address?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  identity?: Maybe<Scalars['String']>;
  identityVerified?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AccountsMinOrderByAggregateInput = {
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identity?: InputMaybe<SortOrder>;
  identityVerified?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AccountsOrderByWithAggregationInput = {
  _avg?: InputMaybe<AccountsAvgOrderByAggregateInput>;
  _count?: InputMaybe<AccountsCountOrderByAggregateInput>;
  _max?: InputMaybe<AccountsMaxOrderByAggregateInput>;
  _min?: InputMaybe<AccountsMinOrderByAggregateInput>;
  _sum?: InputMaybe<AccountsSumOrderByAggregateInput>;
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identity?: InputMaybe<SortOrder>;
  identityVerified?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AccountsOrderByWithRelationInput = {
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identity?: InputMaybe<SortOrder>;
  identityVerified?: InputMaybe<SortOrder>;
  stakePoolStakers?: InputMaybe<StakePoolStakersOrderByRelationAggregateInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsOrderByRelationAggregateInput>;
  stakePools?: InputMaybe<StakePoolsOrderByRelationAggregateInput>;
  updatedAt?: InputMaybe<SortOrder>;
  workerActivities?: InputMaybe<WorkerActivitiesOrderByRelationAggregateInput>;
  workers?: InputMaybe<WorkersOrderByRelationAggregateInput>;
};

export type AccountsRelationFilter = {
  is?: InputMaybe<AccountsWhereInput>;
  isNot?: InputMaybe<AccountsWhereInput>;
};

export enum AccountsScalarFieldEnum {
  Address = 'address',
  CreatedAt = 'createdAt',
  Id = 'id',
  Identity = 'identity',
  IdentityVerified = 'identityVerified',
  UpdatedAt = 'updatedAt'
}

export type AccountsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<AccountsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<AccountsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<AccountsScalarWhereWithAggregatesInput>>;
  address?: InputMaybe<StringWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  identity?: InputMaybe<StringNullableWithAggregatesFilter>;
  identityVerified?: InputMaybe<BoolWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type AccountsSumAggregate = {
  __typename?: 'AccountsSumAggregate';
  id?: Maybe<Scalars['BigInt']>;
};

export type AccountsSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
};

export type AccountsWhereInput = {
  AND?: InputMaybe<Array<AccountsWhereInput>>;
  NOT?: InputMaybe<Array<AccountsWhereInput>>;
  OR?: InputMaybe<Array<AccountsWhereInput>>;
  address?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<BigIntFilter>;
  identity?: InputMaybe<StringNullableFilter>;
  identityVerified?: InputMaybe<BoolFilter>;
  stakePoolStakers?: InputMaybe<StakePoolStakersListRelationFilter>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsListRelationFilter>;
  stakePools?: InputMaybe<StakePoolsListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  workerActivities?: InputMaybe<WorkerActivitiesListRelationFilter>;
  workers?: InputMaybe<WorkersListRelationFilter>;
};

export type AccountsWhereUniqueInput = {
  address?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

export type AggregateAccountStats = {
  __typename?: 'AggregateAccountStats';
  _avg?: Maybe<AccountStatsAvgAggregate>;
  _count?: Maybe<AccountStatsCountAggregate>;
  _max?: Maybe<AccountStatsMaxAggregate>;
  _min?: Maybe<AccountStatsMinAggregate>;
  _sum?: Maybe<AccountStatsSumAggregate>;
};

export type AggregateAccounts = {
  __typename?: 'AggregateAccounts';
  _avg?: Maybe<AccountsAvgAggregate>;
  _count?: Maybe<AccountsCountAggregate>;
  _max?: Maybe<AccountsMaxAggregate>;
  _min?: Maybe<AccountsMinAggregate>;
  _sum?: Maybe<AccountsSumAggregate>;
};

export type AggregateArInternalMetadata = {
  __typename?: 'AggregateArInternalMetadata';
  _count?: Maybe<ArInternalMetadataCountAggregate>;
  _max?: Maybe<ArInternalMetadataMaxAggregate>;
  _min?: Maybe<ArInternalMetadataMinAggregate>;
};

export type AggregateCalendarDays = {
  __typename?: 'AggregateCalendarDays';
  _avg?: Maybe<CalendarDaysAvgAggregate>;
  _count?: Maybe<CalendarDaysCountAggregate>;
  _max?: Maybe<CalendarDaysMaxAggregate>;
  _min?: Maybe<CalendarDaysMinAggregate>;
  _sum?: Maybe<CalendarDaysSumAggregate>;
};

export type AggregateEvents = {
  __typename?: 'AggregateEvents';
  _avg?: Maybe<EventsAvgAggregate>;
  _count?: Maybe<EventsCountAggregate>;
  _max?: Maybe<EventsMaxAggregate>;
  _min?: Maybe<EventsMinAggregate>;
  _sum?: Maybe<EventsSumAggregate>;
};

export type AggregateMinerActivities = {
  __typename?: 'AggregateMinerActivities';
  _avg?: Maybe<MinerActivitiesAvgAggregate>;
  _count?: Maybe<MinerActivitiesCountAggregate>;
  _max?: Maybe<MinerActivitiesMaxAggregate>;
  _min?: Maybe<MinerActivitiesMinAggregate>;
  _sum?: Maybe<MinerActivitiesSumAggregate>;
};

export type AggregateMinerStats = {
  __typename?: 'AggregateMinerStats';
  _avg?: Maybe<MinerStatsAvgAggregate>;
  _count?: Maybe<MinerStatsCountAggregate>;
  _max?: Maybe<MinerStatsMaxAggregate>;
  _min?: Maybe<MinerStatsMinAggregate>;
  _sum?: Maybe<MinerStatsSumAggregate>;
};

export type AggregateMiners = {
  __typename?: 'AggregateMiners';
  _avg?: Maybe<MinersAvgAggregate>;
  _count?: Maybe<MinersCountAggregate>;
  _max?: Maybe<MinersMaxAggregate>;
  _min?: Maybe<MinersMinAggregate>;
  _sum?: Maybe<MinersSumAggregate>;
};

export type AggregateSchemaMigrations = {
  __typename?: 'AggregateSchemaMigrations';
  _count?: Maybe<SchemaMigrationsCountAggregate>;
  _max?: Maybe<SchemaMigrationsMaxAggregate>;
  _min?: Maybe<SchemaMigrationsMinAggregate>;
};

export type AggregateStakePoolActivities = {
  __typename?: 'AggregateStakePoolActivities';
  _avg?: Maybe<StakePoolActivitiesAvgAggregate>;
  _count?: Maybe<StakePoolActivitiesCountAggregate>;
  _max?: Maybe<StakePoolActivitiesMaxAggregate>;
  _min?: Maybe<StakePoolActivitiesMinAggregate>;
  _sum?: Maybe<StakePoolActivitiesSumAggregate>;
};

export type AggregateStakePoolStakerActivities = {
  __typename?: 'AggregateStakePoolStakerActivities';
  _avg?: Maybe<StakePoolStakerActivitiesAvgAggregate>;
  _count?: Maybe<StakePoolStakerActivitiesCountAggregate>;
  _max?: Maybe<StakePoolStakerActivitiesMaxAggregate>;
  _min?: Maybe<StakePoolStakerActivitiesMinAggregate>;
  _sum?: Maybe<StakePoolStakerActivitiesSumAggregate>;
};

export type AggregateStakePoolStakers = {
  __typename?: 'AggregateStakePoolStakers';
  _avg?: Maybe<StakePoolStakersAvgAggregate>;
  _count?: Maybe<StakePoolStakersCountAggregate>;
  _max?: Maybe<StakePoolStakersMaxAggregate>;
  _min?: Maybe<StakePoolStakersMinAggregate>;
  _sum?: Maybe<StakePoolStakersSumAggregate>;
};

export type AggregateStakePoolStats = {
  __typename?: 'AggregateStakePoolStats';
  _avg?: Maybe<StakePoolStatsAvgAggregate>;
  _count?: Maybe<StakePoolStatsCountAggregate>;
  _max?: Maybe<StakePoolStatsMaxAggregate>;
  _min?: Maybe<StakePoolStatsMinAggregate>;
  _sum?: Maybe<StakePoolStatsSumAggregate>;
};

export type AggregateStakePoolWithdrawals = {
  __typename?: 'AggregateStakePoolWithdrawals';
  _avg?: Maybe<StakePoolWithdrawalsAvgAggregate>;
  _count?: Maybe<StakePoolWithdrawalsCountAggregate>;
  _max?: Maybe<StakePoolWithdrawalsMaxAggregate>;
  _min?: Maybe<StakePoolWithdrawalsMinAggregate>;
  _sum?: Maybe<StakePoolWithdrawalsSumAggregate>;
};

export type AggregateStakePools = {
  __typename?: 'AggregateStakePools';
  _avg?: Maybe<StakePoolsAvgAggregate>;
  _count?: Maybe<StakePoolsCountAggregate>;
  _max?: Maybe<StakePoolsMaxAggregate>;
  _min?: Maybe<StakePoolsMinAggregate>;
  _sum?: Maybe<StakePoolsSumAggregate>;
};

export type AggregateStates = {
  __typename?: 'AggregateStates';
  _avg?: Maybe<StatesAvgAggregate>;
  _count?: Maybe<StatesCountAggregate>;
  _max?: Maybe<StatesMaxAggregate>;
  _min?: Maybe<StatesMinAggregate>;
  _sum?: Maybe<StatesSumAggregate>;
};

export type AggregateWorkerActivities = {
  __typename?: 'AggregateWorkerActivities';
  _avg?: Maybe<WorkerActivitiesAvgAggregate>;
  _count?: Maybe<WorkerActivitiesCountAggregate>;
  _max?: Maybe<WorkerActivitiesMaxAggregate>;
  _min?: Maybe<WorkerActivitiesMinAggregate>;
  _sum?: Maybe<WorkerActivitiesSumAggregate>;
};

export type AggregateWorkers = {
  __typename?: 'AggregateWorkers';
  _avg?: Maybe<WorkersAvgAggregate>;
  _count?: Maybe<WorkersCountAggregate>;
  _max?: Maybe<WorkersMaxAggregate>;
  _min?: Maybe<WorkersMinAggregate>;
  _sum?: Maybe<WorkersSumAggregate>;
};

export type ArInternalMetadata = {
  __typename?: 'ArInternalMetadata';
  createdAt: Scalars['DateTime'];
  key: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
};

export type ArInternalMetadataCountAggregate = {
  __typename?: 'ArInternalMetadataCountAggregate';
  _all: Scalars['Int'];
  createdAt: Scalars['Int'];
  key: Scalars['Int'];
  updatedAt: Scalars['Int'];
  value: Scalars['Int'];
};

export type ArInternalMetadataCountOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ArInternalMetadataGroupBy = {
  __typename?: 'ArInternalMetadataGroupBy';
  _count?: Maybe<ArInternalMetadataCountAggregate>;
  _max?: Maybe<ArInternalMetadataMaxAggregate>;
  _min?: Maybe<ArInternalMetadataMinAggregate>;
  createdAt: Scalars['DateTime'];
  key: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
};

export type ArInternalMetadataMaxAggregate = {
  __typename?: 'ArInternalMetadataMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']>;
  key?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  value?: Maybe<Scalars['String']>;
};

export type ArInternalMetadataMaxOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ArInternalMetadataMinAggregate = {
  __typename?: 'ArInternalMetadataMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']>;
  key?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  value?: Maybe<Scalars['String']>;
};

export type ArInternalMetadataMinOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ArInternalMetadataOrderByWithAggregationInput = {
  _count?: InputMaybe<ArInternalMetadataCountOrderByAggregateInput>;
  _max?: InputMaybe<ArInternalMetadataMaxOrderByAggregateInput>;
  _min?: InputMaybe<ArInternalMetadataMinOrderByAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ArInternalMetadataOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum ArInternalMetadataScalarFieldEnum {
  CreatedAt = 'createdAt',
  Key = 'key',
  UpdatedAt = 'updatedAt',
  Value = 'value'
}

export type ArInternalMetadataScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ArInternalMetadataScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ArInternalMetadataScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ArInternalMetadataScalarWhereWithAggregatesInput>>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  key?: InputMaybe<StringWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  value?: InputMaybe<StringNullableWithAggregatesFilter>;
};

export type ArInternalMetadataWhereInput = {
  AND?: InputMaybe<Array<ArInternalMetadataWhereInput>>;
  NOT?: InputMaybe<Array<ArInternalMetadataWhereInput>>;
  OR?: InputMaybe<Array<ArInternalMetadataWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  key?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  value?: InputMaybe<StringNullableFilter>;
};

export type ArInternalMetadataWhereUniqueInput = {
  key?: InputMaybe<Scalars['String']>;
};

export type BigIntFilter = {
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type BigIntNullableFilter = {
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type BigIntNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedBigIntNullableFilter>;
  _min?: InputMaybe<NestedBigIntNullableFilter>;
  _sum?: InputMaybe<NestedBigIntNullableFilter>;
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type BigIntWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBigIntFilter>;
  _min?: InputMaybe<NestedBigIntFilter>;
  _sum?: InputMaybe<NestedBigIntFilter>;
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type BoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type BoolNullableFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolNullableFilter>;
};

export type BoolNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedBoolNullableFilter>;
  _min?: InputMaybe<NestedBoolNullableFilter>;
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolNullableWithAggregatesFilter>;
};

export type BoolWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBoolFilter>;
  _min?: InputMaybe<NestedBoolFilter>;
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolWithAggregatesFilter>;
};

export type CalendarDays = {
  __typename?: 'CalendarDays';
  date: Scalars['DateTime'];
  id: Scalars['BigInt'];
  isTheEndOfMonth: Scalars['Boolean'];
  startedBlockNumber: Scalars['BigInt'];
  startedBlockTime: Scalars['DateTime'];
};

export type CalendarDaysAvgAggregate = {
  __typename?: 'CalendarDaysAvgAggregate';
  id?: Maybe<Scalars['Float']>;
  startedBlockNumber?: Maybe<Scalars['Float']>;
};

export type CalendarDaysAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  startedBlockNumber?: InputMaybe<SortOrder>;
};

export type CalendarDaysCountAggregate = {
  __typename?: 'CalendarDaysCountAggregate';
  _all: Scalars['Int'];
  date: Scalars['Int'];
  id: Scalars['Int'];
  isTheEndOfMonth: Scalars['Int'];
  startedBlockNumber: Scalars['Int'];
  startedBlockTime: Scalars['Int'];
};

export type CalendarDaysCountOrderByAggregateInput = {
  date?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isTheEndOfMonth?: InputMaybe<SortOrder>;
  startedBlockNumber?: InputMaybe<SortOrder>;
  startedBlockTime?: InputMaybe<SortOrder>;
};

export type CalendarDaysGroupBy = {
  __typename?: 'CalendarDaysGroupBy';
  _avg?: Maybe<CalendarDaysAvgAggregate>;
  _count?: Maybe<CalendarDaysCountAggregate>;
  _max?: Maybe<CalendarDaysMaxAggregate>;
  _min?: Maybe<CalendarDaysMinAggregate>;
  _sum?: Maybe<CalendarDaysSumAggregate>;
  date: Scalars['DateTime'];
  id: Scalars['BigInt'];
  isTheEndOfMonth: Scalars['Boolean'];
  startedBlockNumber: Scalars['BigInt'];
  startedBlockTime: Scalars['DateTime'];
};

export type CalendarDaysMaxAggregate = {
  __typename?: 'CalendarDaysMaxAggregate';
  date?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  isTheEndOfMonth?: Maybe<Scalars['Boolean']>;
  startedBlockNumber?: Maybe<Scalars['BigInt']>;
  startedBlockTime?: Maybe<Scalars['DateTime']>;
};

export type CalendarDaysMaxOrderByAggregateInput = {
  date?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isTheEndOfMonth?: InputMaybe<SortOrder>;
  startedBlockNumber?: InputMaybe<SortOrder>;
  startedBlockTime?: InputMaybe<SortOrder>;
};

export type CalendarDaysMinAggregate = {
  __typename?: 'CalendarDaysMinAggregate';
  date?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  isTheEndOfMonth?: Maybe<Scalars['Boolean']>;
  startedBlockNumber?: Maybe<Scalars['BigInt']>;
  startedBlockTime?: Maybe<Scalars['DateTime']>;
};

export type CalendarDaysMinOrderByAggregateInput = {
  date?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isTheEndOfMonth?: InputMaybe<SortOrder>;
  startedBlockNumber?: InputMaybe<SortOrder>;
  startedBlockTime?: InputMaybe<SortOrder>;
};

export type CalendarDaysOrderByWithAggregationInput = {
  _avg?: InputMaybe<CalendarDaysAvgOrderByAggregateInput>;
  _count?: InputMaybe<CalendarDaysCountOrderByAggregateInput>;
  _max?: InputMaybe<CalendarDaysMaxOrderByAggregateInput>;
  _min?: InputMaybe<CalendarDaysMinOrderByAggregateInput>;
  _sum?: InputMaybe<CalendarDaysSumOrderByAggregateInput>;
  date?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isTheEndOfMonth?: InputMaybe<SortOrder>;
  startedBlockNumber?: InputMaybe<SortOrder>;
  startedBlockTime?: InputMaybe<SortOrder>;
};

export type CalendarDaysOrderByWithRelationInput = {
  date?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isTheEndOfMonth?: InputMaybe<SortOrder>;
  startedBlockNumber?: InputMaybe<SortOrder>;
  startedBlockTime?: InputMaybe<SortOrder>;
};

export enum CalendarDaysScalarFieldEnum {
  Date = 'date',
  Id = 'id',
  IsTheEndOfMonth = 'isTheEndOfMonth',
  StartedBlockNumber = 'startedBlockNumber',
  StartedBlockTime = 'startedBlockTime'
}

export type CalendarDaysScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<CalendarDaysScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<CalendarDaysScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<CalendarDaysScalarWhereWithAggregatesInput>>;
  date?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  isTheEndOfMonth?: InputMaybe<BoolWithAggregatesFilter>;
  startedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  startedBlockTime?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type CalendarDaysSumAggregate = {
  __typename?: 'CalendarDaysSumAggregate';
  id?: Maybe<Scalars['BigInt']>;
  startedBlockNumber?: Maybe<Scalars['BigInt']>;
};

export type CalendarDaysSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  startedBlockNumber?: InputMaybe<SortOrder>;
};

export type CalendarDaysWhereInput = {
  AND?: InputMaybe<Array<CalendarDaysWhereInput>>;
  NOT?: InputMaybe<Array<CalendarDaysWhereInput>>;
  OR?: InputMaybe<Array<CalendarDaysWhereInput>>;
  date?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<BigIntFilter>;
  isTheEndOfMonth?: InputMaybe<BoolFilter>;
  startedBlockNumber?: InputMaybe<BigIntFilter>;
  startedBlockTime?: InputMaybe<DateTimeFilter>;
};

export type CalendarDaysWhereUniqueInput = {
  date?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['BigInt']>;
  startedBlockNumber?: InputMaybe<Scalars['BigInt']>;
};

export type DateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type DateTimeNullableFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type DateTimeNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDateTimeNullableFilter>;
  _min?: InputMaybe<NestedDateTimeNullableFilter>;
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type DateTimeWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedDateTimeFilter>;
  _min?: InputMaybe<NestedDateTimeFilter>;
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type DecimalFilter = {
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type DecimalNullableFilter = {
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type DecimalNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedDecimalNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDecimalNullableFilter>;
  _min?: InputMaybe<NestedDecimalNullableFilter>;
  _sum?: InputMaybe<NestedDecimalNullableFilter>;
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type DecimalWithAggregatesFilter = {
  _avg?: InputMaybe<NestedDecimalFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedDecimalFilter>;
  _min?: InputMaybe<NestedDecimalFilter>;
  _sum?: InputMaybe<NestedDecimalFilter>;
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type Events = {
  __typename?: 'Events';
  accountId?: Maybe<Scalars['BigInt']>;
  blockNumber: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['BigInt'];
  memo?: Maybe<Scalars['String']>;
  methodName: Scalars['String'];
  minerId?: Maybe<Scalars['BigInt']>;
  parsedData?: Maybe<Scalars['String']>;
  preparedAt?: Maybe<Scalars['DateTime']>;
  processedAt?: Maybe<Scalars['DateTime']>;
  rawData?: Maybe<Scalars['String']>;
  sectionName: Scalars['String'];
  skippedAt?: Maybe<Scalars['DateTime']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  workerId?: Maybe<Scalars['BigInt']>;
};

export type EventsAvgAggregate = {
  __typename?: 'EventsAvgAggregate';
  accountId?: Maybe<Scalars['Float']>;
  blockNumber?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  minerId?: Maybe<Scalars['Float']>;
  stakePoolId?: Maybe<Scalars['Float']>;
  tokenomicVersion?: Maybe<Scalars['Float']>;
  workerId?: Maybe<Scalars['Float']>;
};

export type EventsAvgOrderByAggregateInput = {
  accountId?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type EventsCountAggregate = {
  __typename?: 'EventsCountAggregate';
  _all: Scalars['Int'];
  accountId: Scalars['Int'];
  blockNumber: Scalars['Int'];
  createdAt: Scalars['Int'];
  id: Scalars['Int'];
  memo: Scalars['Int'];
  methodName: Scalars['Int'];
  minerId: Scalars['Int'];
  parsedData: Scalars['Int'];
  preparedAt: Scalars['Int'];
  processedAt: Scalars['Int'];
  rawData: Scalars['Int'];
  sectionName: Scalars['Int'];
  skippedAt: Scalars['Int'];
  stakePoolId: Scalars['Int'];
  timestamp: Scalars['Int'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['Int'];
  workerId: Scalars['Int'];
};

export type EventsCountOrderByAggregateInput = {
  accountId?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  memo?: InputMaybe<SortOrder>;
  methodName?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  parsedData?: InputMaybe<SortOrder>;
  preparedAt?: InputMaybe<SortOrder>;
  processedAt?: InputMaybe<SortOrder>;
  rawData?: InputMaybe<SortOrder>;
  sectionName?: InputMaybe<SortOrder>;
  skippedAt?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type EventsGroupBy = {
  __typename?: 'EventsGroupBy';
  _avg?: Maybe<EventsAvgAggregate>;
  _count?: Maybe<EventsCountAggregate>;
  _max?: Maybe<EventsMaxAggregate>;
  _min?: Maybe<EventsMinAggregate>;
  _sum?: Maybe<EventsSumAggregate>;
  accountId?: Maybe<Scalars['BigInt']>;
  blockNumber: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['BigInt'];
  memo?: Maybe<Scalars['String']>;
  methodName: Scalars['String'];
  minerId?: Maybe<Scalars['BigInt']>;
  parsedData?: Maybe<Scalars['String']>;
  preparedAt?: Maybe<Scalars['DateTime']>;
  processedAt?: Maybe<Scalars['DateTime']>;
  rawData?: Maybe<Scalars['String']>;
  sectionName: Scalars['String'];
  skippedAt?: Maybe<Scalars['DateTime']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  workerId?: Maybe<Scalars['BigInt']>;
};

export type EventsMaxAggregate = {
  __typename?: 'EventsMaxAggregate';
  accountId?: Maybe<Scalars['BigInt']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  memo?: Maybe<Scalars['String']>;
  methodName?: Maybe<Scalars['String']>;
  minerId?: Maybe<Scalars['BigInt']>;
  parsedData?: Maybe<Scalars['String']>;
  preparedAt?: Maybe<Scalars['DateTime']>;
  processedAt?: Maybe<Scalars['DateTime']>;
  rawData?: Maybe<Scalars['String']>;
  sectionName?: Maybe<Scalars['String']>;
  skippedAt?: Maybe<Scalars['DateTime']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  workerId?: Maybe<Scalars['BigInt']>;
};

export type EventsMaxOrderByAggregateInput = {
  accountId?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  memo?: InputMaybe<SortOrder>;
  methodName?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  parsedData?: InputMaybe<SortOrder>;
  preparedAt?: InputMaybe<SortOrder>;
  processedAt?: InputMaybe<SortOrder>;
  rawData?: InputMaybe<SortOrder>;
  sectionName?: InputMaybe<SortOrder>;
  skippedAt?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type EventsMinAggregate = {
  __typename?: 'EventsMinAggregate';
  accountId?: Maybe<Scalars['BigInt']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  memo?: Maybe<Scalars['String']>;
  methodName?: Maybe<Scalars['String']>;
  minerId?: Maybe<Scalars['BigInt']>;
  parsedData?: Maybe<Scalars['String']>;
  preparedAt?: Maybe<Scalars['DateTime']>;
  processedAt?: Maybe<Scalars['DateTime']>;
  rawData?: Maybe<Scalars['String']>;
  sectionName?: Maybe<Scalars['String']>;
  skippedAt?: Maybe<Scalars['DateTime']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  workerId?: Maybe<Scalars['BigInt']>;
};

export type EventsMinOrderByAggregateInput = {
  accountId?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  memo?: InputMaybe<SortOrder>;
  methodName?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  parsedData?: InputMaybe<SortOrder>;
  preparedAt?: InputMaybe<SortOrder>;
  processedAt?: InputMaybe<SortOrder>;
  rawData?: InputMaybe<SortOrder>;
  sectionName?: InputMaybe<SortOrder>;
  skippedAt?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type EventsOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventsAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventsCountOrderByAggregateInput>;
  _max?: InputMaybe<EventsMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventsMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventsSumOrderByAggregateInput>;
  accountId?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  memo?: InputMaybe<SortOrder>;
  methodName?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  parsedData?: InputMaybe<SortOrder>;
  preparedAt?: InputMaybe<SortOrder>;
  processedAt?: InputMaybe<SortOrder>;
  rawData?: InputMaybe<SortOrder>;
  sectionName?: InputMaybe<SortOrder>;
  skippedAt?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type EventsOrderByWithRelationInput = {
  accountId?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  memo?: InputMaybe<SortOrder>;
  methodName?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  parsedData?: InputMaybe<SortOrder>;
  preparedAt?: InputMaybe<SortOrder>;
  processedAt?: InputMaybe<SortOrder>;
  rawData?: InputMaybe<SortOrder>;
  sectionName?: InputMaybe<SortOrder>;
  skippedAt?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export enum EventsScalarFieldEnum {
  AccountId = 'accountId',
  BlockNumber = 'blockNumber',
  CreatedAt = 'createdAt',
  Id = 'id',
  Memo = 'memo',
  MethodName = 'methodName',
  MinerId = 'minerId',
  ParsedData = 'parsedData',
  PreparedAt = 'preparedAt',
  ProcessedAt = 'processedAt',
  RawData = 'rawData',
  SectionName = 'sectionName',
  SkippedAt = 'skippedAt',
  StakePoolId = 'stakePoolId',
  Timestamp = 'timestamp',
  TokenomicVersion = 'tokenomicVersion',
  Type = 'type',
  WorkerId = 'workerId'
}

export type EventsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventsScalarWhereWithAggregatesInput>>;
  accountId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  blockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  memo?: InputMaybe<StringNullableWithAggregatesFilter>;
  methodName?: InputMaybe<StringWithAggregatesFilter>;
  minerId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  parsedData?: InputMaybe<StringNullableWithAggregatesFilter>;
  preparedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  processedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  rawData?: InputMaybe<StringNullableWithAggregatesFilter>;
  sectionName?: InputMaybe<StringWithAggregatesFilter>;
  skippedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  stakePoolId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  timestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  tokenomicVersion?: InputMaybe<IntWithAggregatesFilter>;
  type?: InputMaybe<StringWithAggregatesFilter>;
  workerId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
};

export type EventsSumAggregate = {
  __typename?: 'EventsSumAggregate';
  accountId?: Maybe<Scalars['BigInt']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  minerId?: Maybe<Scalars['BigInt']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  workerId?: Maybe<Scalars['BigInt']>;
};

export type EventsSumOrderByAggregateInput = {
  accountId?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type EventsWhereInput = {
  AND?: InputMaybe<Array<EventsWhereInput>>;
  NOT?: InputMaybe<Array<EventsWhereInput>>;
  OR?: InputMaybe<Array<EventsWhereInput>>;
  accountId?: InputMaybe<BigIntNullableFilter>;
  blockNumber?: InputMaybe<BigIntFilter>;
  createdAt?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<BigIntFilter>;
  memo?: InputMaybe<StringNullableFilter>;
  methodName?: InputMaybe<StringFilter>;
  minerId?: InputMaybe<BigIntNullableFilter>;
  parsedData?: InputMaybe<StringNullableFilter>;
  preparedAt?: InputMaybe<DateTimeNullableFilter>;
  processedAt?: InputMaybe<DateTimeNullableFilter>;
  rawData?: InputMaybe<StringNullableFilter>;
  sectionName?: InputMaybe<StringFilter>;
  skippedAt?: InputMaybe<DateTimeNullableFilter>;
  stakePoolId?: InputMaybe<BigIntNullableFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
  workerId?: InputMaybe<BigIntNullableFilter>;
};

export type EventsWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type FloatFilter = {
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export type FloatWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedFloatFilter>;
  _min?: InputMaybe<NestedFloatFilter>;
  _sum?: InputMaybe<NestedFloatFilter>;
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export type IntFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type IntNullableFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type IntNullableListFilter = {
  equals?: InputMaybe<Array<Scalars['Int']>>;
  has?: InputMaybe<Scalars['Int']>;
  hasEvery?: InputMaybe<Array<Scalars['Int']>>;
  hasSome?: InputMaybe<Array<Scalars['Int']>>;
  isEmpty?: InputMaybe<Scalars['Boolean']>;
};

export type IntNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedIntNullableFilter>;
  _min?: InputMaybe<NestedIntNullableFilter>;
  _sum?: InputMaybe<NestedIntNullableFilter>;
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type IntWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedIntFilter>;
  _min?: InputMaybe<NestedIntFilter>;
  _sum?: InputMaybe<NestedIntFilter>;
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type MinerActivities = {
  __typename?: 'MinerActivities';
  active: Scalars['Boolean'];
  blockNumber: Scalars['BigInt'];
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current: Scalars['Boolean'];
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id: Scalars['BigInt'];
  iterations: Scalars['BigInt'];
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  minerId: Scalars['BigInt'];
  miners: Miners;
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  sMax: Scalars['Decimal'];
  sMin: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stakes: Scalars['Decimal'];
  state: Scalars['String'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalReward: Scalars['Decimal'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  v: Scalars['Decimal'];
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve: Scalars['Decimal'];
};

export type MinerActivitiesAvgAggregate = {
  __typename?: 'MinerActivitiesAvgAggregate';
  blockNumber?: Maybe<Scalars['Float']>;
  eventId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  iterations?: Maybe<Scalars['Float']>;
  minerId?: Maybe<Scalars['Float']>;
  pInit?: Maybe<Scalars['Float']>;
  pInstant?: Maybe<Scalars['Float']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakes?: Maybe<Scalars['Decimal']>;
  tokenomicVersion?: Maybe<Scalars['Float']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  v?: Maybe<Scalars['Decimal']>;
  ve?: Maybe<Scalars['Decimal']>;
};

export type MinerActivitiesAvgOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export type MinerActivitiesCountAggregate = {
  __typename?: 'MinerActivitiesCountAggregate';
  _all: Scalars['Int'];
  active: Scalars['Int'];
  blockNumber: Scalars['Int'];
  coolingDownStartedAt: Scalars['Int'];
  createdAt: Scalars['Int'];
  current: Scalars['Int'];
  estimatesReclaimableAt: Scalars['Int'];
  eventId: Scalars['Int'];
  id: Scalars['Int'];
  iterations: Scalars['Int'];
  lastChallengedAt: Scalars['Int'];
  minerId: Scalars['Int'];
  miningStartedAt: Scalars['Int'];
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  sMax: Scalars['Int'];
  sMin: Scalars['Int'];
  shares: Scalars['Int'];
  stakes: Scalars['Int'];
  state: Scalars['Int'];
  timestamp: Scalars['Int'];
  tokenomicVersion: Scalars['Int'];
  totalReward: Scalars['Int'];
  type: Scalars['Int'];
  updatedAt: Scalars['Int'];
  v: Scalars['Int'];
  vUpdatedAt: Scalars['Int'];
  ve: Scalars['Int'];
};

export type MinerActivitiesCountOrderByAggregateInput = {
  active?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export type MinerActivitiesGroupBy = {
  __typename?: 'MinerActivitiesGroupBy';
  _avg?: Maybe<MinerActivitiesAvgAggregate>;
  _count?: Maybe<MinerActivitiesCountAggregate>;
  _max?: Maybe<MinerActivitiesMaxAggregate>;
  _min?: Maybe<MinerActivitiesMinAggregate>;
  _sum?: Maybe<MinerActivitiesSumAggregate>;
  active: Scalars['Boolean'];
  blockNumber: Scalars['BigInt'];
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current: Scalars['Boolean'];
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id: Scalars['BigInt'];
  iterations: Scalars['BigInt'];
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  minerId: Scalars['BigInt'];
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  sMax: Scalars['Decimal'];
  sMin: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stakes: Scalars['Decimal'];
  state: Scalars['String'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalReward: Scalars['Decimal'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  v: Scalars['Decimal'];
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve: Scalars['Decimal'];
};

export type MinerActivitiesListRelationFilter = {
  every?: InputMaybe<MinerActivitiesWhereInput>;
  none?: InputMaybe<MinerActivitiesWhereInput>;
  some?: InputMaybe<MinerActivitiesWhereInput>;
};

export type MinerActivitiesMaxAggregate = {
  __typename?: 'MinerActivitiesMaxAggregate';
  active?: Maybe<Scalars['Boolean']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  current?: Maybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  iterations?: Maybe<Scalars['BigInt']>;
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  minerId?: Maybe<Scalars['BigInt']>;
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit?: Maybe<Scalars['Int']>;
  pInstant?: Maybe<Scalars['Int']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakes?: Maybe<Scalars['Decimal']>;
  state?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  v?: Maybe<Scalars['Decimal']>;
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve?: Maybe<Scalars['Decimal']>;
};

export type MinerActivitiesMaxOrderByAggregateInput = {
  active?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export type MinerActivitiesMinAggregate = {
  __typename?: 'MinerActivitiesMinAggregate';
  active?: Maybe<Scalars['Boolean']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  current?: Maybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  iterations?: Maybe<Scalars['BigInt']>;
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  minerId?: Maybe<Scalars['BigInt']>;
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit?: Maybe<Scalars['Int']>;
  pInstant?: Maybe<Scalars['Int']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakes?: Maybe<Scalars['Decimal']>;
  state?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  v?: Maybe<Scalars['Decimal']>;
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve?: Maybe<Scalars['Decimal']>;
};

export type MinerActivitiesMinOrderByAggregateInput = {
  active?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export type MinerActivitiesOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type MinerActivitiesOrderByWithAggregationInput = {
  _avg?: InputMaybe<MinerActivitiesAvgOrderByAggregateInput>;
  _count?: InputMaybe<MinerActivitiesCountOrderByAggregateInput>;
  _max?: InputMaybe<MinerActivitiesMaxOrderByAggregateInput>;
  _min?: InputMaybe<MinerActivitiesMinOrderByAggregateInput>;
  _sum?: InputMaybe<MinerActivitiesSumOrderByAggregateInput>;
  active?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export type MinerActivitiesOrderByWithRelationInput = {
  active?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  miners?: InputMaybe<MinersOrderByWithRelationInput>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export enum MinerActivitiesScalarFieldEnum {
  Active = 'active',
  BlockNumber = 'blockNumber',
  CoolingDownStartedAt = 'coolingDownStartedAt',
  CreatedAt = 'createdAt',
  Current = 'current',
  EstimatesReclaimableAt = 'estimatesReclaimableAt',
  EventId = 'eventId',
  Id = 'id',
  Iterations = 'iterations',
  LastChallengedAt = 'lastChallengedAt',
  MinerId = 'minerId',
  MiningStartedAt = 'miningStartedAt',
  PInit = 'pInit',
  PInstant = 'pInstant',
  SMax = 'sMax',
  SMin = 'sMin',
  Shares = 'shares',
  Stakes = 'stakes',
  State = 'state',
  Timestamp = 'timestamp',
  TokenomicVersion = 'tokenomicVersion',
  TotalReward = 'totalReward',
  Type = 'type',
  UpdatedAt = 'updatedAt',
  V = 'v',
  VUpdatedAt = 'vUpdatedAt',
  Ve = 've'
}

export type MinerActivitiesScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<MinerActivitiesScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<MinerActivitiesScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<MinerActivitiesScalarWhereWithAggregatesInput>>;
  active?: InputMaybe<BoolWithAggregatesFilter>;
  blockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  coolingDownStartedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  current?: InputMaybe<BoolWithAggregatesFilter>;
  estimatesReclaimableAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  eventId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  iterations?: InputMaybe<BigIntWithAggregatesFilter>;
  lastChallengedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  minerId?: InputMaybe<BigIntWithAggregatesFilter>;
  miningStartedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  pInit?: InputMaybe<IntWithAggregatesFilter>;
  pInstant?: InputMaybe<IntWithAggregatesFilter>;
  sMax?: InputMaybe<DecimalWithAggregatesFilter>;
  sMin?: InputMaybe<DecimalWithAggregatesFilter>;
  shares?: InputMaybe<DecimalWithAggregatesFilter>;
  stakes?: InputMaybe<DecimalWithAggregatesFilter>;
  state?: InputMaybe<StringWithAggregatesFilter>;
  timestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  tokenomicVersion?: InputMaybe<IntWithAggregatesFilter>;
  totalReward?: InputMaybe<DecimalWithAggregatesFilter>;
  type?: InputMaybe<StringWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  v?: InputMaybe<DecimalWithAggregatesFilter>;
  vUpdatedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  ve?: InputMaybe<DecimalWithAggregatesFilter>;
};

export type MinerActivitiesSumAggregate = {
  __typename?: 'MinerActivitiesSumAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  iterations?: Maybe<Scalars['BigInt']>;
  minerId?: Maybe<Scalars['BigInt']>;
  pInit?: Maybe<Scalars['Int']>;
  pInstant?: Maybe<Scalars['Int']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakes?: Maybe<Scalars['Decimal']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  v?: Maybe<Scalars['Decimal']>;
  ve?: Maybe<Scalars['Decimal']>;
};

export type MinerActivitiesSumOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
};

export type MinerActivitiesWhereInput = {
  AND?: InputMaybe<Array<MinerActivitiesWhereInput>>;
  NOT?: InputMaybe<Array<MinerActivitiesWhereInput>>;
  OR?: InputMaybe<Array<MinerActivitiesWhereInput>>;
  active?: InputMaybe<BoolFilter>;
  blockNumber?: InputMaybe<BigIntFilter>;
  coolingDownStartedAt?: InputMaybe<DateTimeNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  current?: InputMaybe<BoolFilter>;
  estimatesReclaimableAt?: InputMaybe<DateTimeNullableFilter>;
  eventId?: InputMaybe<BigIntNullableFilter>;
  id?: InputMaybe<BigIntFilter>;
  iterations?: InputMaybe<BigIntFilter>;
  lastChallengedAt?: InputMaybe<DateTimeNullableFilter>;
  minerId?: InputMaybe<BigIntFilter>;
  miners?: InputMaybe<MinersRelationFilter>;
  miningStartedAt?: InputMaybe<DateTimeNullableFilter>;
  pInit?: InputMaybe<IntFilter>;
  pInstant?: InputMaybe<IntFilter>;
  sMax?: InputMaybe<DecimalFilter>;
  sMin?: InputMaybe<DecimalFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stakes?: InputMaybe<DecimalFilter>;
  state?: InputMaybe<StringFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  totalReward?: InputMaybe<DecimalFilter>;
  type?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  v?: InputMaybe<DecimalFilter>;
  vUpdatedAt?: InputMaybe<DateTimeNullableFilter>;
  ve?: InputMaybe<DecimalFilter>;
};

export type MinerActivitiesWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type MinerStats = {
  __typename?: 'MinerStats';
  accumulatedMiningReward: Scalars['Decimal'];
  address: Scalars['String'];
  createdAt: Scalars['DateTime'];
  id: Scalars['BigInt'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minerId?: Maybe<Scalars['BigInt']>;
  updatedAt: Scalars['DateTime'];
};

export type MinerStatsAvgAggregate = {
  __typename?: 'MinerStatsAvgAggregate';
  accumulatedMiningReward?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['Float']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  minerId?: Maybe<Scalars['Float']>;
};

export type MinerStatsAvgOrderByAggregateInput = {
  accumulatedMiningReward?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
};

export type MinerStatsCountAggregate = {
  __typename?: 'MinerStatsCountAggregate';
  _all: Scalars['Int'];
  accumulatedMiningReward: Scalars['Int'];
  address: Scalars['Int'];
  createdAt: Scalars['Int'];
  id: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['Int'];
  lastUpdatedTimestamp: Scalars['Int'];
  minerId: Scalars['Int'];
  updatedAt: Scalars['Int'];
};

export type MinerStatsCountOrderByAggregateInput = {
  accumulatedMiningReward?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type MinerStatsGroupBy = {
  __typename?: 'MinerStatsGroupBy';
  _avg?: Maybe<MinerStatsAvgAggregate>;
  _count?: Maybe<MinerStatsCountAggregate>;
  _max?: Maybe<MinerStatsMaxAggregate>;
  _min?: Maybe<MinerStatsMinAggregate>;
  _sum?: Maybe<MinerStatsSumAggregate>;
  accumulatedMiningReward: Scalars['Decimal'];
  address: Scalars['String'];
  createdAt: Scalars['DateTime'];
  id: Scalars['BigInt'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minerId?: Maybe<Scalars['BigInt']>;
  updatedAt: Scalars['DateTime'];
};

export type MinerStatsMaxAggregate = {
  __typename?: 'MinerStatsMaxAggregate';
  accumulatedMiningReward?: Maybe<Scalars['Decimal']>;
  address?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  minerId?: Maybe<Scalars['BigInt']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type MinerStatsMaxOrderByAggregateInput = {
  accumulatedMiningReward?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type MinerStatsMinAggregate = {
  __typename?: 'MinerStatsMinAggregate';
  accumulatedMiningReward?: Maybe<Scalars['Decimal']>;
  address?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  minerId?: Maybe<Scalars['BigInt']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type MinerStatsMinOrderByAggregateInput = {
  accumulatedMiningReward?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type MinerStatsOrderByWithAggregationInput = {
  _avg?: InputMaybe<MinerStatsAvgOrderByAggregateInput>;
  _count?: InputMaybe<MinerStatsCountOrderByAggregateInput>;
  _max?: InputMaybe<MinerStatsMaxOrderByAggregateInput>;
  _min?: InputMaybe<MinerStatsMinOrderByAggregateInput>;
  _sum?: InputMaybe<MinerStatsSumOrderByAggregateInput>;
  accumulatedMiningReward?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type MinerStatsOrderByWithRelationInput = {
  accumulatedMiningReward?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum MinerStatsScalarFieldEnum {
  AccumulatedMiningReward = 'accumulatedMiningReward',
  Address = 'address',
  CreatedAt = 'createdAt',
  Id = 'id',
  LastUpdatedBlockNumber = 'lastUpdatedBlockNumber',
  LastUpdatedTimestamp = 'lastUpdatedTimestamp',
  MinerId = 'minerId',
  UpdatedAt = 'updatedAt'
}

export type MinerStatsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<MinerStatsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<MinerStatsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<MinerStatsScalarWhereWithAggregatesInput>>;
  accumulatedMiningReward?: InputMaybe<DecimalWithAggregatesFilter>;
  address?: InputMaybe<StringWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  minerId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type MinerStatsSumAggregate = {
  __typename?: 'MinerStatsSumAggregate';
  accumulatedMiningReward?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  minerId?: Maybe<Scalars['BigInt']>;
};

export type MinerStatsSumOrderByAggregateInput = {
  accumulatedMiningReward?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  minerId?: InputMaybe<SortOrder>;
};

export type MinerStatsWhereInput = {
  AND?: InputMaybe<Array<MinerStatsWhereInput>>;
  NOT?: InputMaybe<Array<MinerStatsWhereInput>>;
  OR?: InputMaybe<Array<MinerStatsWhereInput>>;
  accumulatedMiningReward?: InputMaybe<DecimalFilter>;
  address?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<BigIntFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  minerId?: InputMaybe<BigIntNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type MinerStatsWhereUniqueInput = {
  address?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

export type Miners = {
  __typename?: 'Miners';
  _count?: Maybe<MinersCount>;
  active: Scalars['Boolean'];
  address: Scalars['String'];
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current: Scalars['Boolean'];
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['BigInt'];
  iterations: Scalars['BigInt'];
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minerActivities: Array<MinerActivities>;
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  pid: Scalars['Int'];
  sMax: Scalars['Decimal'];
  sMin: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakePools: StakePools;
  stakes: Scalars['Decimal'];
  state: Scalars['String'];
  totalReward: Scalars['Decimal'];
  updatedAt: Scalars['DateTime'];
  v: Scalars['Decimal'];
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve: Scalars['Decimal'];
  workerActivities: Array<WorkerActivities>;
  workerId: Scalars['BigInt'];
  workerPublicKey: Scalars['String'];
  workersMinersToWorkersCurrentMinerIds: Array<Workers>;
  workersMinersWorkerIdToWorkers: Workers;
};


export type MinersMinerActivitiesArgs = {
  cursor?: InputMaybe<MinerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type MinersWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type MinersWorkersMinersToWorkersCurrentMinerIdsArgs = {
  cursor?: InputMaybe<WorkersWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};

export type MinersAvgAggregate = {
  __typename?: 'MinersAvgAggregate';
  id?: Maybe<Scalars['Float']>;
  iterations?: Maybe<Scalars['Float']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  pInit?: Maybe<Scalars['Float']>;
  pInstant?: Maybe<Scalars['Float']>;
  pid?: Maybe<Scalars['Float']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['Float']>;
  stakes?: Maybe<Scalars['Decimal']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  v?: Maybe<Scalars['Decimal']>;
  ve?: Maybe<Scalars['Decimal']>;
  workerId?: Maybe<Scalars['Float']>;
};

export type MinersAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type MinersCount = {
  __typename?: 'MinersCount';
  minerActivities: Scalars['Int'];
  workerActivities: Scalars['Int'];
  workersMinersToWorkersCurrentMinerIds: Scalars['Int'];
};

export type MinersCountAggregate = {
  __typename?: 'MinersCountAggregate';
  _all: Scalars['Int'];
  active: Scalars['Int'];
  address: Scalars['Int'];
  coolingDownStartedAt: Scalars['Int'];
  createdAt: Scalars['Int'];
  current: Scalars['Int'];
  estimatesReclaimableAt: Scalars['Int'];
  id: Scalars['Int'];
  iterations: Scalars['Int'];
  lastChallengedAt: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['Int'];
  lastUpdatedTimestamp: Scalars['Int'];
  miningStartedAt: Scalars['Int'];
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  pid: Scalars['Int'];
  sMax: Scalars['Int'];
  sMin: Scalars['Int'];
  shares: Scalars['Int'];
  stakePoolId: Scalars['Int'];
  stakes: Scalars['Int'];
  state: Scalars['Int'];
  totalReward: Scalars['Int'];
  updatedAt: Scalars['Int'];
  v: Scalars['Int'];
  vUpdatedAt: Scalars['Int'];
  ve: Scalars['Int'];
  workerId: Scalars['Int'];
  workerPublicKey: Scalars['Int'];
};

export type MinersCountOrderByAggregateInput = {
  active?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
  workerPublicKey?: InputMaybe<SortOrder>;
};

export type MinersGroupBy = {
  __typename?: 'MinersGroupBy';
  _avg?: Maybe<MinersAvgAggregate>;
  _count?: Maybe<MinersCountAggregate>;
  _max?: Maybe<MinersMaxAggregate>;
  _min?: Maybe<MinersMinAggregate>;
  _sum?: Maybe<MinersSumAggregate>;
  active: Scalars['Boolean'];
  address: Scalars['String'];
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  current: Scalars['Boolean'];
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['BigInt'];
  iterations: Scalars['BigInt'];
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  pid: Scalars['Int'];
  sMax: Scalars['Decimal'];
  sMin: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakes: Scalars['Decimal'];
  state: Scalars['String'];
  totalReward: Scalars['Decimal'];
  updatedAt: Scalars['DateTime'];
  v: Scalars['Decimal'];
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve: Scalars['Decimal'];
  workerId: Scalars['BigInt'];
  workerPublicKey: Scalars['String'];
};

export type MinersListRelationFilter = {
  every?: InputMaybe<MinersWhereInput>;
  none?: InputMaybe<MinersWhereInput>;
  some?: InputMaybe<MinersWhereInput>;
};

export type MinersMaxAggregate = {
  __typename?: 'MinersMaxAggregate';
  active?: Maybe<Scalars['Boolean']>;
  address?: Maybe<Scalars['String']>;
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  current?: Maybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  iterations?: Maybe<Scalars['BigInt']>;
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit?: Maybe<Scalars['Int']>;
  pInstant?: Maybe<Scalars['Int']>;
  pid?: Maybe<Scalars['Int']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakes?: Maybe<Scalars['Decimal']>;
  state?: Maybe<Scalars['String']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  v?: Maybe<Scalars['Decimal']>;
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve?: Maybe<Scalars['Decimal']>;
  workerId?: Maybe<Scalars['BigInt']>;
  workerPublicKey?: Maybe<Scalars['String']>;
};

export type MinersMaxOrderByAggregateInput = {
  active?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
  workerPublicKey?: InputMaybe<SortOrder>;
};

export type MinersMinAggregate = {
  __typename?: 'MinersMinAggregate';
  active?: Maybe<Scalars['Boolean']>;
  address?: Maybe<Scalars['String']>;
  coolingDownStartedAt?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  current?: Maybe<Scalars['Boolean']>;
  estimatesReclaimableAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  iterations?: Maybe<Scalars['BigInt']>;
  lastChallengedAt?: Maybe<Scalars['DateTime']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  miningStartedAt?: Maybe<Scalars['DateTime']>;
  pInit?: Maybe<Scalars['Int']>;
  pInstant?: Maybe<Scalars['Int']>;
  pid?: Maybe<Scalars['Int']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakes?: Maybe<Scalars['Decimal']>;
  state?: Maybe<Scalars['String']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  v?: Maybe<Scalars['Decimal']>;
  vUpdatedAt?: Maybe<Scalars['DateTime']>;
  ve?: Maybe<Scalars['Decimal']>;
  workerId?: Maybe<Scalars['BigInt']>;
  workerPublicKey?: Maybe<Scalars['String']>;
};

export type MinersMinOrderByAggregateInput = {
  active?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
  workerPublicKey?: InputMaybe<SortOrder>;
};

export type MinersOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type MinersOrderByWithAggregationInput = {
  _avg?: InputMaybe<MinersAvgOrderByAggregateInput>;
  _count?: InputMaybe<MinersCountOrderByAggregateInput>;
  _max?: InputMaybe<MinersMaxOrderByAggregateInput>;
  _min?: InputMaybe<MinersMinOrderByAggregateInput>;
  _sum?: InputMaybe<MinersSumOrderByAggregateInput>;
  active?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
  workerPublicKey?: InputMaybe<SortOrder>;
};

export type MinersOrderByWithRelationInput = {
  active?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  coolingDownStartedAt?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  current?: InputMaybe<SortOrder>;
  estimatesReclaimableAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastChallengedAt?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minerActivities?: InputMaybe<MinerActivitiesOrderByRelationAggregateInput>;
  miningStartedAt?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  stakes?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  vUpdatedAt?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerActivities?: InputMaybe<WorkerActivitiesOrderByRelationAggregateInput>;
  workerId?: InputMaybe<SortOrder>;
  workerPublicKey?: InputMaybe<SortOrder>;
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersOrderByRelationAggregateInput>;
  workersMinersWorkerIdToWorkers?: InputMaybe<WorkersOrderByWithRelationInput>;
};

export type MinersRelationFilter = {
  is?: InputMaybe<MinersWhereInput>;
  isNot?: InputMaybe<MinersWhereInput>;
};

export enum MinersScalarFieldEnum {
  Active = 'active',
  Address = 'address',
  CoolingDownStartedAt = 'coolingDownStartedAt',
  CreatedAt = 'createdAt',
  Current = 'current',
  EstimatesReclaimableAt = 'estimatesReclaimableAt',
  Id = 'id',
  Iterations = 'iterations',
  LastChallengedAt = 'lastChallengedAt',
  LastUpdatedBlockNumber = 'lastUpdatedBlockNumber',
  LastUpdatedTimestamp = 'lastUpdatedTimestamp',
  MiningStartedAt = 'miningStartedAt',
  PInit = 'pInit',
  PInstant = 'pInstant',
  Pid = 'pid',
  SMax = 'sMax',
  SMin = 'sMin',
  Shares = 'shares',
  StakePoolId = 'stakePoolId',
  Stakes = 'stakes',
  State = 'state',
  TotalReward = 'totalReward',
  UpdatedAt = 'updatedAt',
  V = 'v',
  VUpdatedAt = 'vUpdatedAt',
  Ve = 've',
  WorkerId = 'workerId',
  WorkerPublicKey = 'workerPublicKey'
}

export type MinersScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<MinersScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<MinersScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<MinersScalarWhereWithAggregatesInput>>;
  active?: InputMaybe<BoolWithAggregatesFilter>;
  address?: InputMaybe<StringWithAggregatesFilter>;
  coolingDownStartedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  current?: InputMaybe<BoolWithAggregatesFilter>;
  estimatesReclaimableAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  iterations?: InputMaybe<BigIntWithAggregatesFilter>;
  lastChallengedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  miningStartedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  pInit?: InputMaybe<IntWithAggregatesFilter>;
  pInstant?: InputMaybe<IntWithAggregatesFilter>;
  pid?: InputMaybe<IntWithAggregatesFilter>;
  sMax?: InputMaybe<DecimalWithAggregatesFilter>;
  sMin?: InputMaybe<DecimalWithAggregatesFilter>;
  shares?: InputMaybe<DecimalWithAggregatesFilter>;
  stakePoolId?: InputMaybe<BigIntWithAggregatesFilter>;
  stakes?: InputMaybe<DecimalWithAggregatesFilter>;
  state?: InputMaybe<StringWithAggregatesFilter>;
  totalReward?: InputMaybe<DecimalWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  v?: InputMaybe<DecimalWithAggregatesFilter>;
  vUpdatedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  ve?: InputMaybe<DecimalWithAggregatesFilter>;
  workerId?: InputMaybe<BigIntWithAggregatesFilter>;
  workerPublicKey?: InputMaybe<StringWithAggregatesFilter>;
};

export type MinersSumAggregate = {
  __typename?: 'MinersSumAggregate';
  id?: Maybe<Scalars['BigInt']>;
  iterations?: Maybe<Scalars['BigInt']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  pInit?: Maybe<Scalars['Int']>;
  pInstant?: Maybe<Scalars['Int']>;
  pid?: Maybe<Scalars['Int']>;
  sMax?: Maybe<Scalars['Decimal']>;
  sMin?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakes?: Maybe<Scalars['Decimal']>;
  totalReward?: Maybe<Scalars['Decimal']>;
  v?: Maybe<Scalars['Decimal']>;
  ve?: Maybe<Scalars['Decimal']>;
  workerId?: Maybe<Scalars['BigInt']>;
};

export type MinersSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  iterations?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  pInit?: InputMaybe<SortOrder>;
  pInstant?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  sMax?: InputMaybe<SortOrder>;
  sMin?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakes?: InputMaybe<SortOrder>;
  totalReward?: InputMaybe<SortOrder>;
  v?: InputMaybe<SortOrder>;
  ve?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type MinersWhereInput = {
  AND?: InputMaybe<Array<MinersWhereInput>>;
  NOT?: InputMaybe<Array<MinersWhereInput>>;
  OR?: InputMaybe<Array<MinersWhereInput>>;
  active?: InputMaybe<BoolFilter>;
  address?: InputMaybe<StringFilter>;
  coolingDownStartedAt?: InputMaybe<DateTimeNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  current?: InputMaybe<BoolFilter>;
  estimatesReclaimableAt?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<BigIntFilter>;
  iterations?: InputMaybe<BigIntFilter>;
  lastChallengedAt?: InputMaybe<DateTimeNullableFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  minerActivities?: InputMaybe<MinerActivitiesListRelationFilter>;
  miningStartedAt?: InputMaybe<DateTimeNullableFilter>;
  pInit?: InputMaybe<IntFilter>;
  pInstant?: InputMaybe<IntFilter>;
  pid?: InputMaybe<IntFilter>;
  sMax?: InputMaybe<DecimalFilter>;
  sMin?: InputMaybe<DecimalFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stakePoolId?: InputMaybe<BigIntFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  stakes?: InputMaybe<DecimalFilter>;
  state?: InputMaybe<StringFilter>;
  totalReward?: InputMaybe<DecimalFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  v?: InputMaybe<DecimalFilter>;
  vUpdatedAt?: InputMaybe<DateTimeNullableFilter>;
  ve?: InputMaybe<DecimalFilter>;
  workerActivities?: InputMaybe<WorkerActivitiesListRelationFilter>;
  workerId?: InputMaybe<BigIntFilter>;
  workerPublicKey?: InputMaybe<StringFilter>;
  workersMinersToWorkersCurrentMinerIds?: InputMaybe<WorkersListRelationFilter>;
  workersMinersWorkerIdToWorkers?: InputMaybe<WorkersRelationFilter>;
};

export type MinersWhereUniqueInput = {
  address?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

export type NestedBigIntFilter = {
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type NestedBigIntNullableFilter = {
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type NestedBigIntNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedBigIntNullableFilter>;
  _min?: InputMaybe<NestedBigIntNullableFilter>;
  _sum?: InputMaybe<NestedBigIntNullableFilter>;
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type NestedBigIntWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBigIntFilter>;
  _min?: InputMaybe<NestedBigIntFilter>;
  _sum?: InputMaybe<NestedBigIntFilter>;
  equals?: InputMaybe<Scalars['BigInt']>;
  gt?: InputMaybe<Scalars['BigInt']>;
  gte?: InputMaybe<Scalars['BigInt']>;
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  lt?: InputMaybe<Scalars['BigInt']>;
  lte?: InputMaybe<Scalars['BigInt']>;
  not?: InputMaybe<NestedBigIntWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type NestedBoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type NestedBoolNullableFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolNullableFilter>;
};

export type NestedBoolNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedBoolNullableFilter>;
  _min?: InputMaybe<NestedBoolNullableFilter>;
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolNullableWithAggregatesFilter>;
};

export type NestedBoolWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBoolFilter>;
  _min?: InputMaybe<NestedBoolFilter>;
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolWithAggregatesFilter>;
};

export type NestedDateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedDateTimeNullableFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedDateTimeNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDateTimeNullableFilter>;
  _min?: InputMaybe<NestedDateTimeNullableFilter>;
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedDateTimeWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedDateTimeFilter>;
  _min?: InputMaybe<NestedDateTimeFilter>;
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedDecimalFilter = {
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type NestedDecimalNullableFilter = {
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type NestedDecimalNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedDecimalNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDecimalNullableFilter>;
  _min?: InputMaybe<NestedDecimalNullableFilter>;
  _sum?: InputMaybe<NestedDecimalNullableFilter>;
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type NestedDecimalWithAggregatesFilter = {
  _avg?: InputMaybe<NestedDecimalFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedDecimalFilter>;
  _min?: InputMaybe<NestedDecimalFilter>;
  _sum?: InputMaybe<NestedDecimalFilter>;
  equals?: InputMaybe<Scalars['Decimal']>;
  gt?: InputMaybe<Scalars['Decimal']>;
  gte?: InputMaybe<Scalars['Decimal']>;
  in?: InputMaybe<Array<Scalars['Decimal']>>;
  lt?: InputMaybe<Scalars['Decimal']>;
  lte?: InputMaybe<Scalars['Decimal']>;
  not?: InputMaybe<NestedDecimalWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']>>;
};

export type NestedFloatFilter = {
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export type NestedFloatNullableFilter = {
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export type NestedFloatWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedFloatFilter>;
  _min?: InputMaybe<NestedFloatFilter>;
  _sum?: InputMaybe<NestedFloatFilter>;
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export type NestedIntFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type NestedIntNullableFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type NestedIntNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedIntNullableFilter>;
  _min?: InputMaybe<NestedIntNullableFilter>;
  _sum?: InputMaybe<NestedIntNullableFilter>;
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type NestedIntWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedIntFilter>;
  _min?: InputMaybe<NestedIntFilter>;
  _sum?: InputMaybe<NestedIntFilter>;
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type NestedStringFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type NestedStringNullableFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type NestedStringNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedStringNullableFilter>;
  _min?: InputMaybe<NestedStringNullableFilter>;
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type NestedStringWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedStringFilter>;
  _min?: InputMaybe<NestedStringFilter>;
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type Query = {
  __typename?: 'Query';
  aggregateAccountStats: AggregateAccountStats;
  aggregateAccounts: AggregateAccounts;
  aggregateArInternalMetadata: AggregateArInternalMetadata;
  aggregateCalendarDays: AggregateCalendarDays;
  aggregateEvents: AggregateEvents;
  aggregateMinerActivities: AggregateMinerActivities;
  aggregateMinerStats: AggregateMinerStats;
  aggregateMiners: AggregateMiners;
  aggregateSchemaMigrations: AggregateSchemaMigrations;
  aggregateStakePoolActivities: AggregateStakePoolActivities;
  aggregateStakePoolStakerActivities: AggregateStakePoolStakerActivities;
  aggregateStakePoolStakers: AggregateStakePoolStakers;
  aggregateStakePoolStats: AggregateStakePoolStats;
  aggregateStakePoolWithdrawals: AggregateStakePoolWithdrawals;
  aggregateStakePools: AggregateStakePools;
  aggregateStates: AggregateStates;
  aggregateWorkerActivities: AggregateWorkerActivities;
  aggregateWorkers: AggregateWorkers;
  findFirstAccountStats?: Maybe<AccountStats>;
  findFirstAccounts?: Maybe<Accounts>;
  findFirstArInternalMetadata?: Maybe<ArInternalMetadata>;
  findFirstCalendarDays?: Maybe<CalendarDays>;
  findFirstEvents?: Maybe<Events>;
  findFirstMinerActivities?: Maybe<MinerActivities>;
  findFirstMinerStats?: Maybe<MinerStats>;
  findFirstMiners?: Maybe<Miners>;
  findFirstSchemaMigrations?: Maybe<SchemaMigrations>;
  findFirstStakePoolActivities?: Maybe<StakePoolActivities>;
  findFirstStakePoolStakerActivities?: Maybe<StakePoolStakerActivities>;
  findFirstStakePoolStakers?: Maybe<StakePoolStakers>;
  findFirstStakePoolStats?: Maybe<StakePoolStats>;
  findFirstStakePoolWithdrawals?: Maybe<StakePoolWithdrawals>;
  findFirstStakePools?: Maybe<StakePools>;
  findFirstStates?: Maybe<States>;
  findFirstWorkerActivities?: Maybe<WorkerActivities>;
  findFirstWorkers?: Maybe<Workers>;
  findManyAccountStats: Array<AccountStats>;
  findManyAccounts: Array<Accounts>;
  findManyArInternalMetadata: Array<ArInternalMetadata>;
  findManyCalendarDays: Array<CalendarDays>;
  findManyEvents: Array<Events>;
  findManyMinerActivities: Array<MinerActivities>;
  findManyMinerStats: Array<MinerStats>;
  findManyMiners: Array<Miners>;
  findManySchemaMigrations: Array<SchemaMigrations>;
  findManyStakePoolActivities: Array<StakePoolActivities>;
  findManyStakePoolStakerActivities: Array<StakePoolStakerActivities>;
  findManyStakePoolStakers: Array<StakePoolStakers>;
  findManyStakePoolStats: Array<StakePoolStats>;
  findManyStakePoolWithdrawals: Array<StakePoolWithdrawals>;
  findManyStakePools: Array<StakePools>;
  findManyStates: Array<States>;
  findManyWorkerActivities: Array<WorkerActivities>;
  findManyWorkers: Array<Workers>;
  findUniqueAccountStats?: Maybe<AccountStats>;
  findUniqueAccounts?: Maybe<Accounts>;
  findUniqueArInternalMetadata?: Maybe<ArInternalMetadata>;
  findUniqueCalendarDays?: Maybe<CalendarDays>;
  findUniqueEvents?: Maybe<Events>;
  findUniqueMinerActivities?: Maybe<MinerActivities>;
  findUniqueMinerStats?: Maybe<MinerStats>;
  findUniqueMiners?: Maybe<Miners>;
  findUniqueSchemaMigrations?: Maybe<SchemaMigrations>;
  findUniqueStakePoolActivities?: Maybe<StakePoolActivities>;
  findUniqueStakePoolStakerActivities?: Maybe<StakePoolStakerActivities>;
  findUniqueStakePoolStakers?: Maybe<StakePoolStakers>;
  findUniqueStakePoolStats?: Maybe<StakePoolStats>;
  findUniqueStakePoolWithdrawals?: Maybe<StakePoolWithdrawals>;
  findUniqueStakePools?: Maybe<StakePools>;
  findUniqueStates?: Maybe<States>;
  findUniqueWorkerActivities?: Maybe<WorkerActivities>;
  findUniqueWorkers?: Maybe<Workers>;
  groupByAccountStats: Array<AccountStatsGroupBy>;
  groupByAccounts: Array<AccountsGroupBy>;
  groupByArInternalMetadata: Array<ArInternalMetadataGroupBy>;
  groupByCalendarDays: Array<CalendarDaysGroupBy>;
  groupByEvents: Array<EventsGroupBy>;
  groupByMinerActivities: Array<MinerActivitiesGroupBy>;
  groupByMinerStats: Array<MinerStatsGroupBy>;
  groupByMiners: Array<MinersGroupBy>;
  groupBySchemaMigrations: Array<SchemaMigrationsGroupBy>;
  groupByStakePoolActivities: Array<StakePoolActivitiesGroupBy>;
  groupByStakePoolStakerActivities: Array<StakePoolStakerActivitiesGroupBy>;
  groupByStakePoolStakers: Array<StakePoolStakersGroupBy>;
  groupByStakePoolStats: Array<StakePoolStatsGroupBy>;
  groupByStakePoolWithdrawals: Array<StakePoolWithdrawalsGroupBy>;
  groupByStakePools: Array<StakePoolsGroupBy>;
  groupByStates: Array<StatesGroupBy>;
  groupByWorkerActivities: Array<WorkerActivitiesGroupBy>;
  groupByWorkers: Array<WorkersGroupBy>;
};


export type QueryAggregateAccountStatsArgs = {
  cursor?: InputMaybe<AccountStatsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<AccountStatsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountStatsWhereInput>;
};


export type QueryAggregateAccountsArgs = {
  cursor?: InputMaybe<AccountsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<AccountsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountsWhereInput>;
};


export type QueryAggregateArInternalMetadataArgs = {
  cursor?: InputMaybe<ArInternalMetadataWhereUniqueInput>;
  orderBy?: InputMaybe<Array<ArInternalMetadataOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ArInternalMetadataWhereInput>;
};


export type QueryAggregateCalendarDaysArgs = {
  cursor?: InputMaybe<CalendarDaysWhereUniqueInput>;
  orderBy?: InputMaybe<Array<CalendarDaysOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CalendarDaysWhereInput>;
};


export type QueryAggregateEventsArgs = {
  cursor?: InputMaybe<EventsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<EventsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EventsWhereInput>;
};


export type QueryAggregateMinerActivitiesArgs = {
  cursor?: InputMaybe<MinerActivitiesWhereUniqueInput>;
  orderBy?: InputMaybe<Array<MinerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type QueryAggregateMinerStatsArgs = {
  cursor?: InputMaybe<MinerStatsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<MinerStatsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerStatsWhereInput>;
};


export type QueryAggregateMinersArgs = {
  cursor?: InputMaybe<MinersWhereUniqueInput>;
  orderBy?: InputMaybe<Array<MinersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinersWhereInput>;
};


export type QueryAggregateSchemaMigrationsArgs = {
  cursor?: InputMaybe<SchemaMigrationsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<SchemaMigrationsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SchemaMigrationsWhereInput>;
};


export type QueryAggregateStakePoolActivitiesArgs = {
  cursor?: InputMaybe<StakePoolActivitiesWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StakePoolActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type QueryAggregateStakePoolStakerActivitiesArgs = {
  cursor?: InputMaybe<StakePoolStakerActivitiesWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StakePoolStakerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};


export type QueryAggregateStakePoolStakersArgs = {
  cursor?: InputMaybe<StakePoolStakersWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StakePoolStakersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type QueryAggregateStakePoolStatsArgs = {
  cursor?: InputMaybe<StakePoolStatsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StakePoolStatsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStatsWhereInput>;
};


export type QueryAggregateStakePoolWithdrawalsArgs = {
  cursor?: InputMaybe<StakePoolWithdrawalsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type QueryAggregateStakePoolsArgs = {
  cursor?: InputMaybe<StakePoolsWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StakePoolsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolsWhereInput>;
};


export type QueryAggregateStatesArgs = {
  cursor?: InputMaybe<StatesWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StatesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StatesWhereInput>;
};


export type QueryAggregateWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type QueryAggregateWorkersArgs = {
  cursor?: InputMaybe<WorkersWhereUniqueInput>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};


export type QueryFindFirstAccountStatsArgs = {
  cursor?: InputMaybe<AccountStatsWhereUniqueInput>;
  distinct?: InputMaybe<Array<AccountStatsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AccountStatsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountStatsWhereInput>;
};


export type QueryFindFirstAccountsArgs = {
  cursor?: InputMaybe<AccountsWhereUniqueInput>;
  distinct?: InputMaybe<Array<AccountsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AccountsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountsWhereInput>;
};


export type QueryFindFirstArInternalMetadataArgs = {
  cursor?: InputMaybe<ArInternalMetadataWhereUniqueInput>;
  distinct?: InputMaybe<Array<ArInternalMetadataScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ArInternalMetadataOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ArInternalMetadataWhereInput>;
};


export type QueryFindFirstCalendarDaysArgs = {
  cursor?: InputMaybe<CalendarDaysWhereUniqueInput>;
  distinct?: InputMaybe<Array<CalendarDaysScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<CalendarDaysOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CalendarDaysWhereInput>;
};


export type QueryFindFirstEventsArgs = {
  cursor?: InputMaybe<EventsWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EventsWhereInput>;
};


export type QueryFindFirstMinerActivitiesArgs = {
  cursor?: InputMaybe<MinerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type QueryFindFirstMinerStatsArgs = {
  cursor?: InputMaybe<MinerStatsWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinerStatsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinerStatsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerStatsWhereInput>;
};


export type QueryFindFirstMinersArgs = {
  cursor?: InputMaybe<MinersWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinersWhereInput>;
};


export type QueryFindFirstSchemaMigrationsArgs = {
  cursor?: InputMaybe<SchemaMigrationsWhereUniqueInput>;
  distinct?: InputMaybe<Array<SchemaMigrationsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<SchemaMigrationsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SchemaMigrationsWhereInput>;
};


export type QueryFindFirstStakePoolActivitiesArgs = {
  cursor?: InputMaybe<StakePoolActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type QueryFindFirstStakePoolStakerActivitiesArgs = {
  cursor?: InputMaybe<StakePoolStakerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};


export type QueryFindFirstStakePoolStakersArgs = {
  cursor?: InputMaybe<StakePoolStakersWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type QueryFindFirstStakePoolStatsArgs = {
  cursor?: InputMaybe<StakePoolStatsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStatsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStatsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStatsWhereInput>;
};


export type QueryFindFirstStakePoolWithdrawalsArgs = {
  cursor?: InputMaybe<StakePoolWithdrawalsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolWithdrawalsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type QueryFindFirstStakePoolsArgs = {
  cursor?: InputMaybe<StakePoolsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolsWhereInput>;
};


export type QueryFindFirstStatesArgs = {
  cursor?: InputMaybe<StatesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StatesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StatesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StatesWhereInput>;
};


export type QueryFindFirstWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type QueryFindFirstWorkersArgs = {
  cursor?: InputMaybe<WorkersWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};


export type QueryFindManyAccountStatsArgs = {
  cursor?: InputMaybe<AccountStatsWhereUniqueInput>;
  distinct?: InputMaybe<Array<AccountStatsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AccountStatsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountStatsWhereInput>;
};


export type QueryFindManyAccountsArgs = {
  cursor?: InputMaybe<AccountsWhereUniqueInput>;
  distinct?: InputMaybe<Array<AccountsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AccountsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountsWhereInput>;
};


export type QueryFindManyArInternalMetadataArgs = {
  cursor?: InputMaybe<ArInternalMetadataWhereUniqueInput>;
  distinct?: InputMaybe<Array<ArInternalMetadataScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ArInternalMetadataOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ArInternalMetadataWhereInput>;
};


export type QueryFindManyCalendarDaysArgs = {
  cursor?: InputMaybe<CalendarDaysWhereUniqueInput>;
  distinct?: InputMaybe<Array<CalendarDaysScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<CalendarDaysOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CalendarDaysWhereInput>;
};


export type QueryFindManyEventsArgs = {
  cursor?: InputMaybe<EventsWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EventsWhereInput>;
};


export type QueryFindManyMinerActivitiesArgs = {
  cursor?: InputMaybe<MinerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type QueryFindManyMinerStatsArgs = {
  cursor?: InputMaybe<MinerStatsWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinerStatsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinerStatsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerStatsWhereInput>;
};


export type QueryFindManyMinersArgs = {
  cursor?: InputMaybe<MinersWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinersWhereInput>;
};


export type QueryFindManySchemaMigrationsArgs = {
  cursor?: InputMaybe<SchemaMigrationsWhereUniqueInput>;
  distinct?: InputMaybe<Array<SchemaMigrationsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<SchemaMigrationsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SchemaMigrationsWhereInput>;
};


export type QueryFindManyStakePoolActivitiesArgs = {
  cursor?: InputMaybe<StakePoolActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type QueryFindManyStakePoolStakerActivitiesArgs = {
  cursor?: InputMaybe<StakePoolStakerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};


export type QueryFindManyStakePoolStakersArgs = {
  cursor?: InputMaybe<StakePoolStakersWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type QueryFindManyStakePoolStatsArgs = {
  cursor?: InputMaybe<StakePoolStatsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStatsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStatsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStatsWhereInput>;
};


export type QueryFindManyStakePoolWithdrawalsArgs = {
  cursor?: InputMaybe<StakePoolWithdrawalsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolWithdrawalsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type QueryFindManyStakePoolsArgs = {
  cursor?: InputMaybe<StakePoolsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolsWhereInput>;
};


export type QueryFindManyStatesArgs = {
  cursor?: InputMaybe<StatesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StatesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StatesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StatesWhereInput>;
};


export type QueryFindManyWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type QueryFindManyWorkersArgs = {
  cursor?: InputMaybe<WorkersWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};


export type QueryFindUniqueAccountStatsArgs = {
  where: AccountStatsWhereUniqueInput;
};


export type QueryFindUniqueAccountsArgs = {
  where: AccountsWhereUniqueInput;
};


export type QueryFindUniqueArInternalMetadataArgs = {
  where: ArInternalMetadataWhereUniqueInput;
};


export type QueryFindUniqueCalendarDaysArgs = {
  where: CalendarDaysWhereUniqueInput;
};


export type QueryFindUniqueEventsArgs = {
  where: EventsWhereUniqueInput;
};


export type QueryFindUniqueMinerActivitiesArgs = {
  where: MinerActivitiesWhereUniqueInput;
};


export type QueryFindUniqueMinerStatsArgs = {
  where: MinerStatsWhereUniqueInput;
};


export type QueryFindUniqueMinersArgs = {
  where: MinersWhereUniqueInput;
};


export type QueryFindUniqueSchemaMigrationsArgs = {
  where: SchemaMigrationsWhereUniqueInput;
};


export type QueryFindUniqueStakePoolActivitiesArgs = {
  where: StakePoolActivitiesWhereUniqueInput;
};


export type QueryFindUniqueStakePoolStakerActivitiesArgs = {
  where: StakePoolStakerActivitiesWhereUniqueInput;
};


export type QueryFindUniqueStakePoolStakersArgs = {
  where: StakePoolStakersWhereUniqueInput;
};


export type QueryFindUniqueStakePoolStatsArgs = {
  where: StakePoolStatsWhereUniqueInput;
};


export type QueryFindUniqueStakePoolWithdrawalsArgs = {
  where: StakePoolWithdrawalsWhereUniqueInput;
};


export type QueryFindUniqueStakePoolsArgs = {
  where: StakePoolsWhereUniqueInput;
};


export type QueryFindUniqueStatesArgs = {
  where: StatesWhereUniqueInput;
};


export type QueryFindUniqueWorkerActivitiesArgs = {
  where: WorkerActivitiesWhereUniqueInput;
};


export type QueryFindUniqueWorkersArgs = {
  where: WorkersWhereUniqueInput;
};


export type QueryGroupByAccountStatsArgs = {
  by: Array<AccountStatsScalarFieldEnum>;
  having?: InputMaybe<AccountStatsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<AccountStatsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountStatsWhereInput>;
};


export type QueryGroupByAccountsArgs = {
  by: Array<AccountsScalarFieldEnum>;
  having?: InputMaybe<AccountsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<AccountsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountsWhereInput>;
};


export type QueryGroupByArInternalMetadataArgs = {
  by: Array<ArInternalMetadataScalarFieldEnum>;
  having?: InputMaybe<ArInternalMetadataScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<ArInternalMetadataOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ArInternalMetadataWhereInput>;
};


export type QueryGroupByCalendarDaysArgs = {
  by: Array<CalendarDaysScalarFieldEnum>;
  having?: InputMaybe<CalendarDaysScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<CalendarDaysOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CalendarDaysWhereInput>;
};


export type QueryGroupByEventsArgs = {
  by: Array<EventsScalarFieldEnum>;
  having?: InputMaybe<EventsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<EventsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EventsWhereInput>;
};


export type QueryGroupByMinerActivitiesArgs = {
  by: Array<MinerActivitiesScalarFieldEnum>;
  having?: InputMaybe<MinerActivitiesScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<MinerActivitiesOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerActivitiesWhereInput>;
};


export type QueryGroupByMinerStatsArgs = {
  by: Array<MinerStatsScalarFieldEnum>;
  having?: InputMaybe<MinerStatsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<MinerStatsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinerStatsWhereInput>;
};


export type QueryGroupByMinersArgs = {
  by: Array<MinersScalarFieldEnum>;
  having?: InputMaybe<MinersScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<MinersOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinersWhereInput>;
};


export type QueryGroupBySchemaMigrationsArgs = {
  by: Array<SchemaMigrationsScalarFieldEnum>;
  having?: InputMaybe<SchemaMigrationsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<SchemaMigrationsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SchemaMigrationsWhereInput>;
};


export type QueryGroupByStakePoolActivitiesArgs = {
  by: Array<StakePoolActivitiesScalarFieldEnum>;
  having?: InputMaybe<StakePoolActivitiesScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StakePoolActivitiesOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type QueryGroupByStakePoolStakerActivitiesArgs = {
  by: Array<StakePoolStakerActivitiesScalarFieldEnum>;
  having?: InputMaybe<StakePoolStakerActivitiesScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StakePoolStakerActivitiesOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};


export type QueryGroupByStakePoolStakersArgs = {
  by: Array<StakePoolStakersScalarFieldEnum>;
  having?: InputMaybe<StakePoolStakersScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StakePoolStakersOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type QueryGroupByStakePoolStatsArgs = {
  by: Array<StakePoolStatsScalarFieldEnum>;
  having?: InputMaybe<StakePoolStatsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StakePoolStatsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStatsWhereInput>;
};


export type QueryGroupByStakePoolWithdrawalsArgs = {
  by: Array<StakePoolWithdrawalsScalarFieldEnum>;
  having?: InputMaybe<StakePoolWithdrawalsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type QueryGroupByStakePoolsArgs = {
  by: Array<StakePoolsScalarFieldEnum>;
  having?: InputMaybe<StakePoolsScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StakePoolsOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolsWhereInput>;
};


export type QueryGroupByStatesArgs = {
  by: Array<StatesScalarFieldEnum>;
  having?: InputMaybe<StatesScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StatesOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StatesWhereInput>;
};


export type QueryGroupByWorkerActivitiesArgs = {
  by: Array<WorkerActivitiesScalarFieldEnum>;
  having?: InputMaybe<WorkerActivitiesScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type QueryGroupByWorkersArgs = {
  by: Array<WorkersScalarFieldEnum>;
  having?: InputMaybe<WorkersScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive'
}

export type SchemaMigrations = {
  __typename?: 'SchemaMigrations';
  version: Scalars['String'];
};

export type SchemaMigrationsCountAggregate = {
  __typename?: 'SchemaMigrationsCountAggregate';
  _all: Scalars['Int'];
  version: Scalars['Int'];
};

export type SchemaMigrationsCountOrderByAggregateInput = {
  version?: InputMaybe<SortOrder>;
};

export type SchemaMigrationsGroupBy = {
  __typename?: 'SchemaMigrationsGroupBy';
  _count?: Maybe<SchemaMigrationsCountAggregate>;
  _max?: Maybe<SchemaMigrationsMaxAggregate>;
  _min?: Maybe<SchemaMigrationsMinAggregate>;
  version: Scalars['String'];
};

export type SchemaMigrationsMaxAggregate = {
  __typename?: 'SchemaMigrationsMaxAggregate';
  version?: Maybe<Scalars['String']>;
};

export type SchemaMigrationsMaxOrderByAggregateInput = {
  version?: InputMaybe<SortOrder>;
};

export type SchemaMigrationsMinAggregate = {
  __typename?: 'SchemaMigrationsMinAggregate';
  version?: Maybe<Scalars['String']>;
};

export type SchemaMigrationsMinOrderByAggregateInput = {
  version?: InputMaybe<SortOrder>;
};

export type SchemaMigrationsOrderByWithAggregationInput = {
  _count?: InputMaybe<SchemaMigrationsCountOrderByAggregateInput>;
  _max?: InputMaybe<SchemaMigrationsMaxOrderByAggregateInput>;
  _min?: InputMaybe<SchemaMigrationsMinOrderByAggregateInput>;
  version?: InputMaybe<SortOrder>;
};

export type SchemaMigrationsOrderByWithRelationInput = {
  version?: InputMaybe<SortOrder>;
};

export enum SchemaMigrationsScalarFieldEnum {
  Version = 'version'
}

export type SchemaMigrationsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<SchemaMigrationsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<SchemaMigrationsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<SchemaMigrationsScalarWhereWithAggregatesInput>>;
  version?: InputMaybe<StringWithAggregatesFilter>;
};

export type SchemaMigrationsWhereInput = {
  AND?: InputMaybe<Array<SchemaMigrationsWhereInput>>;
  NOT?: InputMaybe<Array<SchemaMigrationsWhereInput>>;
  OR?: InputMaybe<Array<SchemaMigrationsWhereInput>>;
  version?: InputMaybe<StringFilter>;
};

export type SchemaMigrationsWhereUniqueInput = {
  version?: InputMaybe<Scalars['String']>;
};

export enum SortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type StakePoolActivities = {
  __typename?: 'StakePoolActivities';
  averageBlockTimeSinceLastActivity: Scalars['Float'];
  blockNumber: Scalars['BigInt'];
  cap?: Maybe<Scalars['Decimal']>;
  commission: Scalars['Decimal'];
  coolingDownMinersCount: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  eventId?: Maybe<Scalars['BigInt']>;
  freeStake: Scalars['Decimal'];
  id: Scalars['BigInt'];
  idleMinersCount: Scalars['Int'];
  minersCount: Scalars['Int'];
  ownerReward: Scalars['Decimal'];
  readyMinersCount: Scalars['Int'];
  releasingStake: Scalars['Decimal'];
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakePools: StakePools;
  stakersCount: Scalars['Int'];
  theoreticalApr: Scalars['Decimal'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalShares: Scalars['Decimal'];
  totalStake: Scalars['Decimal'];
  type: Scalars['String'];
  unresponsiveMinersCount: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
  usedStake: Scalars['Decimal'];
  withdrawalsCount: Scalars['Int'];
};

export type StakePoolActivitiesAvgAggregate = {
  __typename?: 'StakePoolActivitiesAvgAggregate';
  averageBlockTimeSinceLastActivity?: Maybe<Scalars['Float']>;
  blockNumber?: Maybe<Scalars['Float']>;
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Float']>;
  eventId?: Maybe<Scalars['Float']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['Float']>;
  idleMinersCount?: Maybe<Scalars['Float']>;
  minersCount?: Maybe<Scalars['Float']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  readyMinersCount?: Maybe<Scalars['Float']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['Float']>;
  stakersCount?: Maybe<Scalars['Float']>;
  theoreticalApr?: Maybe<Scalars['Decimal']>;
  tokenomicVersion?: Maybe<Scalars['Float']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: Maybe<Scalars['Float']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Float']>;
};

export type StakePoolActivitiesAvgOrderByAggregateInput = {
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesCountAggregate = {
  __typename?: 'StakePoolActivitiesCountAggregate';
  _all: Scalars['Int'];
  averageBlockTimeSinceLastActivity: Scalars['Int'];
  blockNumber: Scalars['Int'];
  cap: Scalars['Int'];
  commission: Scalars['Int'];
  coolingDownMinersCount: Scalars['Int'];
  createdAt: Scalars['Int'];
  eventId: Scalars['Int'];
  freeStake: Scalars['Int'];
  id: Scalars['Int'];
  idleMinersCount: Scalars['Int'];
  minersCount: Scalars['Int'];
  ownerReward: Scalars['Int'];
  readyMinersCount: Scalars['Int'];
  releasingStake: Scalars['Int'];
  remainingStake: Scalars['Int'];
  rewardAcc: Scalars['Int'];
  stakePoolId: Scalars['Int'];
  stakersCount: Scalars['Int'];
  theoreticalApr: Scalars['Int'];
  timestamp: Scalars['Int'];
  tokenomicVersion: Scalars['Int'];
  totalShares: Scalars['Int'];
  totalStake: Scalars['Int'];
  type: Scalars['Int'];
  unresponsiveMinersCount: Scalars['Int'];
  updatedAt: Scalars['Int'];
  usedStake: Scalars['Int'];
  withdrawalsCount: Scalars['Int'];
};

export type StakePoolActivitiesCountOrderByAggregateInput = {
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesGroupBy = {
  __typename?: 'StakePoolActivitiesGroupBy';
  _avg?: Maybe<StakePoolActivitiesAvgAggregate>;
  _count?: Maybe<StakePoolActivitiesCountAggregate>;
  _max?: Maybe<StakePoolActivitiesMaxAggregate>;
  _min?: Maybe<StakePoolActivitiesMinAggregate>;
  _sum?: Maybe<StakePoolActivitiesSumAggregate>;
  averageBlockTimeSinceLastActivity: Scalars['Float'];
  blockNumber: Scalars['BigInt'];
  cap?: Maybe<Scalars['Decimal']>;
  commission: Scalars['Decimal'];
  coolingDownMinersCount: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  eventId?: Maybe<Scalars['BigInt']>;
  freeStake: Scalars['Decimal'];
  id: Scalars['BigInt'];
  idleMinersCount: Scalars['Int'];
  minersCount: Scalars['Int'];
  ownerReward: Scalars['Decimal'];
  readyMinersCount: Scalars['Int'];
  releasingStake: Scalars['Decimal'];
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakersCount: Scalars['Int'];
  theoreticalApr: Scalars['Decimal'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  totalShares: Scalars['Decimal'];
  totalStake: Scalars['Decimal'];
  type: Scalars['String'];
  unresponsiveMinersCount: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
  usedStake: Scalars['Decimal'];
  withdrawalsCount: Scalars['Int'];
};

export type StakePoolActivitiesListRelationFilter = {
  every?: InputMaybe<StakePoolActivitiesWhereInput>;
  none?: InputMaybe<StakePoolActivitiesWhereInput>;
  some?: InputMaybe<StakePoolActivitiesWhereInput>;
};

export type StakePoolActivitiesMaxAggregate = {
  __typename?: 'StakePoolActivitiesMaxAggregate';
  averageBlockTimeSinceLastActivity?: Maybe<Scalars['Float']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  idleMinersCount?: Maybe<Scalars['Int']>;
  minersCount?: Maybe<Scalars['Int']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  readyMinersCount?: Maybe<Scalars['Int']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakersCount?: Maybe<Scalars['Int']>;
  theoreticalApr?: Maybe<Scalars['Decimal']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  type?: Maybe<Scalars['String']>;
  unresponsiveMinersCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Int']>;
};

export type StakePoolActivitiesMaxOrderByAggregateInput = {
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesMinAggregate = {
  __typename?: 'StakePoolActivitiesMinAggregate';
  averageBlockTimeSinceLastActivity?: Maybe<Scalars['Float']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  idleMinersCount?: Maybe<Scalars['Int']>;
  minersCount?: Maybe<Scalars['Int']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  readyMinersCount?: Maybe<Scalars['Int']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakersCount?: Maybe<Scalars['Int']>;
  theoreticalApr?: Maybe<Scalars['Decimal']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  type?: Maybe<Scalars['String']>;
  unresponsiveMinersCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Int']>;
};

export type StakePoolActivitiesMinOrderByAggregateInput = {
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesOrderByWithAggregationInput = {
  _avg?: InputMaybe<StakePoolActivitiesAvgOrderByAggregateInput>;
  _count?: InputMaybe<StakePoolActivitiesCountOrderByAggregateInput>;
  _max?: InputMaybe<StakePoolActivitiesMaxOrderByAggregateInput>;
  _min?: InputMaybe<StakePoolActivitiesMinOrderByAggregateInput>;
  _sum?: InputMaybe<StakePoolActivitiesSumOrderByAggregateInput>;
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesOrderByWithRelationInput = {
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export enum StakePoolActivitiesScalarFieldEnum {
  AverageBlockTimeSinceLastActivity = 'averageBlockTimeSinceLastActivity',
  BlockNumber = 'blockNumber',
  Cap = 'cap',
  Commission = 'commission',
  CoolingDownMinersCount = 'coolingDownMinersCount',
  CreatedAt = 'createdAt',
  EventId = 'eventId',
  FreeStake = 'freeStake',
  Id = 'id',
  IdleMinersCount = 'idleMinersCount',
  MinersCount = 'minersCount',
  OwnerReward = 'ownerReward',
  ReadyMinersCount = 'readyMinersCount',
  ReleasingStake = 'releasingStake',
  RemainingStake = 'remainingStake',
  RewardAcc = 'rewardAcc',
  StakePoolId = 'stakePoolId',
  StakersCount = 'stakersCount',
  TheoreticalApr = 'theoreticalApr',
  Timestamp = 'timestamp',
  TokenomicVersion = 'tokenomicVersion',
  TotalShares = 'totalShares',
  TotalStake = 'totalStake',
  Type = 'type',
  UnresponsiveMinersCount = 'unresponsiveMinersCount',
  UpdatedAt = 'updatedAt',
  UsedStake = 'usedStake',
  WithdrawalsCount = 'withdrawalsCount'
}

export type StakePoolActivitiesScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StakePoolActivitiesScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StakePoolActivitiesScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StakePoolActivitiesScalarWhereWithAggregatesInput>>;
  averageBlockTimeSinceLastActivity?: InputMaybe<FloatWithAggregatesFilter>;
  blockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  cap?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  commission?: InputMaybe<DecimalWithAggregatesFilter>;
  coolingDownMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  eventId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  freeStake?: InputMaybe<DecimalWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  idleMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  minersCount?: InputMaybe<IntWithAggregatesFilter>;
  ownerReward?: InputMaybe<DecimalWithAggregatesFilter>;
  readyMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  releasingStake?: InputMaybe<DecimalWithAggregatesFilter>;
  remainingStake?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  rewardAcc?: InputMaybe<DecimalWithAggregatesFilter>;
  stakePoolId?: InputMaybe<BigIntWithAggregatesFilter>;
  stakersCount?: InputMaybe<IntWithAggregatesFilter>;
  theoreticalApr?: InputMaybe<DecimalWithAggregatesFilter>;
  timestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  tokenomicVersion?: InputMaybe<IntWithAggregatesFilter>;
  totalShares?: InputMaybe<DecimalWithAggregatesFilter>;
  totalStake?: InputMaybe<DecimalWithAggregatesFilter>;
  type?: InputMaybe<StringWithAggregatesFilter>;
  unresponsiveMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  usedStake?: InputMaybe<DecimalWithAggregatesFilter>;
  withdrawalsCount?: InputMaybe<IntWithAggregatesFilter>;
};

export type StakePoolActivitiesSumAggregate = {
  __typename?: 'StakePoolActivitiesSumAggregate';
  averageBlockTimeSinceLastActivity?: Maybe<Scalars['Float']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Int']>;
  eventId?: Maybe<Scalars['BigInt']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  idleMinersCount?: Maybe<Scalars['Int']>;
  minersCount?: Maybe<Scalars['Int']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  readyMinersCount?: Maybe<Scalars['Int']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakersCount?: Maybe<Scalars['Int']>;
  theoreticalApr?: Maybe<Scalars['Decimal']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: Maybe<Scalars['Int']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Int']>;
};

export type StakePoolActivitiesSumOrderByAggregateInput = {
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
};

export type StakePoolActivitiesWhereInput = {
  AND?: InputMaybe<Array<StakePoolActivitiesWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolActivitiesWhereInput>>;
  OR?: InputMaybe<Array<StakePoolActivitiesWhereInput>>;
  averageBlockTimeSinceLastActivity?: InputMaybe<FloatFilter>;
  blockNumber?: InputMaybe<BigIntFilter>;
  cap?: InputMaybe<DecimalNullableFilter>;
  commission?: InputMaybe<DecimalFilter>;
  coolingDownMinersCount?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  eventId?: InputMaybe<BigIntNullableFilter>;
  freeStake?: InputMaybe<DecimalFilter>;
  id?: InputMaybe<BigIntFilter>;
  idleMinersCount?: InputMaybe<IntFilter>;
  minersCount?: InputMaybe<IntFilter>;
  ownerReward?: InputMaybe<DecimalFilter>;
  readyMinersCount?: InputMaybe<IntFilter>;
  releasingStake?: InputMaybe<DecimalFilter>;
  remainingStake?: InputMaybe<DecimalNullableFilter>;
  rewardAcc?: InputMaybe<DecimalFilter>;
  stakePoolId?: InputMaybe<BigIntFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  stakersCount?: InputMaybe<IntFilter>;
  theoreticalApr?: InputMaybe<DecimalFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  totalShares?: InputMaybe<DecimalFilter>;
  totalStake?: InputMaybe<DecimalFilter>;
  type?: InputMaybe<StringFilter>;
  unresponsiveMinersCount?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  usedStake?: InputMaybe<DecimalFilter>;
  withdrawalsCount?: InputMaybe<IntFilter>;
};

export type StakePoolActivitiesWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type StakePoolStakerActivities = {
  __typename?: 'StakePoolStakerActivities';
  availableReward: Scalars['Decimal'];
  blockNumber: Scalars['BigInt'];
  claimableReward: Scalars['Decimal'];
  createdAt: Scalars['DateTime'];
  eventId?: Maybe<Scalars['BigInt']>;
  id: Scalars['BigInt'];
  instantClaimableReward: Scalars['Decimal'];
  locked: Scalars['Decimal'];
  pendingReward: Scalars['Decimal'];
  rewardDebt: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stake: Scalars['Decimal'];
  stakePoolStakerId: Scalars['BigInt'];
  stakePoolStakers: StakePoolStakers;
  stakeReward: Scalars['Decimal'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakerActivitiesAvgAggregate = {
  __typename?: 'StakePoolStakerActivitiesAvgAggregate';
  availableReward?: Maybe<Scalars['Decimal']>;
  blockNumber?: Maybe<Scalars['Float']>;
  claimableReward?: Maybe<Scalars['Decimal']>;
  eventId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  instantClaimableReward?: Maybe<Scalars['Decimal']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingReward?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolStakerId?: Maybe<Scalars['Float']>;
  stakeReward?: Maybe<Scalars['Decimal']>;
  tokenomicVersion?: Maybe<Scalars['Float']>;
};

export type StakePoolStakerActivitiesAvgOrderByAggregateInput = {
  availableReward?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakeReward?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesCountAggregate = {
  __typename?: 'StakePoolStakerActivitiesCountAggregate';
  _all: Scalars['Int'];
  availableReward: Scalars['Int'];
  blockNumber: Scalars['Int'];
  claimableReward: Scalars['Int'];
  createdAt: Scalars['Int'];
  eventId: Scalars['Int'];
  id: Scalars['Int'];
  instantClaimableReward: Scalars['Int'];
  locked: Scalars['Int'];
  pendingReward: Scalars['Int'];
  rewardDebt: Scalars['Int'];
  shares: Scalars['Int'];
  stake: Scalars['Int'];
  stakePoolStakerId: Scalars['Int'];
  stakeReward: Scalars['Int'];
  timestamp: Scalars['Int'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['Int'];
  updatedAt: Scalars['Int'];
};

export type StakePoolStakerActivitiesCountOrderByAggregateInput = {
  availableReward?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakeReward?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesGroupBy = {
  __typename?: 'StakePoolStakerActivitiesGroupBy';
  _avg?: Maybe<StakePoolStakerActivitiesAvgAggregate>;
  _count?: Maybe<StakePoolStakerActivitiesCountAggregate>;
  _max?: Maybe<StakePoolStakerActivitiesMaxAggregate>;
  _min?: Maybe<StakePoolStakerActivitiesMinAggregate>;
  _sum?: Maybe<StakePoolStakerActivitiesSumAggregate>;
  availableReward: Scalars['Decimal'];
  blockNumber: Scalars['BigInt'];
  claimableReward: Scalars['Decimal'];
  createdAt: Scalars['DateTime'];
  eventId?: Maybe<Scalars['BigInt']>;
  id: Scalars['BigInt'];
  instantClaimableReward: Scalars['Decimal'];
  locked: Scalars['Decimal'];
  pendingReward: Scalars['Decimal'];
  rewardDebt: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stake: Scalars['Decimal'];
  stakePoolStakerId: Scalars['BigInt'];
  stakeReward: Scalars['Decimal'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStakerActivitiesListRelationFilter = {
  every?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
  none?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
  some?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};

export type StakePoolStakerActivitiesMaxAggregate = {
  __typename?: 'StakePoolStakerActivitiesMaxAggregate';
  availableReward?: Maybe<Scalars['Decimal']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  claimableReward?: Maybe<Scalars['Decimal']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  instantClaimableReward?: Maybe<Scalars['Decimal']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingReward?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolStakerId?: Maybe<Scalars['BigInt']>;
  stakeReward?: Maybe<Scalars['Decimal']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StakePoolStakerActivitiesMaxOrderByAggregateInput = {
  availableReward?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakeReward?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesMinAggregate = {
  __typename?: 'StakePoolStakerActivitiesMinAggregate';
  availableReward?: Maybe<Scalars['Decimal']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  claimableReward?: Maybe<Scalars['Decimal']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  instantClaimableReward?: Maybe<Scalars['Decimal']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingReward?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolStakerId?: Maybe<Scalars['BigInt']>;
  stakeReward?: Maybe<Scalars['Decimal']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StakePoolStakerActivitiesMinOrderByAggregateInput = {
  availableReward?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakeReward?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesOrderByWithAggregationInput = {
  _avg?: InputMaybe<StakePoolStakerActivitiesAvgOrderByAggregateInput>;
  _count?: InputMaybe<StakePoolStakerActivitiesCountOrderByAggregateInput>;
  _max?: InputMaybe<StakePoolStakerActivitiesMaxOrderByAggregateInput>;
  _min?: InputMaybe<StakePoolStakerActivitiesMinOrderByAggregateInput>;
  _sum?: InputMaybe<StakePoolStakerActivitiesSumOrderByAggregateInput>;
  availableReward?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakeReward?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesOrderByWithRelationInput = {
  availableReward?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakePoolStakers?: InputMaybe<StakePoolStakersOrderByWithRelationInput>;
  stakeReward?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum StakePoolStakerActivitiesScalarFieldEnum {
  AvailableReward = 'availableReward',
  BlockNumber = 'blockNumber',
  ClaimableReward = 'claimableReward',
  CreatedAt = 'createdAt',
  EventId = 'eventId',
  Id = 'id',
  InstantClaimableReward = 'instantClaimableReward',
  Locked = 'locked',
  PendingReward = 'pendingReward',
  RewardDebt = 'rewardDebt',
  Shares = 'shares',
  Stake = 'stake',
  StakePoolStakerId = 'stakePoolStakerId',
  StakeReward = 'stakeReward',
  Timestamp = 'timestamp',
  TokenomicVersion = 'tokenomicVersion',
  Type = 'type',
  UpdatedAt = 'updatedAt'
}

export type StakePoolStakerActivitiesScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StakePoolStakerActivitiesScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StakePoolStakerActivitiesScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StakePoolStakerActivitiesScalarWhereWithAggregatesInput>>;
  availableReward?: InputMaybe<DecimalWithAggregatesFilter>;
  blockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  claimableReward?: InputMaybe<DecimalWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  eventId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  instantClaimableReward?: InputMaybe<DecimalWithAggregatesFilter>;
  locked?: InputMaybe<DecimalWithAggregatesFilter>;
  pendingReward?: InputMaybe<DecimalWithAggregatesFilter>;
  rewardDebt?: InputMaybe<DecimalWithAggregatesFilter>;
  shares?: InputMaybe<DecimalWithAggregatesFilter>;
  stake?: InputMaybe<DecimalWithAggregatesFilter>;
  stakePoolStakerId?: InputMaybe<BigIntWithAggregatesFilter>;
  stakeReward?: InputMaybe<DecimalWithAggregatesFilter>;
  timestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  tokenomicVersion?: InputMaybe<IntWithAggregatesFilter>;
  type?: InputMaybe<StringWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type StakePoolStakerActivitiesSumAggregate = {
  __typename?: 'StakePoolStakerActivitiesSumAggregate';
  availableReward?: Maybe<Scalars['Decimal']>;
  blockNumber?: Maybe<Scalars['BigInt']>;
  claimableReward?: Maybe<Scalars['Decimal']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  instantClaimableReward?: Maybe<Scalars['Decimal']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingReward?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolStakerId?: Maybe<Scalars['BigInt']>;
  stakeReward?: Maybe<Scalars['Decimal']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
};

export type StakePoolStakerActivitiesSumOrderByAggregateInput = {
  availableReward?: InputMaybe<SortOrder>;
  blockNumber?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolStakerId?: InputMaybe<SortOrder>;
  stakeReward?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
};

export type StakePoolStakerActivitiesWhereInput = {
  AND?: InputMaybe<Array<StakePoolStakerActivitiesWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolStakerActivitiesWhereInput>>;
  OR?: InputMaybe<Array<StakePoolStakerActivitiesWhereInput>>;
  availableReward?: InputMaybe<DecimalFilter>;
  blockNumber?: InputMaybe<BigIntFilter>;
  claimableReward?: InputMaybe<DecimalFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  eventId?: InputMaybe<BigIntNullableFilter>;
  id?: InputMaybe<BigIntFilter>;
  instantClaimableReward?: InputMaybe<DecimalFilter>;
  locked?: InputMaybe<DecimalFilter>;
  pendingReward?: InputMaybe<DecimalFilter>;
  rewardDebt?: InputMaybe<DecimalFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stake?: InputMaybe<DecimalFilter>;
  stakePoolStakerId?: InputMaybe<BigIntFilter>;
  stakePoolStakers?: InputMaybe<StakePoolStakersRelationFilter>;
  stakeReward?: InputMaybe<DecimalFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type StakePoolStakerActivitiesWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type StakePoolStakers = {
  __typename?: 'StakePoolStakers';
  _count?: Maybe<StakePoolStakersCount>;
  accounts: Accounts;
  address?: Maybe<Scalars['String']>;
  availableReward: Scalars['Decimal'];
  claimableReward: Scalars['Decimal'];
  createdAt: Scalars['DateTime'];
  id: Scalars['BigInt'];
  instantClaimableReward: Scalars['Decimal'];
  isOwner: Scalars['Boolean'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  locked: Scalars['Decimal'];
  pendingReward: Scalars['Decimal'];
  rewardDebt: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stake: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakePoolStakerActivities: Array<StakePoolStakerActivities>;
  stakePools: StakePools;
  stakeReward: Scalars['Decimal'];
  updatedAt: Scalars['DateTime'];
  userId: Scalars['BigInt'];
};


export type StakePoolStakersStakePoolStakerActivitiesArgs = {
  cursor?: InputMaybe<StakePoolStakerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakerActivitiesWhereInput>;
};

export type StakePoolStakersAvgAggregate = {
  __typename?: 'StakePoolStakersAvgAggregate';
  availableReward?: Maybe<Scalars['Decimal']>;
  claimableReward?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['Float']>;
  instantClaimableReward?: Maybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingReward?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['Float']>;
  stakeReward?: Maybe<Scalars['Decimal']>;
  userId?: Maybe<Scalars['Float']>;
};

export type StakePoolStakersAvgOrderByAggregateInput = {
  availableReward?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakeReward?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersCount = {
  __typename?: 'StakePoolStakersCount';
  stakePoolStakerActivities: Scalars['Int'];
};

export type StakePoolStakersCountAggregate = {
  __typename?: 'StakePoolStakersCountAggregate';
  _all: Scalars['Int'];
  address: Scalars['Int'];
  availableReward: Scalars['Int'];
  claimableReward: Scalars['Int'];
  createdAt: Scalars['Int'];
  id: Scalars['Int'];
  instantClaimableReward: Scalars['Int'];
  isOwner: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['Int'];
  lastUpdatedTimestamp: Scalars['Int'];
  locked: Scalars['Int'];
  pendingReward: Scalars['Int'];
  rewardDebt: Scalars['Int'];
  shares: Scalars['Int'];
  stake: Scalars['Int'];
  stakePoolId: Scalars['Int'];
  stakeReward: Scalars['Int'];
  updatedAt: Scalars['Int'];
  userId: Scalars['Int'];
};

export type StakePoolStakersCountOrderByAggregateInput = {
  address?: InputMaybe<SortOrder>;
  availableReward?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  isOwner?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakeReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersGroupBy = {
  __typename?: 'StakePoolStakersGroupBy';
  _avg?: Maybe<StakePoolStakersAvgAggregate>;
  _count?: Maybe<StakePoolStakersCountAggregate>;
  _max?: Maybe<StakePoolStakersMaxAggregate>;
  _min?: Maybe<StakePoolStakersMinAggregate>;
  _sum?: Maybe<StakePoolStakersSumAggregate>;
  address?: Maybe<Scalars['String']>;
  availableReward: Scalars['Decimal'];
  claimableReward: Scalars['Decimal'];
  createdAt: Scalars['DateTime'];
  id: Scalars['BigInt'];
  instantClaimableReward: Scalars['Decimal'];
  isOwner: Scalars['Boolean'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  locked: Scalars['Decimal'];
  pendingReward: Scalars['Decimal'];
  rewardDebt: Scalars['Decimal'];
  shares: Scalars['Decimal'];
  stake: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakeReward: Scalars['Decimal'];
  updatedAt: Scalars['DateTime'];
  userId: Scalars['BigInt'];
};

export type StakePoolStakersListRelationFilter = {
  every?: InputMaybe<StakePoolStakersWhereInput>;
  none?: InputMaybe<StakePoolStakersWhereInput>;
  some?: InputMaybe<StakePoolStakersWhereInput>;
};

export type StakePoolStakersMaxAggregate = {
  __typename?: 'StakePoolStakersMaxAggregate';
  address?: Maybe<Scalars['String']>;
  availableReward?: Maybe<Scalars['Decimal']>;
  claimableReward?: Maybe<Scalars['Decimal']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  instantClaimableReward?: Maybe<Scalars['Decimal']>;
  isOwner?: Maybe<Scalars['Boolean']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingReward?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakeReward?: Maybe<Scalars['Decimal']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolStakersMaxOrderByAggregateInput = {
  address?: InputMaybe<SortOrder>;
  availableReward?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  isOwner?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakeReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersMinAggregate = {
  __typename?: 'StakePoolStakersMinAggregate';
  address?: Maybe<Scalars['String']>;
  availableReward?: Maybe<Scalars['Decimal']>;
  claimableReward?: Maybe<Scalars['Decimal']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  instantClaimableReward?: Maybe<Scalars['Decimal']>;
  isOwner?: Maybe<Scalars['Boolean']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingReward?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakeReward?: Maybe<Scalars['Decimal']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolStakersMinOrderByAggregateInput = {
  address?: InputMaybe<SortOrder>;
  availableReward?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  isOwner?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakeReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StakePoolStakersOrderByWithAggregationInput = {
  _avg?: InputMaybe<StakePoolStakersAvgOrderByAggregateInput>;
  _count?: InputMaybe<StakePoolStakersCountOrderByAggregateInput>;
  _max?: InputMaybe<StakePoolStakersMaxOrderByAggregateInput>;
  _min?: InputMaybe<StakePoolStakersMinOrderByAggregateInput>;
  _sum?: InputMaybe<StakePoolStakersSumOrderByAggregateInput>;
  address?: InputMaybe<SortOrder>;
  availableReward?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  isOwner?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakeReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersOrderByWithRelationInput = {
  accounts?: InputMaybe<AccountsOrderByWithRelationInput>;
  address?: InputMaybe<SortOrder>;
  availableReward?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  isOwner?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesOrderByRelationAggregateInput>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  stakeReward?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersRelationFilter = {
  is?: InputMaybe<StakePoolStakersWhereInput>;
  isNot?: InputMaybe<StakePoolStakersWhereInput>;
};

export enum StakePoolStakersScalarFieldEnum {
  Address = 'address',
  AvailableReward = 'availableReward',
  ClaimableReward = 'claimableReward',
  CreatedAt = 'createdAt',
  Id = 'id',
  InstantClaimableReward = 'instantClaimableReward',
  IsOwner = 'isOwner',
  LastUpdatedBlockNumber = 'lastUpdatedBlockNumber',
  LastUpdatedTimestamp = 'lastUpdatedTimestamp',
  Locked = 'locked',
  PendingReward = 'pendingReward',
  RewardDebt = 'rewardDebt',
  Shares = 'shares',
  Stake = 'stake',
  StakePoolId = 'stakePoolId',
  StakeReward = 'stakeReward',
  UpdatedAt = 'updatedAt',
  UserId = 'userId'
}

export type StakePoolStakersScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StakePoolStakersScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StakePoolStakersScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StakePoolStakersScalarWhereWithAggregatesInput>>;
  address?: InputMaybe<StringNullableWithAggregatesFilter>;
  availableReward?: InputMaybe<DecimalWithAggregatesFilter>;
  claimableReward?: InputMaybe<DecimalWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  instantClaimableReward?: InputMaybe<DecimalWithAggregatesFilter>;
  isOwner?: InputMaybe<BoolWithAggregatesFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  locked?: InputMaybe<DecimalWithAggregatesFilter>;
  pendingReward?: InputMaybe<DecimalWithAggregatesFilter>;
  rewardDebt?: InputMaybe<DecimalWithAggregatesFilter>;
  shares?: InputMaybe<DecimalWithAggregatesFilter>;
  stake?: InputMaybe<DecimalWithAggregatesFilter>;
  stakePoolId?: InputMaybe<BigIntWithAggregatesFilter>;
  stakeReward?: InputMaybe<DecimalWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  userId?: InputMaybe<BigIntWithAggregatesFilter>;
};

export type StakePoolStakersSumAggregate = {
  __typename?: 'StakePoolStakersSumAggregate';
  availableReward?: Maybe<Scalars['Decimal']>;
  claimableReward?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  instantClaimableReward?: Maybe<Scalars['Decimal']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  locked?: Maybe<Scalars['Decimal']>;
  pendingReward?: Maybe<Scalars['Decimal']>;
  rewardDebt?: Maybe<Scalars['Decimal']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakeReward?: Maybe<Scalars['Decimal']>;
  userId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolStakersSumOrderByAggregateInput = {
  availableReward?: InputMaybe<SortOrder>;
  claimableReward?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  instantClaimableReward?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  locked?: InputMaybe<SortOrder>;
  pendingReward?: InputMaybe<SortOrder>;
  rewardDebt?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakeReward?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolStakersWhereInput = {
  AND?: InputMaybe<Array<StakePoolStakersWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolStakersWhereInput>>;
  OR?: InputMaybe<Array<StakePoolStakersWhereInput>>;
  accounts?: InputMaybe<AccountsRelationFilter>;
  address?: InputMaybe<StringNullableFilter>;
  availableReward?: InputMaybe<DecimalFilter>;
  claimableReward?: InputMaybe<DecimalFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<BigIntFilter>;
  instantClaimableReward?: InputMaybe<DecimalFilter>;
  isOwner?: InputMaybe<BoolFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  locked?: InputMaybe<DecimalFilter>;
  pendingReward?: InputMaybe<DecimalFilter>;
  rewardDebt?: InputMaybe<DecimalFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stake?: InputMaybe<DecimalFilter>;
  stakePoolId?: InputMaybe<BigIntFilter>;
  stakePoolStakerActivities?: InputMaybe<StakePoolStakerActivitiesListRelationFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  stakeReward?: InputMaybe<DecimalFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  userId?: InputMaybe<BigIntFilter>;
};

export type StakePoolStakersWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type StakePoolStats = {
  __typename?: 'StakePoolStats';
  accumulatedReward: Scalars['Decimal'];
  commission?: Maybe<Scalars['Decimal']>;
  commissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  commissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  createdAt: Scalars['DateTime'];
  highestCommission?: Maybe<Scalars['Decimal']>;
  highestCommissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  highestCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  id: Scalars['BigInt'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  lowestCommission?: Maybe<Scalars['Decimal']>;
  lowestCommissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  lowestCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  pid: Scalars['Int'];
  previousCommission?: Maybe<Scalars['Decimal']>;
  previousCommissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  previousCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  recentReward: Scalars['Decimal'];
  recentStartedBlockNumber: Scalars['BigInt'];
  recentStartedTimestamp: Scalars['DateTime'];
  stakePoolId?: Maybe<Scalars['BigInt']>;
  stakePools?: Maybe<StakePools>;
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStatsAvgAggregate = {
  __typename?: 'StakePoolStatsAvgAggregate';
  accumulatedReward?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  commissionUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  highestCommission?: Maybe<Scalars['Decimal']>;
  highestCommissionUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  lowestCommission?: Maybe<Scalars['Decimal']>;
  lowestCommissionUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  pid?: Maybe<Scalars['Float']>;
  previousCommission?: Maybe<Scalars['Decimal']>;
  previousCommissionUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  recentReward?: Maybe<Scalars['Decimal']>;
  recentStartedBlockNumber?: Maybe<Scalars['Float']>;
  stakePoolId?: Maybe<Scalars['Float']>;
};

export type StakePoolStatsAvgOrderByAggregateInput = {
  accumulatedReward?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  commissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  highestCommission?: InputMaybe<SortOrder>;
  highestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lowestCommission?: InputMaybe<SortOrder>;
  lowestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  previousCommission?: InputMaybe<SortOrder>;
  previousCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  recentReward?: InputMaybe<SortOrder>;
  recentStartedBlockNumber?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
};

export type StakePoolStatsCountAggregate = {
  __typename?: 'StakePoolStatsCountAggregate';
  _all: Scalars['Int'];
  accumulatedReward: Scalars['Int'];
  commission: Scalars['Int'];
  commissionUpdatedAt: Scalars['Int'];
  commissionUpdatedBlockNumber: Scalars['Int'];
  createdAt: Scalars['Int'];
  highestCommission: Scalars['Int'];
  highestCommissionUpdatedAt: Scalars['Int'];
  highestCommissionUpdatedBlockNumber: Scalars['Int'];
  id: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['Int'];
  lastUpdatedTimestamp: Scalars['Int'];
  lowestCommission: Scalars['Int'];
  lowestCommissionUpdatedAt: Scalars['Int'];
  lowestCommissionUpdatedBlockNumber: Scalars['Int'];
  pid: Scalars['Int'];
  previousCommission: Scalars['Int'];
  previousCommissionUpdatedAt: Scalars['Int'];
  previousCommissionUpdatedBlockNumber: Scalars['Int'];
  recentReward: Scalars['Int'];
  recentStartedBlockNumber: Scalars['Int'];
  recentStartedTimestamp: Scalars['Int'];
  stakePoolId: Scalars['Int'];
  updatedAt: Scalars['Int'];
};

export type StakePoolStatsCountOrderByAggregateInput = {
  accumulatedReward?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  commissionUpdatedAt?: InputMaybe<SortOrder>;
  commissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  highestCommission?: InputMaybe<SortOrder>;
  highestCommissionUpdatedAt?: InputMaybe<SortOrder>;
  highestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  lowestCommission?: InputMaybe<SortOrder>;
  lowestCommissionUpdatedAt?: InputMaybe<SortOrder>;
  lowestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  previousCommission?: InputMaybe<SortOrder>;
  previousCommissionUpdatedAt?: InputMaybe<SortOrder>;
  previousCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  recentReward?: InputMaybe<SortOrder>;
  recentStartedBlockNumber?: InputMaybe<SortOrder>;
  recentStartedTimestamp?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StakePoolStatsGroupBy = {
  __typename?: 'StakePoolStatsGroupBy';
  _avg?: Maybe<StakePoolStatsAvgAggregate>;
  _count?: Maybe<StakePoolStatsCountAggregate>;
  _max?: Maybe<StakePoolStatsMaxAggregate>;
  _min?: Maybe<StakePoolStatsMinAggregate>;
  _sum?: Maybe<StakePoolStatsSumAggregate>;
  accumulatedReward: Scalars['Decimal'];
  commission?: Maybe<Scalars['Decimal']>;
  commissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  commissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  createdAt: Scalars['DateTime'];
  highestCommission?: Maybe<Scalars['Decimal']>;
  highestCommissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  highestCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  id: Scalars['BigInt'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  lowestCommission?: Maybe<Scalars['Decimal']>;
  lowestCommissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  lowestCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  pid: Scalars['Int'];
  previousCommission?: Maybe<Scalars['Decimal']>;
  previousCommissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  previousCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  recentReward: Scalars['Decimal'];
  recentStartedBlockNumber: Scalars['BigInt'];
  recentStartedTimestamp: Scalars['DateTime'];
  stakePoolId?: Maybe<Scalars['BigInt']>;
  updatedAt: Scalars['DateTime'];
};

export type StakePoolStatsListRelationFilter = {
  every?: InputMaybe<StakePoolStatsWhereInput>;
  none?: InputMaybe<StakePoolStatsWhereInput>;
  some?: InputMaybe<StakePoolStatsWhereInput>;
};

export type StakePoolStatsMaxAggregate = {
  __typename?: 'StakePoolStatsMaxAggregate';
  accumulatedReward?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  commissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  commissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  highestCommission?: Maybe<Scalars['Decimal']>;
  highestCommissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  highestCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  lowestCommission?: Maybe<Scalars['Decimal']>;
  lowestCommissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  lowestCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  pid?: Maybe<Scalars['Int']>;
  previousCommission?: Maybe<Scalars['Decimal']>;
  previousCommissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  previousCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  recentReward?: Maybe<Scalars['Decimal']>;
  recentStartedBlockNumber?: Maybe<Scalars['BigInt']>;
  recentStartedTimestamp?: Maybe<Scalars['DateTime']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StakePoolStatsMaxOrderByAggregateInput = {
  accumulatedReward?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  commissionUpdatedAt?: InputMaybe<SortOrder>;
  commissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  highestCommission?: InputMaybe<SortOrder>;
  highestCommissionUpdatedAt?: InputMaybe<SortOrder>;
  highestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  lowestCommission?: InputMaybe<SortOrder>;
  lowestCommissionUpdatedAt?: InputMaybe<SortOrder>;
  lowestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  previousCommission?: InputMaybe<SortOrder>;
  previousCommissionUpdatedAt?: InputMaybe<SortOrder>;
  previousCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  recentReward?: InputMaybe<SortOrder>;
  recentStartedBlockNumber?: InputMaybe<SortOrder>;
  recentStartedTimestamp?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StakePoolStatsMinAggregate = {
  __typename?: 'StakePoolStatsMinAggregate';
  accumulatedReward?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  commissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  commissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  highestCommission?: Maybe<Scalars['Decimal']>;
  highestCommissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  highestCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  lowestCommission?: Maybe<Scalars['Decimal']>;
  lowestCommissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  lowestCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  pid?: Maybe<Scalars['Int']>;
  previousCommission?: Maybe<Scalars['Decimal']>;
  previousCommissionUpdatedAt?: Maybe<Scalars['DateTime']>;
  previousCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  recentReward?: Maybe<Scalars['Decimal']>;
  recentStartedBlockNumber?: Maybe<Scalars['BigInt']>;
  recentStartedTimestamp?: Maybe<Scalars['DateTime']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StakePoolStatsMinOrderByAggregateInput = {
  accumulatedReward?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  commissionUpdatedAt?: InputMaybe<SortOrder>;
  commissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  highestCommission?: InputMaybe<SortOrder>;
  highestCommissionUpdatedAt?: InputMaybe<SortOrder>;
  highestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  lowestCommission?: InputMaybe<SortOrder>;
  lowestCommissionUpdatedAt?: InputMaybe<SortOrder>;
  lowestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  previousCommission?: InputMaybe<SortOrder>;
  previousCommissionUpdatedAt?: InputMaybe<SortOrder>;
  previousCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  recentReward?: InputMaybe<SortOrder>;
  recentStartedBlockNumber?: InputMaybe<SortOrder>;
  recentStartedTimestamp?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StakePoolStatsOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StakePoolStatsOrderByWithAggregationInput = {
  _avg?: InputMaybe<StakePoolStatsAvgOrderByAggregateInput>;
  _count?: InputMaybe<StakePoolStatsCountOrderByAggregateInput>;
  _max?: InputMaybe<StakePoolStatsMaxOrderByAggregateInput>;
  _min?: InputMaybe<StakePoolStatsMinOrderByAggregateInput>;
  _sum?: InputMaybe<StakePoolStatsSumOrderByAggregateInput>;
  accumulatedReward?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  commissionUpdatedAt?: InputMaybe<SortOrder>;
  commissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  highestCommission?: InputMaybe<SortOrder>;
  highestCommissionUpdatedAt?: InputMaybe<SortOrder>;
  highestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  lowestCommission?: InputMaybe<SortOrder>;
  lowestCommissionUpdatedAt?: InputMaybe<SortOrder>;
  lowestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  previousCommission?: InputMaybe<SortOrder>;
  previousCommissionUpdatedAt?: InputMaybe<SortOrder>;
  previousCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  recentReward?: InputMaybe<SortOrder>;
  recentStartedBlockNumber?: InputMaybe<SortOrder>;
  recentStartedTimestamp?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StakePoolStatsOrderByWithRelationInput = {
  accumulatedReward?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  commissionUpdatedAt?: InputMaybe<SortOrder>;
  commissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  highestCommission?: InputMaybe<SortOrder>;
  highestCommissionUpdatedAt?: InputMaybe<SortOrder>;
  highestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  lowestCommission?: InputMaybe<SortOrder>;
  lowestCommissionUpdatedAt?: InputMaybe<SortOrder>;
  lowestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  previousCommission?: InputMaybe<SortOrder>;
  previousCommissionUpdatedAt?: InputMaybe<SortOrder>;
  previousCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  recentReward?: InputMaybe<SortOrder>;
  recentStartedBlockNumber?: InputMaybe<SortOrder>;
  recentStartedTimestamp?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum StakePoolStatsScalarFieldEnum {
  AccumulatedReward = 'accumulatedReward',
  Commission = 'commission',
  CommissionUpdatedAt = 'commissionUpdatedAt',
  CommissionUpdatedBlockNumber = 'commissionUpdatedBlockNumber',
  CreatedAt = 'createdAt',
  HighestCommission = 'highestCommission',
  HighestCommissionUpdatedAt = 'highestCommissionUpdatedAt',
  HighestCommissionUpdatedBlockNumber = 'highestCommissionUpdatedBlockNumber',
  Id = 'id',
  LastUpdatedBlockNumber = 'lastUpdatedBlockNumber',
  LastUpdatedTimestamp = 'lastUpdatedTimestamp',
  LowestCommission = 'lowestCommission',
  LowestCommissionUpdatedAt = 'lowestCommissionUpdatedAt',
  LowestCommissionUpdatedBlockNumber = 'lowestCommissionUpdatedBlockNumber',
  Pid = 'pid',
  PreviousCommission = 'previousCommission',
  PreviousCommissionUpdatedAt = 'previousCommissionUpdatedAt',
  PreviousCommissionUpdatedBlockNumber = 'previousCommissionUpdatedBlockNumber',
  RecentReward = 'recentReward',
  RecentStartedBlockNumber = 'recentStartedBlockNumber',
  RecentStartedTimestamp = 'recentStartedTimestamp',
  StakePoolId = 'stakePoolId',
  UpdatedAt = 'updatedAt'
}

export type StakePoolStatsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StakePoolStatsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StakePoolStatsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StakePoolStatsScalarWhereWithAggregatesInput>>;
  accumulatedReward?: InputMaybe<DecimalWithAggregatesFilter>;
  commission?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  commissionUpdatedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  commissionUpdatedBlockNumber?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  highestCommission?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  highestCommissionUpdatedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  highestCommissionUpdatedBlockNumber?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  lowestCommission?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  lowestCommissionUpdatedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  lowestCommissionUpdatedBlockNumber?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  pid?: InputMaybe<IntWithAggregatesFilter>;
  previousCommission?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  previousCommissionUpdatedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  previousCommissionUpdatedBlockNumber?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  recentReward?: InputMaybe<DecimalWithAggregatesFilter>;
  recentStartedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  recentStartedTimestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  stakePoolId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type StakePoolStatsSumAggregate = {
  __typename?: 'StakePoolStatsSumAggregate';
  accumulatedReward?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  commissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  highestCommission?: Maybe<Scalars['Decimal']>;
  highestCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lowestCommission?: Maybe<Scalars['Decimal']>;
  lowestCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  pid?: Maybe<Scalars['Int']>;
  previousCommission?: Maybe<Scalars['Decimal']>;
  previousCommissionUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  recentReward?: Maybe<Scalars['Decimal']>;
  recentStartedBlockNumber?: Maybe<Scalars['BigInt']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolStatsSumOrderByAggregateInput = {
  accumulatedReward?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  commissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  highestCommission?: InputMaybe<SortOrder>;
  highestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lowestCommission?: InputMaybe<SortOrder>;
  lowestCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  previousCommission?: InputMaybe<SortOrder>;
  previousCommissionUpdatedBlockNumber?: InputMaybe<SortOrder>;
  recentReward?: InputMaybe<SortOrder>;
  recentStartedBlockNumber?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
};

export type StakePoolStatsWhereInput = {
  AND?: InputMaybe<Array<StakePoolStatsWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolStatsWhereInput>>;
  OR?: InputMaybe<Array<StakePoolStatsWhereInput>>;
  accumulatedReward?: InputMaybe<DecimalFilter>;
  commission?: InputMaybe<DecimalNullableFilter>;
  commissionUpdatedAt?: InputMaybe<DateTimeNullableFilter>;
  commissionUpdatedBlockNumber?: InputMaybe<BigIntNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  highestCommission?: InputMaybe<DecimalNullableFilter>;
  highestCommissionUpdatedAt?: InputMaybe<DateTimeNullableFilter>;
  highestCommissionUpdatedBlockNumber?: InputMaybe<BigIntNullableFilter>;
  id?: InputMaybe<BigIntFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  lowestCommission?: InputMaybe<DecimalNullableFilter>;
  lowestCommissionUpdatedAt?: InputMaybe<DateTimeNullableFilter>;
  lowestCommissionUpdatedBlockNumber?: InputMaybe<BigIntNullableFilter>;
  pid?: InputMaybe<IntFilter>;
  previousCommission?: InputMaybe<DecimalNullableFilter>;
  previousCommissionUpdatedAt?: InputMaybe<DateTimeNullableFilter>;
  previousCommissionUpdatedBlockNumber?: InputMaybe<BigIntNullableFilter>;
  recentReward?: InputMaybe<DecimalFilter>;
  recentStartedBlockNumber?: InputMaybe<BigIntFilter>;
  recentStartedTimestamp?: InputMaybe<DateTimeFilter>;
  stakePoolId?: InputMaybe<BigIntNullableFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type StakePoolStatsWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  pid?: InputMaybe<Scalars['Int']>;
};

export type StakePoolWithdrawals = {
  __typename?: 'StakePoolWithdrawals';
  accounts: Accounts;
  createdAt: Scalars['DateTime'];
  endBlockNumber?: Maybe<Scalars['BigInt']>;
  endEventId?: Maybe<Scalars['BigInt']>;
  endTimestamp?: Maybe<Scalars['DateTime']>;
  estimatesEndTime: Scalars['DateTime'];
  id: Scalars['BigInt'];
  shares: Scalars['Decimal'];
  stake: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  stakePools: StakePools;
  startBlockNumber?: Maybe<Scalars['BigInt']>;
  startEventId?: Maybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: Maybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: Maybe<Scalars['String']>;
  userId: Scalars['BigInt'];
};

export type StakePoolWithdrawalsAvgAggregate = {
  __typename?: 'StakePoolWithdrawalsAvgAggregate';
  endBlockNumber?: Maybe<Scalars['Float']>;
  endEventId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['Float']>;
  startBlockNumber?: Maybe<Scalars['Float']>;
  startEventId?: Maybe<Scalars['Float']>;
  userId?: Maybe<Scalars['Float']>;
};

export type StakePoolWithdrawalsAvgOrderByAggregateInput = {
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsCountAggregate = {
  __typename?: 'StakePoolWithdrawalsCountAggregate';
  _all: Scalars['Int'];
  createdAt: Scalars['Int'];
  endBlockNumber: Scalars['Int'];
  endEventId: Scalars['Int'];
  endTimestamp: Scalars['Int'];
  estimatesEndTime: Scalars['Int'];
  id: Scalars['Int'];
  shares: Scalars['Int'];
  stake: Scalars['Int'];
  stakePoolId: Scalars['Int'];
  startBlockNumber: Scalars['Int'];
  startEventId: Scalars['Int'];
  startTime: Scalars['Int'];
  startTimestamp: Scalars['Int'];
  updatedAt: Scalars['Int'];
  userAddress: Scalars['Int'];
  userId: Scalars['Int'];
};

export type StakePoolWithdrawalsCountOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  endTimestamp?: InputMaybe<SortOrder>;
  estimatesEndTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  startTime?: InputMaybe<SortOrder>;
  startTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAddress?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsGroupBy = {
  __typename?: 'StakePoolWithdrawalsGroupBy';
  _avg?: Maybe<StakePoolWithdrawalsAvgAggregate>;
  _count?: Maybe<StakePoolWithdrawalsCountAggregate>;
  _max?: Maybe<StakePoolWithdrawalsMaxAggregate>;
  _min?: Maybe<StakePoolWithdrawalsMinAggregate>;
  _sum?: Maybe<StakePoolWithdrawalsSumAggregate>;
  createdAt: Scalars['DateTime'];
  endBlockNumber?: Maybe<Scalars['BigInt']>;
  endEventId?: Maybe<Scalars['BigInt']>;
  endTimestamp?: Maybe<Scalars['DateTime']>;
  estimatesEndTime: Scalars['DateTime'];
  id: Scalars['BigInt'];
  shares: Scalars['Decimal'];
  stake: Scalars['Decimal'];
  stakePoolId: Scalars['BigInt'];
  startBlockNumber?: Maybe<Scalars['BigInt']>;
  startEventId?: Maybe<Scalars['BigInt']>;
  startTime: Scalars['DateTime'];
  startTimestamp?: Maybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
  userAddress?: Maybe<Scalars['String']>;
  userId: Scalars['BigInt'];
};

export type StakePoolWithdrawalsListRelationFilter = {
  every?: InputMaybe<StakePoolWithdrawalsWhereInput>;
  none?: InputMaybe<StakePoolWithdrawalsWhereInput>;
  some?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};

export type StakePoolWithdrawalsMaxAggregate = {
  __typename?: 'StakePoolWithdrawalsMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']>;
  endBlockNumber?: Maybe<Scalars['BigInt']>;
  endEventId?: Maybe<Scalars['BigInt']>;
  endTimestamp?: Maybe<Scalars['DateTime']>;
  estimatesEndTime?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  startBlockNumber?: Maybe<Scalars['BigInt']>;
  startEventId?: Maybe<Scalars['BigInt']>;
  startTime?: Maybe<Scalars['DateTime']>;
  startTimestamp?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userAddress?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolWithdrawalsMaxOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  endTimestamp?: InputMaybe<SortOrder>;
  estimatesEndTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  startTime?: InputMaybe<SortOrder>;
  startTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAddress?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsMinAggregate = {
  __typename?: 'StakePoolWithdrawalsMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']>;
  endBlockNumber?: Maybe<Scalars['BigInt']>;
  endEventId?: Maybe<Scalars['BigInt']>;
  endTimestamp?: Maybe<Scalars['DateTime']>;
  estimatesEndTime?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['BigInt']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  startBlockNumber?: Maybe<Scalars['BigInt']>;
  startEventId?: Maybe<Scalars['BigInt']>;
  startTime?: Maybe<Scalars['DateTime']>;
  startTimestamp?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userAddress?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolWithdrawalsMinOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  endTimestamp?: InputMaybe<SortOrder>;
  estimatesEndTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  startTime?: InputMaybe<SortOrder>;
  startTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAddress?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsOrderByWithAggregationInput = {
  _avg?: InputMaybe<StakePoolWithdrawalsAvgOrderByAggregateInput>;
  _count?: InputMaybe<StakePoolWithdrawalsCountOrderByAggregateInput>;
  _max?: InputMaybe<StakePoolWithdrawalsMaxOrderByAggregateInput>;
  _min?: InputMaybe<StakePoolWithdrawalsMinOrderByAggregateInput>;
  _sum?: InputMaybe<StakePoolWithdrawalsSumOrderByAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  endTimestamp?: InputMaybe<SortOrder>;
  estimatesEndTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  startTime?: InputMaybe<SortOrder>;
  startTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAddress?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsOrderByWithRelationInput = {
  accounts?: InputMaybe<AccountsOrderByWithRelationInput>;
  createdAt?: InputMaybe<SortOrder>;
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  endTimestamp?: InputMaybe<SortOrder>;
  estimatesEndTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  startTime?: InputMaybe<SortOrder>;
  startTimestamp?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAddress?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export enum StakePoolWithdrawalsScalarFieldEnum {
  CreatedAt = 'createdAt',
  EndBlockNumber = 'endBlockNumber',
  EndEventId = 'endEventId',
  EndTimestamp = 'endTimestamp',
  EstimatesEndTime = 'estimatesEndTime',
  Id = 'id',
  Shares = 'shares',
  Stake = 'stake',
  StakePoolId = 'stakePoolId',
  StartBlockNumber = 'startBlockNumber',
  StartEventId = 'startEventId',
  StartTime = 'startTime',
  StartTimestamp = 'startTimestamp',
  UpdatedAt = 'updatedAt',
  UserAddress = 'userAddress',
  UserId = 'userId'
}

export type StakePoolWithdrawalsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StakePoolWithdrawalsScalarWhereWithAggregatesInput>>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  endBlockNumber?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  endEventId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  endTimestamp?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  estimatesEndTime?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  shares?: InputMaybe<DecimalWithAggregatesFilter>;
  stake?: InputMaybe<DecimalWithAggregatesFilter>;
  stakePoolId?: InputMaybe<BigIntWithAggregatesFilter>;
  startBlockNumber?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  startEventId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  startTime?: InputMaybe<DateTimeWithAggregatesFilter>;
  startTimestamp?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  userAddress?: InputMaybe<StringNullableWithAggregatesFilter>;
  userId?: InputMaybe<BigIntWithAggregatesFilter>;
};

export type StakePoolWithdrawalsSumAggregate = {
  __typename?: 'StakePoolWithdrawalsSumAggregate';
  endBlockNumber?: Maybe<Scalars['BigInt']>;
  endEventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  shares?: Maybe<Scalars['Decimal']>;
  stake?: Maybe<Scalars['Decimal']>;
  stakePoolId?: Maybe<Scalars['BigInt']>;
  startBlockNumber?: Maybe<Scalars['BigInt']>;
  startEventId?: Maybe<Scalars['BigInt']>;
  userId?: Maybe<Scalars['BigInt']>;
};

export type StakePoolWithdrawalsSumOrderByAggregateInput = {
  endBlockNumber?: InputMaybe<SortOrder>;
  endEventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  shares?: InputMaybe<SortOrder>;
  stake?: InputMaybe<SortOrder>;
  stakePoolId?: InputMaybe<SortOrder>;
  startBlockNumber?: InputMaybe<SortOrder>;
  startEventId?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type StakePoolWithdrawalsWhereInput = {
  AND?: InputMaybe<Array<StakePoolWithdrawalsWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolWithdrawalsWhereInput>>;
  OR?: InputMaybe<Array<StakePoolWithdrawalsWhereInput>>;
  accounts?: InputMaybe<AccountsRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  endBlockNumber?: InputMaybe<BigIntNullableFilter>;
  endEventId?: InputMaybe<BigIntNullableFilter>;
  endTimestamp?: InputMaybe<DateTimeNullableFilter>;
  estimatesEndTime?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<BigIntFilter>;
  shares?: InputMaybe<DecimalFilter>;
  stake?: InputMaybe<DecimalFilter>;
  stakePoolId?: InputMaybe<BigIntFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  startBlockNumber?: InputMaybe<BigIntNullableFilter>;
  startEventId?: InputMaybe<BigIntNullableFilter>;
  startTime?: InputMaybe<DateTimeFilter>;
  startTimestamp?: InputMaybe<DateTimeNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  userAddress?: InputMaybe<StringNullableFilter>;
  userId?: InputMaybe<BigIntFilter>;
};

export type StakePoolWithdrawalsWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type StakePools = {
  __typename?: 'StakePools';
  _count?: Maybe<StakePoolsCount>;
  accounts: Accounts;
  availableStake: Scalars['Decimal'];
  averageBlockTimeSinceLastActivity: Scalars['Float'];
  cap?: Maybe<Scalars['Decimal']>;
  commission: Scalars['Decimal'];
  coolingDownMinersCount: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  freeStake: Scalars['Decimal'];
  id: Scalars['BigInt'];
  idleMinersCount: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  miners: Array<Miners>;
  minersCount: Scalars['Int'];
  ownerAddress: Scalars['String'];
  ownerId: Scalars['BigInt'];
  ownerReward: Scalars['Decimal'];
  pid: Scalars['Int'];
  readyMinersCount: Scalars['Int'];
  releasingStake: Scalars['Decimal'];
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc: Scalars['Decimal'];
  stakePoolActivities: Array<StakePoolActivities>;
  stakePoolStakers: Array<StakePoolStakers>;
  stakePoolStats: Array<StakePoolStats>;
  stakePoolWithdrawals: Array<StakePoolWithdrawals>;
  stakersCount: Scalars['Int'];
  theoreticalApr: Scalars['Decimal'];
  totalShares: Scalars['Decimal'];
  totalStake: Scalars['Decimal'];
  unresponsiveMinersCount: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
  usedStake: Scalars['Decimal'];
  withdrawalsCount: Scalars['Int'];
  withdrawingStake: Scalars['Decimal'];
  workerActivities: Array<WorkerActivities>;
  workers: Array<Workers>;
};


export type StakePoolsMinersArgs = {
  cursor?: InputMaybe<MinersWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinersWhereInput>;
};


export type StakePoolsStakePoolActivitiesArgs = {
  cursor?: InputMaybe<StakePoolActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolActivitiesWhereInput>;
};


export type StakePoolsStakePoolStakersArgs = {
  cursor?: InputMaybe<StakePoolStakersWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStakersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStakersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakersWhereInput>;
};


export type StakePoolsStakePoolStatsArgs = {
  cursor?: InputMaybe<StakePoolStatsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolStatsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolStatsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStatsWhereInput>;
};


export type StakePoolsStakePoolWithdrawalsArgs = {
  cursor?: InputMaybe<StakePoolWithdrawalsWhereUniqueInput>;
  distinct?: InputMaybe<Array<StakePoolWithdrawalsScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StakePoolWithdrawalsOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWithdrawalsWhereInput>;
};


export type StakePoolsWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};


export type StakePoolsWorkersArgs = {
  cursor?: InputMaybe<WorkersWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkersWhereInput>;
};

export type StakePoolsAvgAggregate = {
  __typename?: 'StakePoolsAvgAggregate';
  availableStake?: Maybe<Scalars['Decimal']>;
  averageBlockTimeSinceLastActivity?: Maybe<Scalars['Float']>;
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Float']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['Float']>;
  idleMinersCount?: Maybe<Scalars['Float']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  minersCount?: Maybe<Scalars['Float']>;
  ownerId?: Maybe<Scalars['Float']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  pid?: Maybe<Scalars['Float']>;
  readyMinersCount?: Maybe<Scalars['Float']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakersCount?: Maybe<Scalars['Float']>;
  theoreticalApr?: Maybe<Scalars['Decimal']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: Maybe<Scalars['Float']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Float']>;
  withdrawingStake?: Maybe<Scalars['Decimal']>;
};

export type StakePoolsAvgOrderByAggregateInput = {
  availableStake?: InputMaybe<SortOrder>;
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
  withdrawingStake?: InputMaybe<SortOrder>;
};

export type StakePoolsCount = {
  __typename?: 'StakePoolsCount';
  miners: Scalars['Int'];
  stakePoolActivities: Scalars['Int'];
  stakePoolStakers: Scalars['Int'];
  stakePoolStats: Scalars['Int'];
  stakePoolWithdrawals: Scalars['Int'];
  workerActivities: Scalars['Int'];
  workers: Scalars['Int'];
};

export type StakePoolsCountAggregate = {
  __typename?: 'StakePoolsCountAggregate';
  _all: Scalars['Int'];
  availableStake: Scalars['Int'];
  averageBlockTimeSinceLastActivity: Scalars['Int'];
  cap: Scalars['Int'];
  commission: Scalars['Int'];
  coolingDownMinersCount: Scalars['Int'];
  createdAt: Scalars['Int'];
  freeStake: Scalars['Int'];
  id: Scalars['Int'];
  idleMinersCount: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['Int'];
  lastUpdatedTimestamp: Scalars['Int'];
  minersCount: Scalars['Int'];
  ownerAddress: Scalars['Int'];
  ownerId: Scalars['Int'];
  ownerReward: Scalars['Int'];
  pid: Scalars['Int'];
  readyMinersCount: Scalars['Int'];
  releasingStake: Scalars['Int'];
  remainingStake: Scalars['Int'];
  rewardAcc: Scalars['Int'];
  stakersCount: Scalars['Int'];
  theoreticalApr: Scalars['Int'];
  totalShares: Scalars['Int'];
  totalStake: Scalars['Int'];
  unresponsiveMinersCount: Scalars['Int'];
  updatedAt: Scalars['Int'];
  usedStake: Scalars['Int'];
  withdrawalsCount: Scalars['Int'];
  withdrawingStake: Scalars['Int'];
};

export type StakePoolsCountOrderByAggregateInput = {
  availableStake?: InputMaybe<SortOrder>;
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerAddress?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
  withdrawingStake?: InputMaybe<SortOrder>;
};

export type StakePoolsGroupBy = {
  __typename?: 'StakePoolsGroupBy';
  _avg?: Maybe<StakePoolsAvgAggregate>;
  _count?: Maybe<StakePoolsCountAggregate>;
  _max?: Maybe<StakePoolsMaxAggregate>;
  _min?: Maybe<StakePoolsMinAggregate>;
  _sum?: Maybe<StakePoolsSumAggregate>;
  availableStake: Scalars['Decimal'];
  averageBlockTimeSinceLastActivity: Scalars['Float'];
  cap?: Maybe<Scalars['Decimal']>;
  commission: Scalars['Decimal'];
  coolingDownMinersCount: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  freeStake: Scalars['Decimal'];
  id: Scalars['BigInt'];
  idleMinersCount: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersCount: Scalars['Int'];
  ownerAddress: Scalars['String'];
  ownerId: Scalars['BigInt'];
  ownerReward: Scalars['Decimal'];
  pid: Scalars['Int'];
  readyMinersCount: Scalars['Int'];
  releasingStake: Scalars['Decimal'];
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc: Scalars['Decimal'];
  stakersCount: Scalars['Int'];
  theoreticalApr: Scalars['Decimal'];
  totalShares: Scalars['Decimal'];
  totalStake: Scalars['Decimal'];
  unresponsiveMinersCount: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
  usedStake: Scalars['Decimal'];
  withdrawalsCount: Scalars['Int'];
  withdrawingStake: Scalars['Decimal'];
};

export type StakePoolsListRelationFilter = {
  every?: InputMaybe<StakePoolsWhereInput>;
  none?: InputMaybe<StakePoolsWhereInput>;
  some?: InputMaybe<StakePoolsWhereInput>;
};

export type StakePoolsMaxAggregate = {
  __typename?: 'StakePoolsMaxAggregate';
  availableStake?: Maybe<Scalars['Decimal']>;
  averageBlockTimeSinceLastActivity?: Maybe<Scalars['Float']>;
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  idleMinersCount?: Maybe<Scalars['Int']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  minersCount?: Maybe<Scalars['Int']>;
  ownerAddress?: Maybe<Scalars['String']>;
  ownerId?: Maybe<Scalars['BigInt']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  pid?: Maybe<Scalars['Int']>;
  readyMinersCount?: Maybe<Scalars['Int']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakersCount?: Maybe<Scalars['Int']>;
  theoreticalApr?: Maybe<Scalars['Decimal']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Int']>;
  withdrawingStake?: Maybe<Scalars['Decimal']>;
};

export type StakePoolsMaxOrderByAggregateInput = {
  availableStake?: InputMaybe<SortOrder>;
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerAddress?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
  withdrawingStake?: InputMaybe<SortOrder>;
};

export type StakePoolsMinAggregate = {
  __typename?: 'StakePoolsMinAggregate';
  availableStake?: Maybe<Scalars['Decimal']>;
  averageBlockTimeSinceLastActivity?: Maybe<Scalars['Float']>;
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  idleMinersCount?: Maybe<Scalars['Int']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  minersCount?: Maybe<Scalars['Int']>;
  ownerAddress?: Maybe<Scalars['String']>;
  ownerId?: Maybe<Scalars['BigInt']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  pid?: Maybe<Scalars['Int']>;
  readyMinersCount?: Maybe<Scalars['Int']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakersCount?: Maybe<Scalars['Int']>;
  theoreticalApr?: Maybe<Scalars['Decimal']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Int']>;
  withdrawingStake?: Maybe<Scalars['Decimal']>;
};

export type StakePoolsMinOrderByAggregateInput = {
  availableStake?: InputMaybe<SortOrder>;
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerAddress?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
  withdrawingStake?: InputMaybe<SortOrder>;
};

export type StakePoolsOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StakePoolsOrderByWithAggregationInput = {
  _avg?: InputMaybe<StakePoolsAvgOrderByAggregateInput>;
  _count?: InputMaybe<StakePoolsCountOrderByAggregateInput>;
  _max?: InputMaybe<StakePoolsMaxOrderByAggregateInput>;
  _min?: InputMaybe<StakePoolsMinOrderByAggregateInput>;
  _sum?: InputMaybe<StakePoolsSumOrderByAggregateInput>;
  availableStake?: InputMaybe<SortOrder>;
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerAddress?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
  withdrawingStake?: InputMaybe<SortOrder>;
};

export type StakePoolsOrderByWithRelationInput = {
  accounts?: InputMaybe<AccountsOrderByWithRelationInput>;
  availableStake?: InputMaybe<SortOrder>;
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  miners?: InputMaybe<MinersOrderByRelationAggregateInput>;
  minersCount?: InputMaybe<SortOrder>;
  ownerAddress?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesOrderByRelationAggregateInput>;
  stakePoolStakers?: InputMaybe<StakePoolStakersOrderByRelationAggregateInput>;
  stakePoolStats?: InputMaybe<StakePoolStatsOrderByRelationAggregateInput>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsOrderByRelationAggregateInput>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
  withdrawingStake?: InputMaybe<SortOrder>;
  workerActivities?: InputMaybe<WorkerActivitiesOrderByRelationAggregateInput>;
  workers?: InputMaybe<WorkersOrderByRelationAggregateInput>;
};

export type StakePoolsRelationFilter = {
  is?: InputMaybe<StakePoolsWhereInput>;
  isNot?: InputMaybe<StakePoolsWhereInput>;
};

export enum StakePoolsScalarFieldEnum {
  AvailableStake = 'availableStake',
  AverageBlockTimeSinceLastActivity = 'averageBlockTimeSinceLastActivity',
  Cap = 'cap',
  Commission = 'commission',
  CoolingDownMinersCount = 'coolingDownMinersCount',
  CreatedAt = 'createdAt',
  FreeStake = 'freeStake',
  Id = 'id',
  IdleMinersCount = 'idleMinersCount',
  LastUpdatedBlockNumber = 'lastUpdatedBlockNumber',
  LastUpdatedTimestamp = 'lastUpdatedTimestamp',
  MinersCount = 'minersCount',
  OwnerAddress = 'ownerAddress',
  OwnerId = 'ownerId',
  OwnerReward = 'ownerReward',
  Pid = 'pid',
  ReadyMinersCount = 'readyMinersCount',
  ReleasingStake = 'releasingStake',
  RemainingStake = 'remainingStake',
  RewardAcc = 'rewardAcc',
  StakersCount = 'stakersCount',
  TheoreticalApr = 'theoreticalApr',
  TotalShares = 'totalShares',
  TotalStake = 'totalStake',
  UnresponsiveMinersCount = 'unresponsiveMinersCount',
  UpdatedAt = 'updatedAt',
  UsedStake = 'usedStake',
  WithdrawalsCount = 'withdrawalsCount',
  WithdrawingStake = 'withdrawingStake'
}

export type StakePoolsScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StakePoolsScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StakePoolsScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StakePoolsScalarWhereWithAggregatesInput>>;
  availableStake?: InputMaybe<DecimalWithAggregatesFilter>;
  averageBlockTimeSinceLastActivity?: InputMaybe<FloatWithAggregatesFilter>;
  cap?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  commission?: InputMaybe<DecimalWithAggregatesFilter>;
  coolingDownMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  freeStake?: InputMaybe<DecimalWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  idleMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  minersCount?: InputMaybe<IntWithAggregatesFilter>;
  ownerAddress?: InputMaybe<StringWithAggregatesFilter>;
  ownerId?: InputMaybe<BigIntWithAggregatesFilter>;
  ownerReward?: InputMaybe<DecimalWithAggregatesFilter>;
  pid?: InputMaybe<IntWithAggregatesFilter>;
  readyMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  releasingStake?: InputMaybe<DecimalWithAggregatesFilter>;
  remainingStake?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  rewardAcc?: InputMaybe<DecimalWithAggregatesFilter>;
  stakersCount?: InputMaybe<IntWithAggregatesFilter>;
  theoreticalApr?: InputMaybe<DecimalWithAggregatesFilter>;
  totalShares?: InputMaybe<DecimalWithAggregatesFilter>;
  totalStake?: InputMaybe<DecimalWithAggregatesFilter>;
  unresponsiveMinersCount?: InputMaybe<IntWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  usedStake?: InputMaybe<DecimalWithAggregatesFilter>;
  withdrawalsCount?: InputMaybe<IntWithAggregatesFilter>;
  withdrawingStake?: InputMaybe<DecimalWithAggregatesFilter>;
};

export type StakePoolsSumAggregate = {
  __typename?: 'StakePoolsSumAggregate';
  availableStake?: Maybe<Scalars['Decimal']>;
  averageBlockTimeSinceLastActivity?: Maybe<Scalars['Float']>;
  cap?: Maybe<Scalars['Decimal']>;
  commission?: Maybe<Scalars['Decimal']>;
  coolingDownMinersCount?: Maybe<Scalars['Int']>;
  freeStake?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  idleMinersCount?: Maybe<Scalars['Int']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  minersCount?: Maybe<Scalars['Int']>;
  ownerId?: Maybe<Scalars['BigInt']>;
  ownerReward?: Maybe<Scalars['Decimal']>;
  pid?: Maybe<Scalars['Int']>;
  readyMinersCount?: Maybe<Scalars['Int']>;
  releasingStake?: Maybe<Scalars['Decimal']>;
  remainingStake?: Maybe<Scalars['Decimal']>;
  rewardAcc?: Maybe<Scalars['Decimal']>;
  stakersCount?: Maybe<Scalars['Int']>;
  theoreticalApr?: Maybe<Scalars['Decimal']>;
  totalShares?: Maybe<Scalars['Decimal']>;
  totalStake?: Maybe<Scalars['Decimal']>;
  unresponsiveMinersCount?: Maybe<Scalars['Int']>;
  usedStake?: Maybe<Scalars['Decimal']>;
  withdrawalsCount?: Maybe<Scalars['Int']>;
  withdrawingStake?: Maybe<Scalars['Decimal']>;
};

export type StakePoolsSumOrderByAggregateInput = {
  availableStake?: InputMaybe<SortOrder>;
  averageBlockTimeSinceLastActivity?: InputMaybe<SortOrder>;
  cap?: InputMaybe<SortOrder>;
  commission?: InputMaybe<SortOrder>;
  coolingDownMinersCount?: InputMaybe<SortOrder>;
  freeStake?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idleMinersCount?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  minersCount?: InputMaybe<SortOrder>;
  ownerId?: InputMaybe<SortOrder>;
  ownerReward?: InputMaybe<SortOrder>;
  pid?: InputMaybe<SortOrder>;
  readyMinersCount?: InputMaybe<SortOrder>;
  releasingStake?: InputMaybe<SortOrder>;
  remainingStake?: InputMaybe<SortOrder>;
  rewardAcc?: InputMaybe<SortOrder>;
  stakersCount?: InputMaybe<SortOrder>;
  theoreticalApr?: InputMaybe<SortOrder>;
  totalShares?: InputMaybe<SortOrder>;
  totalStake?: InputMaybe<SortOrder>;
  unresponsiveMinersCount?: InputMaybe<SortOrder>;
  usedStake?: InputMaybe<SortOrder>;
  withdrawalsCount?: InputMaybe<SortOrder>;
  withdrawingStake?: InputMaybe<SortOrder>;
};

export type StakePoolsWhereInput = {
  AND?: InputMaybe<Array<StakePoolsWhereInput>>;
  NOT?: InputMaybe<Array<StakePoolsWhereInput>>;
  OR?: InputMaybe<Array<StakePoolsWhereInput>>;
  accounts?: InputMaybe<AccountsRelationFilter>;
  availableStake?: InputMaybe<DecimalFilter>;
  averageBlockTimeSinceLastActivity?: InputMaybe<FloatFilter>;
  cap?: InputMaybe<DecimalNullableFilter>;
  commission?: InputMaybe<DecimalFilter>;
  coolingDownMinersCount?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  freeStake?: InputMaybe<DecimalFilter>;
  id?: InputMaybe<BigIntFilter>;
  idleMinersCount?: InputMaybe<IntFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  miners?: InputMaybe<MinersListRelationFilter>;
  minersCount?: InputMaybe<IntFilter>;
  ownerAddress?: InputMaybe<StringFilter>;
  ownerId?: InputMaybe<BigIntFilter>;
  ownerReward?: InputMaybe<DecimalFilter>;
  pid?: InputMaybe<IntFilter>;
  readyMinersCount?: InputMaybe<IntFilter>;
  releasingStake?: InputMaybe<DecimalFilter>;
  remainingStake?: InputMaybe<DecimalNullableFilter>;
  rewardAcc?: InputMaybe<DecimalFilter>;
  stakePoolActivities?: InputMaybe<StakePoolActivitiesListRelationFilter>;
  stakePoolStakers?: InputMaybe<StakePoolStakersListRelationFilter>;
  stakePoolStats?: InputMaybe<StakePoolStatsListRelationFilter>;
  stakePoolWithdrawals?: InputMaybe<StakePoolWithdrawalsListRelationFilter>;
  stakersCount?: InputMaybe<IntFilter>;
  theoreticalApr?: InputMaybe<DecimalFilter>;
  totalShares?: InputMaybe<DecimalFilter>;
  totalStake?: InputMaybe<DecimalFilter>;
  unresponsiveMinersCount?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  usedStake?: InputMaybe<DecimalFilter>;
  withdrawalsCount?: InputMaybe<IntFilter>;
  withdrawingStake?: InputMaybe<DecimalFilter>;
  workerActivities?: InputMaybe<WorkerActivitiesListRelationFilter>;
  workers?: InputMaybe<WorkersListRelationFilter>;
};

export type StakePoolsWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  pid?: InputMaybe<Scalars['Int']>;
};

export type States = {
  __typename?: 'States';
  createdAt: Scalars['DateTime'];
  datetimeValue?: Maybe<Scalars['DateTime']>;
  decimalValue?: Maybe<Scalars['Decimal']>;
  id: Scalars['BigInt'];
  integerValue?: Maybe<Scalars['Int']>;
  key?: Maybe<Scalars['String']>;
  stringValue?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  visible?: Maybe<Scalars['Boolean']>;
};

export type StatesAvgAggregate = {
  __typename?: 'StatesAvgAggregate';
  decimalValue?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['Float']>;
  integerValue?: Maybe<Scalars['Float']>;
};

export type StatesAvgOrderByAggregateInput = {
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
};

export type StatesCountAggregate = {
  __typename?: 'StatesCountAggregate';
  _all: Scalars['Int'];
  createdAt: Scalars['Int'];
  datetimeValue: Scalars['Int'];
  decimalValue: Scalars['Int'];
  id: Scalars['Int'];
  integerValue: Scalars['Int'];
  key: Scalars['Int'];
  stringValue: Scalars['Int'];
  updatedAt: Scalars['Int'];
  visible: Scalars['Int'];
};

export type StatesCountOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  datetimeValue?: InputMaybe<SortOrder>;
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  stringValue?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  visible?: InputMaybe<SortOrder>;
};

export type StatesGroupBy = {
  __typename?: 'StatesGroupBy';
  _avg?: Maybe<StatesAvgAggregate>;
  _count?: Maybe<StatesCountAggregate>;
  _max?: Maybe<StatesMaxAggregate>;
  _min?: Maybe<StatesMinAggregate>;
  _sum?: Maybe<StatesSumAggregate>;
  createdAt: Scalars['DateTime'];
  datetimeValue?: Maybe<Scalars['DateTime']>;
  decimalValue?: Maybe<Scalars['Decimal']>;
  id: Scalars['BigInt'];
  integerValue?: Maybe<Scalars['Int']>;
  key?: Maybe<Scalars['String']>;
  stringValue?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  visible?: Maybe<Scalars['Boolean']>;
};

export type StatesMaxAggregate = {
  __typename?: 'StatesMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']>;
  datetimeValue?: Maybe<Scalars['DateTime']>;
  decimalValue?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  integerValue?: Maybe<Scalars['Int']>;
  key?: Maybe<Scalars['String']>;
  stringValue?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  visible?: Maybe<Scalars['Boolean']>;
};

export type StatesMaxOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  datetimeValue?: InputMaybe<SortOrder>;
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  stringValue?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  visible?: InputMaybe<SortOrder>;
};

export type StatesMinAggregate = {
  __typename?: 'StatesMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']>;
  datetimeValue?: Maybe<Scalars['DateTime']>;
  decimalValue?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  integerValue?: Maybe<Scalars['Int']>;
  key?: Maybe<Scalars['String']>;
  stringValue?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  visible?: Maybe<Scalars['Boolean']>;
};

export type StatesMinOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  datetimeValue?: InputMaybe<SortOrder>;
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  stringValue?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  visible?: InputMaybe<SortOrder>;
};

export type StatesOrderByWithAggregationInput = {
  _avg?: InputMaybe<StatesAvgOrderByAggregateInput>;
  _count?: InputMaybe<StatesCountOrderByAggregateInput>;
  _max?: InputMaybe<StatesMaxOrderByAggregateInput>;
  _min?: InputMaybe<StatesMinOrderByAggregateInput>;
  _sum?: InputMaybe<StatesSumOrderByAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  datetimeValue?: InputMaybe<SortOrder>;
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  stringValue?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  visible?: InputMaybe<SortOrder>;
};

export type StatesOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  datetimeValue?: InputMaybe<SortOrder>;
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  stringValue?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  visible?: InputMaybe<SortOrder>;
};

export enum StatesScalarFieldEnum {
  CreatedAt = 'createdAt',
  DatetimeValue = 'datetimeValue',
  DecimalValue = 'decimalValue',
  Id = 'id',
  IntegerValue = 'integerValue',
  Key = 'key',
  StringValue = 'stringValue',
  UpdatedAt = 'updatedAt',
  Visible = 'visible'
}

export type StatesScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StatesScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StatesScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StatesScalarWhereWithAggregatesInput>>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  datetimeValue?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  decimalValue?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  integerValue?: InputMaybe<IntNullableWithAggregatesFilter>;
  key?: InputMaybe<StringNullableWithAggregatesFilter>;
  stringValue?: InputMaybe<StringNullableWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  visible?: InputMaybe<BoolNullableWithAggregatesFilter>;
};

export type StatesSumAggregate = {
  __typename?: 'StatesSumAggregate';
  decimalValue?: Maybe<Scalars['Decimal']>;
  id?: Maybe<Scalars['BigInt']>;
  integerValue?: Maybe<Scalars['Int']>;
};

export type StatesSumOrderByAggregateInput = {
  decimalValue?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  integerValue?: InputMaybe<SortOrder>;
};

export type StatesWhereInput = {
  AND?: InputMaybe<Array<StatesWhereInput>>;
  NOT?: InputMaybe<Array<StatesWhereInput>>;
  OR?: InputMaybe<Array<StatesWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  datetimeValue?: InputMaybe<DateTimeNullableFilter>;
  decimalValue?: InputMaybe<DecimalNullableFilter>;
  id?: InputMaybe<BigIntFilter>;
  integerValue?: InputMaybe<IntNullableFilter>;
  key?: InputMaybe<StringNullableFilter>;
  stringValue?: InputMaybe<StringNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  visible?: InputMaybe<BoolNullableFilter>;
};

export type StatesWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type StringFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type StringNullableFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type StringNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedStringNullableFilter>;
  _min?: InputMaybe<NestedStringNullableFilter>;
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type StringWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedStringFilter>;
  _min?: InputMaybe<NestedStringFilter>;
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type WorkerActivities = {
  __typename?: 'WorkerActivities';
  accounts?: Maybe<Accounts>;
  blockNumber: Scalars['BigInt'];
  confidenceLevel: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['BigInt']>;
  features: Array<Scalars['Int']>;
  id: Scalars['BigInt'];
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore: Scalars['Int'];
  miners?: Maybe<Miners>;
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  runtimeVersion: Scalars['Int'];
  stakePools?: Maybe<StakePools>;
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workerId: Scalars['BigInt'];
  workers: Workers;
};

export type WorkerActivitiesAvgAggregate = {
  __typename?: 'WorkerActivitiesAvgAggregate';
  blockNumber?: Maybe<Scalars['Float']>;
  confidenceLevel?: Maybe<Scalars['Float']>;
  currentMinerId?: Maybe<Scalars['Float']>;
  currentPid?: Maybe<Scalars['Float']>;
  currentStakePoolId?: Maybe<Scalars['Float']>;
  eventId?: Maybe<Scalars['Float']>;
  features?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  initialScore?: Maybe<Scalars['Float']>;
  operatorId?: Maybe<Scalars['Float']>;
  runtimeVersion?: Maybe<Scalars['Float']>;
  tokenomicVersion?: Maybe<Scalars['Float']>;
  workerId?: Maybe<Scalars['Float']>;
};

export type WorkerActivitiesAvgOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesCountAggregate = {
  __typename?: 'WorkerActivitiesCountAggregate';
  _all: Scalars['Int'];
  blockNumber: Scalars['Int'];
  confidenceLevel: Scalars['Int'];
  createdAt: Scalars['Int'];
  currentMinerAccountAddress: Scalars['Int'];
  currentMinerId: Scalars['Int'];
  currentPid: Scalars['Int'];
  currentStakePoolId: Scalars['Int'];
  ecdhPublicKey: Scalars['Int'];
  eventId: Scalars['Int'];
  features: Scalars['Int'];
  id: Scalars['Int'];
  infoLastUpdatedAt: Scalars['Int'];
  initialScore: Scalars['Int'];
  operatorAddress: Scalars['Int'];
  operatorId: Scalars['Int'];
  runtimeVersion: Scalars['Int'];
  timestamp: Scalars['Int'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['Int'];
  updatedAt: Scalars['Int'];
  workerId: Scalars['Int'];
};

export type WorkerActivitiesCountOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesGroupBy = {
  __typename?: 'WorkerActivitiesGroupBy';
  _avg?: Maybe<WorkerActivitiesAvgAggregate>;
  _count?: Maybe<WorkerActivitiesCountAggregate>;
  _max?: Maybe<WorkerActivitiesMaxAggregate>;
  _min?: Maybe<WorkerActivitiesMinAggregate>;
  _sum?: Maybe<WorkerActivitiesSumAggregate>;
  blockNumber: Scalars['BigInt'];
  confidenceLevel: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['BigInt']>;
  features?: Maybe<Array<Scalars['Int']>>;
  id: Scalars['BigInt'];
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore: Scalars['Int'];
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  runtimeVersion: Scalars['Int'];
  timestamp: Scalars['DateTime'];
  tokenomicVersion: Scalars['Int'];
  type: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  workerId: Scalars['BigInt'];
};

export type WorkerActivitiesListRelationFilter = {
  every?: InputMaybe<WorkerActivitiesWhereInput>;
  none?: InputMaybe<WorkerActivitiesWhereInput>;
  some?: InputMaybe<WorkerActivitiesWhereInput>;
};

export type WorkerActivitiesMaxAggregate = {
  __typename?: 'WorkerActivitiesMaxAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  confidenceLevel?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  infoLastUpdatedAt?: Maybe<Scalars['DateTime']>;
  initialScore?: Maybe<Scalars['Int']>;
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  runtimeVersion?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  workerId?: Maybe<Scalars['BigInt']>;
};

export type WorkerActivitiesMaxOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesMinAggregate = {
  __typename?: 'WorkerActivitiesMinAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  confidenceLevel?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
  infoLastUpdatedAt?: Maybe<Scalars['DateTime']>;
  initialScore?: Maybe<Scalars['Int']>;
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  runtimeVersion?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['DateTime']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  workerId?: Maybe<Scalars['BigInt']>;
};

export type WorkerActivitiesMinOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesOrderByWithAggregationInput = {
  _avg?: InputMaybe<WorkerActivitiesAvgOrderByAggregateInput>;
  _count?: InputMaybe<WorkerActivitiesCountOrderByAggregateInput>;
  _max?: InputMaybe<WorkerActivitiesMaxOrderByAggregateInput>;
  _min?: InputMaybe<WorkerActivitiesMinOrderByAggregateInput>;
  _sum?: InputMaybe<WorkerActivitiesSumOrderByAggregateInput>;
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesOrderByWithRelationInput = {
  accounts?: InputMaybe<AccountsOrderByWithRelationInput>;
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  miners?: InputMaybe<MinersOrderByWithRelationInput>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  timestamp?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
  workers?: InputMaybe<WorkersOrderByWithRelationInput>;
};

export enum WorkerActivitiesScalarFieldEnum {
  BlockNumber = 'blockNumber',
  ConfidenceLevel = 'confidenceLevel',
  CreatedAt = 'createdAt',
  CurrentMinerAccountAddress = 'currentMinerAccountAddress',
  CurrentMinerId = 'currentMinerId',
  CurrentPid = 'currentPid',
  CurrentStakePoolId = 'currentStakePoolId',
  EcdhPublicKey = 'ecdhPublicKey',
  EventId = 'eventId',
  Features = 'features',
  Id = 'id',
  InfoLastUpdatedAt = 'infoLastUpdatedAt',
  InitialScore = 'initialScore',
  OperatorAddress = 'operatorAddress',
  OperatorId = 'operatorId',
  RuntimeVersion = 'runtimeVersion',
  Timestamp = 'timestamp',
  TokenomicVersion = 'tokenomicVersion',
  Type = 'type',
  UpdatedAt = 'updatedAt',
  WorkerId = 'workerId'
}

export type WorkerActivitiesScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<WorkerActivitiesScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<WorkerActivitiesScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<WorkerActivitiesScalarWhereWithAggregatesInput>>;
  blockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  confidenceLevel?: InputMaybe<IntWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  currentMinerAccountAddress?: InputMaybe<StringNullableWithAggregatesFilter>;
  currentMinerId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  currentPid?: InputMaybe<IntNullableWithAggregatesFilter>;
  currentStakePoolId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  ecdhPublicKey?: InputMaybe<StringNullableWithAggregatesFilter>;
  eventId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  features?: InputMaybe<IntNullableListFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  infoLastUpdatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  initialScore?: InputMaybe<IntWithAggregatesFilter>;
  operatorAddress?: InputMaybe<StringNullableWithAggregatesFilter>;
  operatorId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  runtimeVersion?: InputMaybe<IntWithAggregatesFilter>;
  timestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  tokenomicVersion?: InputMaybe<IntWithAggregatesFilter>;
  type?: InputMaybe<StringWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  workerId?: InputMaybe<BigIntWithAggregatesFilter>;
};

export type WorkerActivitiesSumAggregate = {
  __typename?: 'WorkerActivitiesSumAggregate';
  blockNumber?: Maybe<Scalars['BigInt']>;
  confidenceLevel?: Maybe<Scalars['Int']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  eventId?: Maybe<Scalars['BigInt']>;
  features?: Maybe<Array<Scalars['Int']>>;
  id?: Maybe<Scalars['BigInt']>;
  initialScore?: Maybe<Scalars['Int']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  runtimeVersion?: Maybe<Scalars['Int']>;
  tokenomicVersion?: Maybe<Scalars['Int']>;
  workerId?: Maybe<Scalars['BigInt']>;
};

export type WorkerActivitiesSumOrderByAggregateInput = {
  blockNumber?: InputMaybe<SortOrder>;
  confidenceLevel?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  eventId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  tokenomicVersion?: InputMaybe<SortOrder>;
  workerId?: InputMaybe<SortOrder>;
};

export type WorkerActivitiesWhereInput = {
  AND?: InputMaybe<Array<WorkerActivitiesWhereInput>>;
  NOT?: InputMaybe<Array<WorkerActivitiesWhereInput>>;
  OR?: InputMaybe<Array<WorkerActivitiesWhereInput>>;
  accounts?: InputMaybe<AccountsRelationFilter>;
  blockNumber?: InputMaybe<BigIntFilter>;
  confidenceLevel?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  currentMinerAccountAddress?: InputMaybe<StringNullableFilter>;
  currentMinerId?: InputMaybe<BigIntNullableFilter>;
  currentPid?: InputMaybe<IntNullableFilter>;
  currentStakePoolId?: InputMaybe<BigIntNullableFilter>;
  ecdhPublicKey?: InputMaybe<StringNullableFilter>;
  eventId?: InputMaybe<BigIntNullableFilter>;
  features?: InputMaybe<IntNullableListFilter>;
  id?: InputMaybe<BigIntFilter>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFilter>;
  initialScore?: InputMaybe<IntFilter>;
  miners?: InputMaybe<MinersRelationFilter>;
  operatorAddress?: InputMaybe<StringNullableFilter>;
  operatorId?: InputMaybe<BigIntNullableFilter>;
  runtimeVersion?: InputMaybe<IntFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
  tokenomicVersion?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  workerId?: InputMaybe<BigIntFilter>;
  workers?: InputMaybe<WorkersRelationFilter>;
};

export type WorkerActivitiesWhereUniqueInput = {
  id?: InputMaybe<Scalars['BigInt']>;
};

export type Workers = {
  __typename?: 'Workers';
  _count?: Maybe<WorkersCount>;
  accounts?: Maybe<Accounts>;
  confidenceLevel: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  features: Array<Scalars['Int']>;
  id: Scalars['BigInt'];
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  minersMinersToWorkersCurrentMinerId?: Maybe<Miners>;
  minersMinersWorkerIdToWorkers: Array<Miners>;
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  publicKey: Scalars['String'];
  runtimeVersion: Scalars['Int'];
  stakePools?: Maybe<StakePools>;
  updatedAt: Scalars['DateTime'];
  workerActivities: Array<WorkerActivities>;
};


export type WorkersMinersMinersWorkerIdToWorkersArgs = {
  cursor?: InputMaybe<MinersWhereUniqueInput>;
  distinct?: InputMaybe<Array<MinersScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MinersOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MinersWhereInput>;
};


export type WorkersWorkerActivitiesArgs = {
  cursor?: InputMaybe<WorkerActivitiesWhereUniqueInput>;
  distinct?: InputMaybe<Array<WorkerActivitiesScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WorkerActivitiesOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerActivitiesWhereInput>;
};

export type WorkersAvgAggregate = {
  __typename?: 'WorkersAvgAggregate';
  confidenceLevel?: Maybe<Scalars['Float']>;
  currentMinerId?: Maybe<Scalars['Float']>;
  currentPid?: Maybe<Scalars['Float']>;
  currentStakePoolId?: Maybe<Scalars['Float']>;
  features?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  initialScore?: Maybe<Scalars['Float']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['Float']>;
  operatorId?: Maybe<Scalars['Float']>;
  runtimeVersion?: Maybe<Scalars['Float']>;
};

export type WorkersAvgOrderByAggregateInput = {
  confidenceLevel?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
};

export type WorkersCount = {
  __typename?: 'WorkersCount';
  minersMinersWorkerIdToWorkers: Scalars['Int'];
  workerActivities: Scalars['Int'];
};

export type WorkersCountAggregate = {
  __typename?: 'WorkersCountAggregate';
  _all: Scalars['Int'];
  confidenceLevel: Scalars['Int'];
  createdAt: Scalars['Int'];
  currentMinerAccountAddress: Scalars['Int'];
  currentMinerId: Scalars['Int'];
  currentPid: Scalars['Int'];
  currentStakePoolId: Scalars['Int'];
  ecdhPublicKey: Scalars['Int'];
  features: Scalars['Int'];
  id: Scalars['Int'];
  infoLastUpdatedAt: Scalars['Int'];
  initialScore: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['Int'];
  lastUpdatedTimestamp: Scalars['Int'];
  operatorAddress: Scalars['Int'];
  operatorId: Scalars['Int'];
  publicKey: Scalars['Int'];
  runtimeVersion: Scalars['Int'];
  updatedAt: Scalars['Int'];
};

export type WorkersCountOrderByAggregateInput = {
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  publicKey?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type WorkersGroupBy = {
  __typename?: 'WorkersGroupBy';
  _avg?: Maybe<WorkersAvgAggregate>;
  _count?: Maybe<WorkersCountAggregate>;
  _max?: Maybe<WorkersMaxAggregate>;
  _min?: Maybe<WorkersMinAggregate>;
  _sum?: Maybe<WorkersSumAggregate>;
  confidenceLevel: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  features?: Maybe<Array<Scalars['Int']>>;
  id: Scalars['BigInt'];
  infoLastUpdatedAt: Scalars['DateTime'];
  initialScore: Scalars['Int'];
  lastUpdatedBlockNumber: Scalars['BigInt'];
  lastUpdatedTimestamp: Scalars['DateTime'];
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  publicKey: Scalars['String'];
  runtimeVersion: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
};

export type WorkersListRelationFilter = {
  every?: InputMaybe<WorkersWhereInput>;
  none?: InputMaybe<WorkersWhereInput>;
  some?: InputMaybe<WorkersWhereInput>;
};

export type WorkersMaxAggregate = {
  __typename?: 'WorkersMaxAggregate';
  confidenceLevel?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['BigInt']>;
  infoLastUpdatedAt?: Maybe<Scalars['DateTime']>;
  initialScore?: Maybe<Scalars['Int']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  publicKey?: Maybe<Scalars['String']>;
  runtimeVersion?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type WorkersMaxOrderByAggregateInput = {
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  publicKey?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type WorkersMinAggregate = {
  __typename?: 'WorkersMinAggregate';
  confidenceLevel?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  currentMinerAccountAddress?: Maybe<Scalars['String']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  ecdhPublicKey?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['BigInt']>;
  infoLastUpdatedAt?: Maybe<Scalars['DateTime']>;
  initialScore?: Maybe<Scalars['Int']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  lastUpdatedTimestamp?: Maybe<Scalars['DateTime']>;
  operatorAddress?: Maybe<Scalars['String']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  publicKey?: Maybe<Scalars['String']>;
  runtimeVersion?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type WorkersMinOrderByAggregateInput = {
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  publicKey?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type WorkersOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type WorkersOrderByWithAggregationInput = {
  _avg?: InputMaybe<WorkersAvgOrderByAggregateInput>;
  _count?: InputMaybe<WorkersCountOrderByAggregateInput>;
  _max?: InputMaybe<WorkersMaxOrderByAggregateInput>;
  _min?: InputMaybe<WorkersMinOrderByAggregateInput>;
  _sum?: InputMaybe<WorkersSumOrderByAggregateInput>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  publicKey?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type WorkersOrderByWithRelationInput = {
  accounts?: InputMaybe<AccountsOrderByWithRelationInput>;
  confidenceLevel?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  currentMinerAccountAddress?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  ecdhPublicKey?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  infoLastUpdatedAt?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  lastUpdatedTimestamp?: InputMaybe<SortOrder>;
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersOrderByWithRelationInput>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersOrderByRelationAggregateInput>;
  operatorAddress?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  publicKey?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
  stakePools?: InputMaybe<StakePoolsOrderByWithRelationInput>;
  updatedAt?: InputMaybe<SortOrder>;
  workerActivities?: InputMaybe<WorkerActivitiesOrderByRelationAggregateInput>;
};

export type WorkersRelationFilter = {
  is?: InputMaybe<WorkersWhereInput>;
  isNot?: InputMaybe<WorkersWhereInput>;
};

export enum WorkersScalarFieldEnum {
  ConfidenceLevel = 'confidenceLevel',
  CreatedAt = 'createdAt',
  CurrentMinerAccountAddress = 'currentMinerAccountAddress',
  CurrentMinerId = 'currentMinerId',
  CurrentPid = 'currentPid',
  CurrentStakePoolId = 'currentStakePoolId',
  EcdhPublicKey = 'ecdhPublicKey',
  Features = 'features',
  Id = 'id',
  InfoLastUpdatedAt = 'infoLastUpdatedAt',
  InitialScore = 'initialScore',
  LastUpdatedBlockNumber = 'lastUpdatedBlockNumber',
  LastUpdatedTimestamp = 'lastUpdatedTimestamp',
  OperatorAddress = 'operatorAddress',
  OperatorId = 'operatorId',
  PublicKey = 'publicKey',
  RuntimeVersion = 'runtimeVersion',
  UpdatedAt = 'updatedAt'
}

export type WorkersScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<WorkersScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<WorkersScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<WorkersScalarWhereWithAggregatesInput>>;
  confidenceLevel?: InputMaybe<IntWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  currentMinerAccountAddress?: InputMaybe<StringNullableWithAggregatesFilter>;
  currentMinerId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  currentPid?: InputMaybe<IntNullableWithAggregatesFilter>;
  currentStakePoolId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  ecdhPublicKey?: InputMaybe<StringNullableWithAggregatesFilter>;
  features?: InputMaybe<IntNullableListFilter>;
  id?: InputMaybe<BigIntWithAggregatesFilter>;
  infoLastUpdatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  initialScore?: InputMaybe<IntWithAggregatesFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntWithAggregatesFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeWithAggregatesFilter>;
  operatorAddress?: InputMaybe<StringNullableWithAggregatesFilter>;
  operatorId?: InputMaybe<BigIntNullableWithAggregatesFilter>;
  publicKey?: InputMaybe<StringWithAggregatesFilter>;
  runtimeVersion?: InputMaybe<IntWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type WorkersSumAggregate = {
  __typename?: 'WorkersSumAggregate';
  confidenceLevel?: Maybe<Scalars['Int']>;
  currentMinerId?: Maybe<Scalars['BigInt']>;
  currentPid?: Maybe<Scalars['Int']>;
  currentStakePoolId?: Maybe<Scalars['BigInt']>;
  features?: Maybe<Array<Scalars['Int']>>;
  id?: Maybe<Scalars['BigInt']>;
  initialScore?: Maybe<Scalars['Int']>;
  lastUpdatedBlockNumber?: Maybe<Scalars['BigInt']>;
  operatorId?: Maybe<Scalars['BigInt']>;
  runtimeVersion?: Maybe<Scalars['Int']>;
};

export type WorkersSumOrderByAggregateInput = {
  confidenceLevel?: InputMaybe<SortOrder>;
  currentMinerId?: InputMaybe<SortOrder>;
  currentPid?: InputMaybe<SortOrder>;
  currentStakePoolId?: InputMaybe<SortOrder>;
  features?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  initialScore?: InputMaybe<SortOrder>;
  lastUpdatedBlockNumber?: InputMaybe<SortOrder>;
  operatorId?: InputMaybe<SortOrder>;
  runtimeVersion?: InputMaybe<SortOrder>;
};

export type WorkersWhereInput = {
  AND?: InputMaybe<Array<WorkersWhereInput>>;
  NOT?: InputMaybe<Array<WorkersWhereInput>>;
  OR?: InputMaybe<Array<WorkersWhereInput>>;
  accounts?: InputMaybe<AccountsRelationFilter>;
  confidenceLevel?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  currentMinerAccountAddress?: InputMaybe<StringNullableFilter>;
  currentMinerId?: InputMaybe<BigIntNullableFilter>;
  currentPid?: InputMaybe<IntNullableFilter>;
  currentStakePoolId?: InputMaybe<BigIntNullableFilter>;
  ecdhPublicKey?: InputMaybe<StringNullableFilter>;
  features?: InputMaybe<IntNullableListFilter>;
  id?: InputMaybe<BigIntFilter>;
  infoLastUpdatedAt?: InputMaybe<DateTimeFilter>;
  initialScore?: InputMaybe<IntFilter>;
  lastUpdatedBlockNumber?: InputMaybe<BigIntFilter>;
  lastUpdatedTimestamp?: InputMaybe<DateTimeFilter>;
  minersMinersToWorkersCurrentMinerId?: InputMaybe<MinersRelationFilter>;
  minersMinersWorkerIdToWorkers?: InputMaybe<MinersListRelationFilter>;
  operatorAddress?: InputMaybe<StringNullableFilter>;
  operatorId?: InputMaybe<BigIntNullableFilter>;
  publicKey?: InputMaybe<StringFilter>;
  runtimeVersion?: InputMaybe<IntFilter>;
  stakePools?: InputMaybe<StakePoolsRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  workerActivities?: InputMaybe<WorkerActivitiesListRelationFilter>;
};

export type WorkersWhereUniqueInput = {
  ecdhPublicKey?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  publicKey?: InputMaybe<Scalars['String']>;
};

export type StakePoolsQueryVariables = Exact<{
  where?: InputMaybe<StakePoolsWhereInput>;
  orderBy?: InputMaybe<Array<StakePoolsOrderByWithRelationInput> | StakePoolsOrderByWithRelationInput>;
  take?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  withStakePoolStakers?: InputMaybe<Scalars['Boolean']>;
  stakePoolStakersWhere?: InputMaybe<StakePoolStakersWhereInput>;
  withStakePoolWithdrawals?: InputMaybe<Scalars['Boolean']>;
  stakePoolWithdrawalsWhere?: InputMaybe<StakePoolWithdrawalsWhereInput>;
  withMiners?: InputMaybe<Scalars['Boolean']>;
  minersWhere?: InputMaybe<MinersWhereInput>;
}>;


export type StakePoolsQuery = { __typename?: 'Query', findManyStakePools: Array<{ __typename?: 'StakePools', pid: number, ownerAddress: string, commission: string, ownerReward: string, cap?: string | null, rewardAcc: string, totalShares: string, totalStake: string, freeStake: string, releasingStake: string, usedStake: string, remainingStake?: string | null, stakersCount: number, minersCount: number, theoreticalApr: string, withdrawalsCount: number, availableStake: string, stakePoolStakers?: Array<{ __typename?: 'StakePoolStakers', address?: string | null, shares: string, locked: string, availableReward: string, rewardDebt: string, stake: string, pendingReward: string, stakeReward: string, claimableReward: string, instantClaimableReward: string, isOwner: boolean }>, accounts: { __typename?: 'Accounts', identity?: string | null, identityVerified: boolean }, stakePoolWithdrawals?: Array<{ __typename?: 'StakePoolWithdrawals', shares: string, startTime: any, estimatesEndTime: any, stake: string, userAddress?: string | null }>, miners?: Array<{ __typename?: 'Miners', estimatesReclaimableAt?: any | null, workerPublicKey: string, stakes: string }>, stakePoolStats: Array<{ __typename?: 'StakePoolStats', commission?: string | null, commissionUpdatedAt?: any | null, previousCommission?: string | null }> }>, aggregateStakePools: { __typename?: 'AggregateStakePools', _count?: { __typename?: 'StakePoolsCountAggregate', _all: number } | null } };

export type TotalStakeQueryVariables = Exact<{ [key: string]: never; }>;


export type TotalStakeQuery = { __typename?: 'Query', aggregateStakePools: { __typename?: 'AggregateStakePools', _sum?: { __typename?: 'StakePoolsSumAggregate', totalStake?: string | null } | null } };

export type StatesQueryVariables = Exact<{ [key: string]: never; }>;


export type StatesQuery = { __typename?: 'Query', findManyStates: Array<{ __typename?: 'States', integerValue?: number | null, datetimeValue?: any | null }> };

export type MinersQueryVariables = Exact<{
  where?: InputMaybe<MinersWhereInput>;
  orderBy?: InputMaybe<Array<MinersOrderByWithRelationInput> | MinersOrderByWithRelationInput>;
  take?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
}>;


export type MinersQuery = { __typename?: 'Query', findManyMiners: Array<{ __typename?: 'Miners', workerPublicKey: string, pid: number, state: string, v: string, ve: string, pInit: number, pInstant: number, totalReward: string, shares: string, sMin: string, sMax: string, stakes: string, estimatesReclaimableAt?: any | null, stakePools: { __typename?: 'StakePools', freeStake: string } }>, aggregateMiners: { __typename?: 'AggregateMiners', _count?: { __typename?: 'MinersCountAggregate', _all: number } | null } };

export type StakePoolQueryVariables = Exact<{
  where: StakePoolsWhereUniqueInput;
}>;


export type StakePoolQuery = { __typename?: 'Query', findUniqueStakePools?: { __typename?: 'StakePools', pid: number, ownerAddress: string, commission: string, ownerReward: string, cap?: string | null, rewardAcc: string, totalShares: string, totalStake: string, freeStake: string, releasingStake: string, remainingStake?: string | null, theoreticalApr: string, stakersCount: number, withdrawalsCount: number, minersCount: number, idleMinersCount: number, availableStake: string, accounts: { __typename?: 'Accounts', identity?: string | null, identityVerified: boolean }, stakePoolWithdrawals: Array<{ __typename?: 'StakePoolWithdrawals', shares: string, startTime: any, estimatesEndTime: any, stake: string, userAddress?: string | null }>, stakePoolStats: Array<{ __typename?: 'StakePoolStats', commission?: string | null, commissionUpdatedAt?: any | null, previousCommission?: string | null }> } | null };


export const StakePoolsDocument = `
    query StakePools($where: StakePoolsWhereInput, $orderBy: [StakePoolsOrderByWithRelationInput!], $take: Int, $skip: Int, $withStakePoolStakers: Boolean = false, $stakePoolStakersWhere: StakePoolStakersWhereInput, $withStakePoolWithdrawals: Boolean = false, $stakePoolWithdrawalsWhere: StakePoolWithdrawalsWhereInput, $withMiners: Boolean = false, $minersWhere: MinersWhereInput) {
  findManyStakePools(where: $where, orderBy: $orderBy, take: $take, skip: $skip) {
    pid
    ownerAddress
    commission
    ownerReward
    cap
    rewardAcc
    totalShares
    totalStake
    freeStake
    releasingStake
    usedStake
    remainingStake
    stakersCount
    minersCount
    theoreticalApr
    stakePoolStakers(where: $stakePoolStakersWhere) @include(if: $withStakePoolStakers) {
      address
      shares
      locked
      availableReward
      rewardDebt
      stake
      pendingReward
      stakeReward
      claimableReward
      instantClaimableReward
      isOwner
    }
    accounts {
      identity
      identityVerified
    }
    stakePoolWithdrawals(where: $stakePoolWithdrawalsWhere) @include(if: $withStakePoolWithdrawals) {
      shares
      startTime
      estimatesEndTime
      stake
      userAddress
    }
    miners(where: $minersWhere) @include(if: $withMiners) {
      estimatesReclaimableAt
      workerPublicKey
      stakes
    }
    withdrawalsCount
    stakePoolStats {
      commission
      commissionUpdatedAt
      previousCommission
    }
    availableStake
  }
  aggregateStakePools(where: $where) {
    _count {
      _all
    }
  }
}
    `;
export const useStakePoolsQuery = <
      TData = StakePoolsQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: StakePoolsQueryVariables,
      options?: UseQueryOptions<StakePoolsQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<StakePoolsQuery, TError, TData>(
      variables === undefined ? ['StakePools'] : ['StakePools', variables],
      fetcher<StakePoolsQuery, StakePoolsQueryVariables>(client, StakePoolsDocument, variables, headers),
      options
    );
export const TotalStakeDocument = `
    query TotalStake {
  aggregateStakePools {
    _sum {
      totalStake
    }
  }
}
    `;
export const useTotalStakeQuery = <
      TData = TotalStakeQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: TotalStakeQueryVariables,
      options?: UseQueryOptions<TotalStakeQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<TotalStakeQuery, TError, TData>(
      variables === undefined ? ['TotalStake'] : ['TotalStake', variables],
      fetcher<TotalStakeQuery, TotalStakeQueryVariables>(client, TotalStakeDocument, variables, headers),
      options
    );
export const StatesDocument = `
    query States {
  findManyStates {
    integerValue
    datetimeValue
  }
}
    `;
export const useStatesQuery = <
      TData = StatesQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: StatesQueryVariables,
      options?: UseQueryOptions<StatesQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<StatesQuery, TError, TData>(
      variables === undefined ? ['States'] : ['States', variables],
      fetcher<StatesQuery, StatesQueryVariables>(client, StatesDocument, variables, headers),
      options
    );
export const MinersDocument = `
    query Miners($where: MinersWhereInput, $orderBy: [MinersOrderByWithRelationInput!], $take: Int, $skip: Int) {
  findManyMiners(where: $where, orderBy: $orderBy, take: $take, skip: $skip) {
    workerPublicKey
    pid
    state
    v
    ve
    pInit
    pInstant
    totalReward
    shares
    sMin
    sMax
    stakes
    estimatesReclaimableAt
    stakePools {
      freeStake
    }
  }
  aggregateMiners(where: $where) {
    _count {
      _all
    }
  }
}
    `;
export const useMinersQuery = <
      TData = MinersQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: MinersQueryVariables,
      options?: UseQueryOptions<MinersQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<MinersQuery, TError, TData>(
      variables === undefined ? ['Miners'] : ['Miners', variables],
      fetcher<MinersQuery, MinersQueryVariables>(client, MinersDocument, variables, headers),
      options
    );
export const StakePoolDocument = `
    query StakePool($where: StakePoolsWhereUniqueInput!) {
  findUniqueStakePools(where: $where) {
    pid
    ownerAddress
    commission
    ownerReward
    cap
    rewardAcc
    totalShares
    totalStake
    freeStake
    releasingStake
    remainingStake
    theoreticalApr
    stakersCount
    withdrawalsCount
    minersCount
    accounts {
      identity
      identityVerified
    }
    stakePoolWithdrawals {
      shares
      startTime
      estimatesEndTime
      stake
      userAddress
    }
    stakePoolStats {
      commission
      commissionUpdatedAt
      previousCommission
    }
    idleMinersCount
    availableStake
  }
}
    `;
export const useStakePoolQuery = <
      TData = StakePoolQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables: StakePoolQueryVariables,
      options?: UseQueryOptions<StakePoolQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<StakePoolQuery, TError, TData>(
      ['StakePool', variables],
      fetcher<StakePoolQuery, StakePoolQueryVariables>(client, StakePoolDocument, variables, headers),
      options
    );