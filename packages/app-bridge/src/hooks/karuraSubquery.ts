/* eslint-disable */
/* This file is generated by graphql-codegen, don't edit it directly. */
import { GraphQLClient } from 'graphql-request';
import { RequestInit } from 'graphql-request/dist/types.dom';
import { useQuery, UseQueryOptions } from 'react-query';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

function fetcher<TData, TVariables>(client: GraphQLClient, query: string, variables?: TVariables, headers?: RequestInit['headers']) {
  return async (): Promise<TData> => client.request<TData, TVariables>(query, variables, headers);
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: string;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: string;
  /** The day, does not include a time. */
  Date: string;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
};

/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export type BigFloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigFloat']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigFloat']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigFloat']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigFloat']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigFloat']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigFloat']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigFloat']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigFloat']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigFloat']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigFloat']>>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']>>;
};

export type CurrencyDeposit = Node & {
  __typename?: 'CurrencyDeposit';
  amount: Scalars['BigFloat'];
  createdAt: Scalars['Datetime'];
  currencyId: Scalars['String'];
  id: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  recipient: Scalars['String'];
};

export type CurrencyDepositAggregates = {
  __typename?: 'CurrencyDepositAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `CurrencyDeposit` object types. All fields are combined with a logical ‘and.’ */
export type CurrencyDepositFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CurrencyDepositFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currencyId` field. */
  currencyId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CurrencyDepositFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CurrencyDepositFilter>>;
  /** Filter by the object’s `recipient` field. */
  recipient?: InputMaybe<StringFilter>;
};

/** A connection to a list of `CurrencyDeposit` values. */
export type CurrencyDepositsConnection = {
  __typename?: 'CurrencyDepositsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<CurrencyDepositAggregates>;
  /** A list of edges which contains the `CurrencyDeposit` and cursor to aid in pagination. */
  edges: Array<CurrencyDepositsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<CurrencyDepositAggregates>>;
  /** A list of `CurrencyDeposit` objects. */
  nodes: Array<Maybe<CurrencyDeposit>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CurrencyDeposit` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `CurrencyDeposit` values. */
export type CurrencyDepositsConnectionGroupedAggregatesArgs = {
  groupBy: Array<CurrencyDepositsGroupBy>;
  having?: InputMaybe<CurrencyDepositsHavingInput>;
};

/** A `CurrencyDeposit` edge in the connection. */
export type CurrencyDepositsEdge = {
  __typename?: 'CurrencyDepositsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CurrencyDeposit` at the end of the edge. */
  node?: Maybe<CurrencyDeposit>;
};

/** Grouping methods for `CurrencyDeposit` for usage during aggregation. */
export enum CurrencyDepositsGroupBy {
  Amount = 'AMOUNT',
  CreatedAt = 'CREATED_AT',
  CurrencyId = 'CURRENCY_ID',
  Recipient = 'RECIPIENT'
}

/** Conditions for `CurrencyDeposit` aggregates. */
export type CurrencyDepositsHavingInput = {
  AND?: InputMaybe<Array<CurrencyDepositsHavingInput>>;
  OR?: InputMaybe<Array<CurrencyDepositsHavingInput>>;
};

/** Methods to use when ordering `CurrencyDeposit`. */
export enum CurrencyDepositsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CurrencyIdAsc = 'CURRENCY_ID_ASC',
  CurrencyIdDesc = 'CURRENCY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecipientAsc = 'RECIPIENT_ASC',
  RecipientDesc = 'RECIPIENT_DESC'
}

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']>>;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  _metadata?: Maybe<_Metadata>;
  currencyDeposit?: Maybe<CurrencyDeposit>;
  /** Reads a single `CurrencyDeposit` using its globally unique `ID`. */
  currencyDepositByNodeId?: Maybe<CurrencyDeposit>;
  /** Reads and enables pagination through a set of `CurrencyDeposit`. */
  currencyDeposits?: Maybe<CurrencyDepositsConnection>;
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  xTokenSent?: Maybe<XTokenSent>;
  /** Reads a single `XTokenSent` using its globally unique `ID`. */
  xTokenSentByNodeId?: Maybe<XTokenSent>;
  /** Reads and enables pagination through a set of `XTokenSent`. */
  xTokenSents?: Maybe<XTokenSentsConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrencyDepositArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrencyDepositByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrencyDepositsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<CurrencyDepositFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrencyDepositsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryXTokenSentArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryXTokenSentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryXTokenSentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<XTokenSentFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<XTokenSentsOrderBy>>;
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']>;
};

export type TableEstimate = {
  __typename?: 'TableEstimate';
  estimate?: Maybe<Scalars['Int']>;
  table?: Maybe<Scalars['String']>;
};

export type XTokenSent = Node & {
  __typename?: 'XTokenSent';
  amount: Scalars['BigFloat'];
  createdAt: Scalars['Datetime'];
  currencyLocation: Scalars['String'];
  destChain?: Maybe<Scalars['BigFloat']>;
  hash: Scalars['String'];
  id: Scalars['String'];
  isX3: Scalars['Boolean'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  recipient: Scalars['String'];
  sender: Scalars['String'];
};

export type XTokenSentAggregates = {
  __typename?: 'XTokenSentAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `XTokenSent` object types. All fields are combined with a logical ‘and.’ */
export type XTokenSentFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<XTokenSentFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currencyLocation` field. */
  currencyLocation?: InputMaybe<StringFilter>;
  /** Filter by the object’s `destChain` field. */
  destChain?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `hash` field. */
  hash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isX3` field. */
  isX3?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<XTokenSentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<XTokenSentFilter>>;
  /** Filter by the object’s `recipient` field. */
  recipient?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sender` field. */
  sender?: InputMaybe<StringFilter>;
};

/** A connection to a list of `XTokenSent` values. */
export type XTokenSentsConnection = {
  __typename?: 'XTokenSentsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<XTokenSentAggregates>;
  /** A list of edges which contains the `XTokenSent` and cursor to aid in pagination. */
  edges: Array<XTokenSentsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<XTokenSentAggregates>>;
  /** A list of `XTokenSent` objects. */
  nodes: Array<Maybe<XTokenSent>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `XTokenSent` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `XTokenSent` values. */
export type XTokenSentsConnectionGroupedAggregatesArgs = {
  groupBy: Array<XTokenSentsGroupBy>;
  having?: InputMaybe<XTokenSentsHavingInput>;
};

/** A `XTokenSent` edge in the connection. */
export type XTokenSentsEdge = {
  __typename?: 'XTokenSentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `XTokenSent` at the end of the edge. */
  node?: Maybe<XTokenSent>;
};

/** Grouping methods for `XTokenSent` for usage during aggregation. */
export enum XTokenSentsGroupBy {
  Amount = 'AMOUNT',
  CreatedAt = 'CREATED_AT',
  CurrencyLocation = 'CURRENCY_LOCATION',
  DestChain = 'DEST_CHAIN',
  Hash = 'HASH',
  IsX3 = 'IS_X3',
  Recipient = 'RECIPIENT',
  Sender = 'SENDER'
}

/** Conditions for `XTokenSent` aggregates. */
export type XTokenSentsHavingInput = {
  AND?: InputMaybe<Array<XTokenSentsHavingInput>>;
  OR?: InputMaybe<Array<XTokenSentsHavingInput>>;
};

/** Methods to use when ordering `XTokenSent`. */
export enum XTokenSentsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CurrencyLocationAsc = 'CURRENCY_LOCATION_ASC',
  CurrencyLocationDesc = 'CURRENCY_LOCATION_DESC',
  DestChainAsc = 'DEST_CHAIN_ASC',
  DestChainDesc = 'DEST_CHAIN_DESC',
  HashAsc = 'HASH_ASC',
  HashDesc = 'HASH_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsX3Asc = 'IS_X3_ASC',
  IsX3Desc = 'IS_X3_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecipientAsc = 'RECIPIENT_ASC',
  RecipientDesc = 'RECIPIENT_DESC',
  SenderAsc = 'SENDER_ASC',
  SenderDesc = 'SENDER_DESC'
}

export type _Metadata = {
  __typename?: '_Metadata';
  chain?: Maybe<Scalars['String']>;
  dynamicDatasources?: Maybe<Scalars['String']>;
  genesisHash?: Maybe<Scalars['String']>;
  indexerHealthy?: Maybe<Scalars['Boolean']>;
  indexerNodeVersion?: Maybe<Scalars['String']>;
  lastProcessedHeight?: Maybe<Scalars['Int']>;
  lastProcessedTimestamp?: Maybe<Scalars['Date']>;
  queryNodeVersion?: Maybe<Scalars['String']>;
  rowCountEstimate?: Maybe<Array<Maybe<TableEstimate>>>;
  specName?: Maybe<Scalars['String']>;
  targetHeight?: Maybe<Scalars['Int']>;
};

export type CurrencyDepositsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  filter?: InputMaybe<CurrencyDepositFilter>;
  orderBy?: InputMaybe<Array<CurrencyDepositsOrderBy> | CurrencyDepositsOrderBy>;
}>;


export type CurrencyDepositsQuery = { __typename?: 'Query', currencyDeposits?: { __typename?: 'CurrencyDepositsConnection', nodes: Array<{ __typename?: 'CurrencyDeposit', nodeId: string, id: string, createdAt: string, currencyId: string, recipient: string, amount: string } | null> } | null };


export const CurrencyDepositsDocument = `
    query CurrencyDeposits($first: Int, $offset: Int, $filter: CurrencyDepositFilter, $orderBy: [CurrencyDepositsOrderBy!]) {
  currencyDeposits(
    first: $first
    offset: $offset
    filter: $filter
    orderBy: $orderBy
  ) {
    nodes {
      nodeId
      id
      createdAt
      currencyId
      recipient
      amount
    }
  }
}
    `;
export const useCurrencyDepositsQuery = <
      TData = CurrencyDepositsQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: CurrencyDepositsQueryVariables,
      options?: UseQueryOptions<CurrencyDepositsQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<CurrencyDepositsQuery, TError, TData>(
      variables === undefined ? ['CurrencyDeposits'] : ['CurrencyDeposits', variables],
      fetcher<CurrencyDepositsQuery, CurrencyDepositsQueryVariables>(client, CurrencyDepositsDocument, variables, headers),
      options
    );