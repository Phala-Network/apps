/* eslint-disable */
/* This file is generated by graphql-codegen, don't edit it directly. */
import { GraphQLClient } from 'graphql-request';
import { RequestInit } from 'graphql-request/dist/types.dom';
import { useQuery, UseQueryOptions } from 'react-query';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

function fetcher<TData, TVariables>(client: GraphQLClient, query: string, variables?: TVariables, headers?: RequestInit['headers']) {
  return async (): Promise<TData> => client.request<TData, TVariables>(query, variables, headers);
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: string;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: string;
  /** The day, does not include a time. */
  Date: string;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: any;
};

/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export type BigFloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigFloat']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigFloat']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigFloat']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigFloat']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigFloat']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigFloat']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigFloat']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigFloat']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigFloat']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigFloat']>>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']>>;
};

export type BridgeDeposited = Node & {
  __typename?: 'BridgeDeposited';
  amount?: Maybe<Scalars['BigFloat']>;
  asset: Scalars['String'];
  createdAt: Scalars['Datetime'];
  id: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  recipient: Scalars['String'];
};

export type BridgeDepositedAggregates = {
  __typename?: 'BridgeDepositedAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `BridgeDeposited` object types. All fields are combined with a logical ‘and.’ */
export type BridgeDepositedFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BridgeDepositedFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BridgeDepositedFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BridgeDepositedFilter>>;
  /** Filter by the object’s `recipient` field. */
  recipient?: InputMaybe<StringFilter>;
};

/** A connection to a list of `BridgeDeposited` values. */
export type BridgeDepositedsConnection = {
  __typename?: 'BridgeDepositedsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BridgeDepositedAggregates>;
  /** A list of edges which contains the `BridgeDeposited` and cursor to aid in pagination. */
  edges: Array<BridgeDepositedsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BridgeDepositedAggregates>>;
  /** A list of `BridgeDeposited` objects. */
  nodes: Array<Maybe<BridgeDeposited>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BridgeDeposited` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `BridgeDeposited` values. */
export type BridgeDepositedsConnectionGroupedAggregatesArgs = {
  groupBy: Array<BridgeDepositedsGroupBy>;
  having?: InputMaybe<BridgeDepositedsHavingInput>;
};

/** A `BridgeDeposited` edge in the connection. */
export type BridgeDepositedsEdge = {
  __typename?: 'BridgeDepositedsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `BridgeDeposited` at the end of the edge. */
  node?: Maybe<BridgeDeposited>;
};

/** Grouping methods for `BridgeDeposited` for usage during aggregation. */
export enum BridgeDepositedsGroupBy {
  Amount = 'AMOUNT',
  Asset = 'ASSET',
  CreatedAt = 'CREATED_AT',
  Recipient = 'RECIPIENT'
}

/** Conditions for `BridgeDeposited` aggregates. */
export type BridgeDepositedsHavingInput = {
  AND?: InputMaybe<Array<BridgeDepositedsHavingInput>>;
  OR?: InputMaybe<Array<BridgeDepositedsHavingInput>>;
};

/** Methods to use when ordering `BridgeDeposited`. */
export enum BridgeDepositedsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AssetAsc = 'ASSET_ASC',
  AssetDesc = 'ASSET_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecipientAsc = 'RECIPIENT_ASC',
  RecipientDesc = 'RECIPIENT_DESC'
}

export type BridgeForwarded = Node & {
  __typename?: 'BridgeForwarded';
  amount?: Maybe<Scalars['BigFloat']>;
  asset: Scalars['String'];
  createdAt: Scalars['Datetime'];
  dest: Scalars['String'];
  id: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  recipient: Scalars['String'];
};

export type BridgeForwardedAggregates = {
  __typename?: 'BridgeForwardedAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `BridgeForwarded` object types. All fields are combined with a logical ‘and.’ */
export type BridgeForwardedFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BridgeForwardedFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `dest` field. */
  dest?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BridgeForwardedFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BridgeForwardedFilter>>;
  /** Filter by the object’s `recipient` field. */
  recipient?: InputMaybe<StringFilter>;
};

/** A connection to a list of `BridgeForwarded` values. */
export type BridgeForwardedsConnection = {
  __typename?: 'BridgeForwardedsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BridgeForwardedAggregates>;
  /** A list of edges which contains the `BridgeForwarded` and cursor to aid in pagination. */
  edges: Array<BridgeForwardedsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BridgeForwardedAggregates>>;
  /** A list of `BridgeForwarded` objects. */
  nodes: Array<Maybe<BridgeForwarded>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BridgeForwarded` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `BridgeForwarded` values. */
export type BridgeForwardedsConnectionGroupedAggregatesArgs = {
  groupBy: Array<BridgeForwardedsGroupBy>;
  having?: InputMaybe<BridgeForwardedsHavingInput>;
};

/** A `BridgeForwarded` edge in the connection. */
export type BridgeForwardedsEdge = {
  __typename?: 'BridgeForwardedsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `BridgeForwarded` at the end of the edge. */
  node?: Maybe<BridgeForwarded>;
};

/** Grouping methods for `BridgeForwarded` for usage during aggregation. */
export enum BridgeForwardedsGroupBy {
  Amount = 'AMOUNT',
  Asset = 'ASSET',
  CreatedAt = 'CREATED_AT',
  Dest = 'DEST',
  Recipient = 'RECIPIENT'
}

/** Conditions for `BridgeForwarded` aggregates. */
export type BridgeForwardedsHavingInput = {
  AND?: InputMaybe<Array<BridgeForwardedsHavingInput>>;
  OR?: InputMaybe<Array<BridgeForwardedsHavingInput>>;
};

/** Methods to use when ordering `BridgeForwarded`. */
export enum BridgeForwardedsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AssetAsc = 'ASSET_ASC',
  AssetDesc = 'ASSET_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DestAsc = 'DEST_ASC',
  DestDesc = 'DEST_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecipientAsc = 'RECIPIENT_ASC',
  RecipientDesc = 'RECIPIENT_DESC'
}

export type BridgeInboundingRecord = Node & {
  __typename?: 'BridgeInboundingRecord';
  createdAt: Scalars['Datetime'];
  depositNonce: Scalars['BigFloat'];
  executeTx?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  originChainId: Scalars['Int'];
  resourceId: Scalars['String'];
  status: Scalars['String'];
  voteTxs: Scalars['JSON'];
};

export type BridgeInboundingRecordAggregates = {
  __typename?: 'BridgeInboundingRecordAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `BridgeInboundingRecord` object types. All fields are combined with a logical ‘and.’ */
export type BridgeInboundingRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BridgeInboundingRecordFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `depositNonce` field. */
  depositNonce?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `executeTx` field. */
  executeTx?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BridgeInboundingRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BridgeInboundingRecordFilter>>;
  /** Filter by the object’s `originChainId` field. */
  originChainId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `resourceId` field. */
  resourceId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voteTxs` field. */
  voteTxs?: InputMaybe<JsonFilter>;
};

/** A connection to a list of `BridgeInboundingRecord` values. */
export type BridgeInboundingRecordsConnection = {
  __typename?: 'BridgeInboundingRecordsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BridgeInboundingRecordAggregates>;
  /** A list of edges which contains the `BridgeInboundingRecord` and cursor to aid in pagination. */
  edges: Array<BridgeInboundingRecordsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BridgeInboundingRecordAggregates>>;
  /** A list of `BridgeInboundingRecord` objects. */
  nodes: Array<Maybe<BridgeInboundingRecord>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BridgeInboundingRecord` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `BridgeInboundingRecord` values. */
export type BridgeInboundingRecordsConnectionGroupedAggregatesArgs = {
  groupBy: Array<BridgeInboundingRecordsGroupBy>;
  having?: InputMaybe<BridgeInboundingRecordsHavingInput>;
};

/** A `BridgeInboundingRecord` edge in the connection. */
export type BridgeInboundingRecordsEdge = {
  __typename?: 'BridgeInboundingRecordsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `BridgeInboundingRecord` at the end of the edge. */
  node?: Maybe<BridgeInboundingRecord>;
};

/** Grouping methods for `BridgeInboundingRecord` for usage during aggregation. */
export enum BridgeInboundingRecordsGroupBy {
  CreatedAt = 'CREATED_AT',
  DepositNonce = 'DEPOSIT_NONCE',
  ExecuteTx = 'EXECUTE_TX',
  OriginChainId = 'ORIGIN_CHAIN_ID',
  ResourceId = 'RESOURCE_ID',
  Status = 'STATUS',
  VoteTxs = 'VOTE_TXS'
}

/** Conditions for `BridgeInboundingRecord` aggregates. */
export type BridgeInboundingRecordsHavingInput = {
  AND?: InputMaybe<Array<BridgeInboundingRecordsHavingInput>>;
  OR?: InputMaybe<Array<BridgeInboundingRecordsHavingInput>>;
};

/** Methods to use when ordering `BridgeInboundingRecord`. */
export enum BridgeInboundingRecordsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DepositNonceAsc = 'DEPOSIT_NONCE_ASC',
  DepositNonceDesc = 'DEPOSIT_NONCE_DESC',
  ExecuteTxAsc = 'EXECUTE_TX_ASC',
  ExecuteTxDesc = 'EXECUTE_TX_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OriginChainIdAsc = 'ORIGIN_CHAIN_ID_ASC',
  OriginChainIdDesc = 'ORIGIN_CHAIN_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ResourceIdAsc = 'RESOURCE_ID_ASC',
  ResourceIdDesc = 'RESOURCE_ID_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  VoteTxsAsc = 'VOTE_TXS_ASC',
  VoteTxsDesc = 'VOTE_TXS_DESC'
}

export type BridgeOutboundingRecord = Node & {
  __typename?: 'BridgeOutboundingRecord';
  amount?: Maybe<Scalars['BigFloat']>;
  createdAt: Scalars['Datetime'];
  depositNonce: Scalars['BigFloat'];
  destChainId: Scalars['Int'];
  id: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  recipient?: Maybe<Scalars['String']>;
  resourceId: Scalars['String'];
  sendTx?: Maybe<Scalars['String']>;
  sender?: Maybe<Scalars['String']>;
};

export type BridgeOutboundingRecordAggregates = {
  __typename?: 'BridgeOutboundingRecordAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `BridgeOutboundingRecord` object types. All fields are combined with a logical ‘and.’ */
export type BridgeOutboundingRecordFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BridgeOutboundingRecordFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `depositNonce` field. */
  depositNonce?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `destChainId` field. */
  destChainId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BridgeOutboundingRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BridgeOutboundingRecordFilter>>;
  /** Filter by the object’s `recipient` field. */
  recipient?: InputMaybe<StringFilter>;
  /** Filter by the object’s `resourceId` field. */
  resourceId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sendTx` field. */
  sendTx?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sender` field. */
  sender?: InputMaybe<StringFilter>;
};

/** A connection to a list of `BridgeOutboundingRecord` values. */
export type BridgeOutboundingRecordsConnection = {
  __typename?: 'BridgeOutboundingRecordsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BridgeOutboundingRecordAggregates>;
  /** A list of edges which contains the `BridgeOutboundingRecord` and cursor to aid in pagination. */
  edges: Array<BridgeOutboundingRecordsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BridgeOutboundingRecordAggregates>>;
  /** A list of `BridgeOutboundingRecord` objects. */
  nodes: Array<Maybe<BridgeOutboundingRecord>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BridgeOutboundingRecord` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `BridgeOutboundingRecord` values. */
export type BridgeOutboundingRecordsConnectionGroupedAggregatesArgs = {
  groupBy: Array<BridgeOutboundingRecordsGroupBy>;
  having?: InputMaybe<BridgeOutboundingRecordsHavingInput>;
};

/** A `BridgeOutboundingRecord` edge in the connection. */
export type BridgeOutboundingRecordsEdge = {
  __typename?: 'BridgeOutboundingRecordsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `BridgeOutboundingRecord` at the end of the edge. */
  node?: Maybe<BridgeOutboundingRecord>;
};

/** Grouping methods for `BridgeOutboundingRecord` for usage during aggregation. */
export enum BridgeOutboundingRecordsGroupBy {
  Amount = 'AMOUNT',
  CreatedAt = 'CREATED_AT',
  DepositNonce = 'DEPOSIT_NONCE',
  DestChainId = 'DEST_CHAIN_ID',
  Recipient = 'RECIPIENT',
  ResourceId = 'RESOURCE_ID',
  Sender = 'SENDER',
  SendTx = 'SEND_TX'
}

/** Conditions for `BridgeOutboundingRecord` aggregates. */
export type BridgeOutboundingRecordsHavingInput = {
  AND?: InputMaybe<Array<BridgeOutboundingRecordsHavingInput>>;
  OR?: InputMaybe<Array<BridgeOutboundingRecordsHavingInput>>;
};

/** Methods to use when ordering `BridgeOutboundingRecord`. */
export enum BridgeOutboundingRecordsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DepositNonceAsc = 'DEPOSIT_NONCE_ASC',
  DepositNonceDesc = 'DEPOSIT_NONCE_DESC',
  DestChainIdAsc = 'DEST_CHAIN_ID_ASC',
  DestChainIdDesc = 'DEST_CHAIN_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecipientAsc = 'RECIPIENT_ASC',
  RecipientDesc = 'RECIPIENT_DESC',
  ResourceIdAsc = 'RESOURCE_ID_ASC',
  ResourceIdDesc = 'RESOURCE_ID_DESC',
  SenderAsc = 'SENDER_ASC',
  SenderDesc = 'SENDER_DESC',
  SendTxAsc = 'SEND_TX_ASC',
  SendTxDesc = 'SEND_TX_DESC'
}

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']>>;
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Contained by the specified JSON. */
  containedBy?: InputMaybe<Scalars['JSON']>;
  /** Contains the specified JSON. */
  contains?: InputMaybe<Scalars['JSON']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: InputMaybe<Array<Scalars['String']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: InputMaybe<Array<Scalars['String']>>;
  /** Contains the specified key. */
  containsKey?: InputMaybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['JSON']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['JSON']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['JSON']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['JSON']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['JSON']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['JSON']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['JSON']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['JSON']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['JSON']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['JSON']>>;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  _metadata?: Maybe<_Metadata>;
  bridgeDeposited?: Maybe<BridgeDeposited>;
  /** Reads a single `BridgeDeposited` using its globally unique `ID`. */
  bridgeDepositedByNodeId?: Maybe<BridgeDeposited>;
  /** Reads and enables pagination through a set of `BridgeDeposited`. */
  bridgeDepositeds?: Maybe<BridgeDepositedsConnection>;
  bridgeForwarded?: Maybe<BridgeForwarded>;
  /** Reads a single `BridgeForwarded` using its globally unique `ID`. */
  bridgeForwardedByNodeId?: Maybe<BridgeForwarded>;
  /** Reads and enables pagination through a set of `BridgeForwarded`. */
  bridgeForwardeds?: Maybe<BridgeForwardedsConnection>;
  bridgeInboundingRecord?: Maybe<BridgeInboundingRecord>;
  /** Reads a single `BridgeInboundingRecord` using its globally unique `ID`. */
  bridgeInboundingRecordByNodeId?: Maybe<BridgeInboundingRecord>;
  /** Reads and enables pagination through a set of `BridgeInboundingRecord`. */
  bridgeInboundingRecords?: Maybe<BridgeInboundingRecordsConnection>;
  bridgeOutboundingRecord?: Maybe<BridgeOutboundingRecord>;
  /** Reads a single `BridgeOutboundingRecord` using its globally unique `ID`. */
  bridgeOutboundingRecordByNodeId?: Maybe<BridgeOutboundingRecord>;
  /** Reads and enables pagination through a set of `BridgeOutboundingRecord`. */
  bridgeOutboundingRecords?: Maybe<BridgeOutboundingRecordsConnection>;
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  tx?: Maybe<Tx>;
  /** Reads a single `Tx` using its globally unique `ID`. */
  txByNodeId?: Maybe<Tx>;
  /** Reads and enables pagination through a set of `Tx`. */
  txes?: Maybe<TxesConnection>;
  xcmDeposited?: Maybe<XcmDeposited>;
  /** Reads a single `XcmDeposited` using its globally unique `ID`. */
  xcmDepositedByNodeId?: Maybe<XcmDeposited>;
  /** Reads and enables pagination through a set of `XcmDeposited`. */
  xcmDepositeds?: Maybe<XcmDepositedsConnection>;
  xcmTransfered?: Maybe<XcmTransfered>;
  /** Reads a single `XcmTransfered` using its globally unique `ID`. */
  xcmTransferedByNodeId?: Maybe<XcmTransfered>;
  /** Reads and enables pagination through a set of `XcmTransfered`. */
  xcmTransfereds?: Maybe<XcmTransferedsConnection>;
  xcmWithdrawn?: Maybe<XcmWithdrawn>;
  /** Reads a single `XcmWithdrawn` using its globally unique `ID`. */
  xcmWithdrawnByNodeId?: Maybe<XcmWithdrawn>;
  /** Reads and enables pagination through a set of `XcmWithdrawn`. */
  xcmWithdrawns?: Maybe<XcmWithdrawnsConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryBridgeDepositedArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBridgeDepositedByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBridgeDepositedsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<BridgeDepositedFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BridgeDepositedsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryBridgeForwardedArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBridgeForwardedByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBridgeForwardedsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<BridgeForwardedFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BridgeForwardedsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryBridgeInboundingRecordArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBridgeInboundingRecordByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBridgeInboundingRecordsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<BridgeInboundingRecordFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BridgeInboundingRecordsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryBridgeOutboundingRecordArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBridgeOutboundingRecordByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBridgeOutboundingRecordsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<BridgeOutboundingRecordFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BridgeOutboundingRecordsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTxArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTxByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTxesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<TxFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TxesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryXcmDepositedArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryXcmDepositedByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryXcmDepositedsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<XcmDepositedFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<XcmDepositedsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryXcmTransferedArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryXcmTransferedByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryXcmTransferedsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<XcmTransferedFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<XcmTransferedsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryXcmWithdrawnArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryXcmWithdrawnByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryXcmWithdrawnsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<XcmWithdrawnFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<XcmWithdrawnsOrderBy>>;
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']>;
};

export type TableEstimate = {
  __typename?: 'TableEstimate';
  estimate?: Maybe<Scalars['Int']>;
  table?: Maybe<Scalars['String']>;
};

export type Tx = Node & {
  __typename?: 'Tx';
  hash: Scalars['String'];
  id: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  sender: Scalars['String'];
};

export type TxAggregates = {
  __typename?: 'TxAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Tx` object types. All fields are combined with a logical ‘and.’ */
export type TxFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TxFilter>>;
  /** Filter by the object’s `hash` field. */
  hash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TxFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TxFilter>>;
  /** Filter by the object’s `sender` field. */
  sender?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Tx` values. */
export type TxesConnection = {
  __typename?: 'TxesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TxAggregates>;
  /** A list of edges which contains the `Tx` and cursor to aid in pagination. */
  edges: Array<TxesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TxAggregates>>;
  /** A list of `Tx` objects. */
  nodes: Array<Maybe<Tx>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tx` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `Tx` values. */
export type TxesConnectionGroupedAggregatesArgs = {
  groupBy: Array<TxesGroupBy>;
  having?: InputMaybe<TxesHavingInput>;
};

/** A `Tx` edge in the connection. */
export type TxesEdge = {
  __typename?: 'TxesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Tx` at the end of the edge. */
  node?: Maybe<Tx>;
};

/** Grouping methods for `Tx` for usage during aggregation. */
export enum TxesGroupBy {
  Hash = 'HASH',
  Sender = 'SENDER'
}

/** Conditions for `Tx` aggregates. */
export type TxesHavingInput = {
  AND?: InputMaybe<Array<TxesHavingInput>>;
  OR?: InputMaybe<Array<TxesHavingInput>>;
};

/** Methods to use when ordering `Tx`. */
export enum TxesOrderBy {
  HashAsc = 'HASH_ASC',
  HashDesc = 'HASH_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SenderAsc = 'SENDER_ASC',
  SenderDesc = 'SENDER_DESC'
}

export type XcmDeposited = Node & {
  __typename?: 'XcmDeposited';
  amount?: Maybe<Scalars['BigFloat']>;
  asset: Scalars['String'];
  createdAt: Scalars['Datetime'];
  id: Scalars['String'];
  isForward?: Maybe<Scalars['Boolean']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  recipient: Scalars['String'];
};

export type XcmDepositedAggregates = {
  __typename?: 'XcmDepositedAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `XcmDeposited` object types. All fields are combined with a logical ‘and.’ */
export type XcmDepositedFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<XcmDepositedFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isForward` field. */
  isForward?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<XcmDepositedFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<XcmDepositedFilter>>;
  /** Filter by the object’s `recipient` field. */
  recipient?: InputMaybe<StringFilter>;
};

/** A connection to a list of `XcmDeposited` values. */
export type XcmDepositedsConnection = {
  __typename?: 'XcmDepositedsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<XcmDepositedAggregates>;
  /** A list of edges which contains the `XcmDeposited` and cursor to aid in pagination. */
  edges: Array<XcmDepositedsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<XcmDepositedAggregates>>;
  /** A list of `XcmDeposited` objects. */
  nodes: Array<Maybe<XcmDeposited>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `XcmDeposited` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `XcmDeposited` values. */
export type XcmDepositedsConnectionGroupedAggregatesArgs = {
  groupBy: Array<XcmDepositedsGroupBy>;
  having?: InputMaybe<XcmDepositedsHavingInput>;
};

/** A `XcmDeposited` edge in the connection. */
export type XcmDepositedsEdge = {
  __typename?: 'XcmDepositedsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `XcmDeposited` at the end of the edge. */
  node?: Maybe<XcmDeposited>;
};

/** Grouping methods for `XcmDeposited` for usage during aggregation. */
export enum XcmDepositedsGroupBy {
  Amount = 'AMOUNT',
  Asset = 'ASSET',
  CreatedAt = 'CREATED_AT',
  IsForward = 'IS_FORWARD',
  Recipient = 'RECIPIENT'
}

/** Conditions for `XcmDeposited` aggregates. */
export type XcmDepositedsHavingInput = {
  AND?: InputMaybe<Array<XcmDepositedsHavingInput>>;
  OR?: InputMaybe<Array<XcmDepositedsHavingInput>>;
};

/** Methods to use when ordering `XcmDeposited`. */
export enum XcmDepositedsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AssetAsc = 'ASSET_ASC',
  AssetDesc = 'ASSET_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsForwardAsc = 'IS_FORWARD_ASC',
  IsForwardDesc = 'IS_FORWARD_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecipientAsc = 'RECIPIENT_ASC',
  RecipientDesc = 'RECIPIENT_DESC'
}

export type XcmTransfered = Node & {
  __typename?: 'XcmTransfered';
  amount?: Maybe<Scalars['BigFloat']>;
  asset: Scalars['String'];
  createdAt: Scalars['Datetime'];
  id: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  recipient: Scalars['String'];
  sender: Scalars['String'];
};

export type XcmTransferedAggregates = {
  __typename?: 'XcmTransferedAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `XcmTransfered` object types. All fields are combined with a logical ‘and.’ */
export type XcmTransferedFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<XcmTransferedFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<XcmTransferedFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<XcmTransferedFilter>>;
  /** Filter by the object’s `recipient` field. */
  recipient?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sender` field. */
  sender?: InputMaybe<StringFilter>;
};

/** A connection to a list of `XcmTransfered` values. */
export type XcmTransferedsConnection = {
  __typename?: 'XcmTransferedsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<XcmTransferedAggregates>;
  /** A list of edges which contains the `XcmTransfered` and cursor to aid in pagination. */
  edges: Array<XcmTransferedsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<XcmTransferedAggregates>>;
  /** A list of `XcmTransfered` objects. */
  nodes: Array<Maybe<XcmTransfered>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `XcmTransfered` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `XcmTransfered` values. */
export type XcmTransferedsConnectionGroupedAggregatesArgs = {
  groupBy: Array<XcmTransferedsGroupBy>;
  having?: InputMaybe<XcmTransferedsHavingInput>;
};

/** A `XcmTransfered` edge in the connection. */
export type XcmTransferedsEdge = {
  __typename?: 'XcmTransferedsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `XcmTransfered` at the end of the edge. */
  node?: Maybe<XcmTransfered>;
};

/** Grouping methods for `XcmTransfered` for usage during aggregation. */
export enum XcmTransferedsGroupBy {
  Amount = 'AMOUNT',
  Asset = 'ASSET',
  CreatedAt = 'CREATED_AT',
  Recipient = 'RECIPIENT',
  Sender = 'SENDER'
}

/** Conditions for `XcmTransfered` aggregates. */
export type XcmTransferedsHavingInput = {
  AND?: InputMaybe<Array<XcmTransferedsHavingInput>>;
  OR?: InputMaybe<Array<XcmTransferedsHavingInput>>;
};

/** Methods to use when ordering `XcmTransfered`. */
export enum XcmTransferedsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AssetAsc = 'ASSET_ASC',
  AssetDesc = 'ASSET_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecipientAsc = 'RECIPIENT_ASC',
  RecipientDesc = 'RECIPIENT_DESC',
  SenderAsc = 'SENDER_ASC',
  SenderDesc = 'SENDER_DESC'
}

export type XcmWithdrawn = Node & {
  __typename?: 'XcmWithdrawn';
  amount?: Maybe<Scalars['BigFloat']>;
  asset: Scalars['String'];
  createdAt: Scalars['Datetime'];
  depositer: Scalars['String'];
  id: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type XcmWithdrawnAggregates = {
  __typename?: 'XcmWithdrawnAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `XcmWithdrawn` object types. All fields are combined with a logical ‘and.’ */
export type XcmWithdrawnFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<XcmWithdrawnFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `depositer` field. */
  depositer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<XcmWithdrawnFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<XcmWithdrawnFilter>>;
};

/** A connection to a list of `XcmWithdrawn` values. */
export type XcmWithdrawnsConnection = {
  __typename?: 'XcmWithdrawnsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<XcmWithdrawnAggregates>;
  /** A list of edges which contains the `XcmWithdrawn` and cursor to aid in pagination. */
  edges: Array<XcmWithdrawnsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<XcmWithdrawnAggregates>>;
  /** A list of `XcmWithdrawn` objects. */
  nodes: Array<Maybe<XcmWithdrawn>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `XcmWithdrawn` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `XcmWithdrawn` values. */
export type XcmWithdrawnsConnectionGroupedAggregatesArgs = {
  groupBy: Array<XcmWithdrawnsGroupBy>;
  having?: InputMaybe<XcmWithdrawnsHavingInput>;
};

/** A `XcmWithdrawn` edge in the connection. */
export type XcmWithdrawnsEdge = {
  __typename?: 'XcmWithdrawnsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `XcmWithdrawn` at the end of the edge. */
  node?: Maybe<XcmWithdrawn>;
};

/** Grouping methods for `XcmWithdrawn` for usage during aggregation. */
export enum XcmWithdrawnsGroupBy {
  Amount = 'AMOUNT',
  Asset = 'ASSET',
  CreatedAt = 'CREATED_AT',
  Depositer = 'DEPOSITER'
}

/** Conditions for `XcmWithdrawn` aggregates. */
export type XcmWithdrawnsHavingInput = {
  AND?: InputMaybe<Array<XcmWithdrawnsHavingInput>>;
  OR?: InputMaybe<Array<XcmWithdrawnsHavingInput>>;
};

/** Methods to use when ordering `XcmWithdrawn`. */
export enum XcmWithdrawnsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AssetAsc = 'ASSET_ASC',
  AssetDesc = 'ASSET_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DepositerAsc = 'DEPOSITER_ASC',
  DepositerDesc = 'DEPOSITER_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type _Metadata = {
  __typename?: '_Metadata';
  chain?: Maybe<Scalars['String']>;
  dynamicDatasources?: Maybe<Scalars['String']>;
  genesisHash?: Maybe<Scalars['String']>;
  indexerHealthy?: Maybe<Scalars['Boolean']>;
  indexerNodeVersion?: Maybe<Scalars['String']>;
  lastProcessedHeight?: Maybe<Scalars['Int']>;
  lastProcessedTimestamp?: Maybe<Scalars['Date']>;
  queryNodeVersion?: Maybe<Scalars['String']>;
  rowCountEstimate?: Maybe<Array<Maybe<TableEstimate>>>;
  specName?: Maybe<Scalars['String']>;
  targetHeight?: Maybe<Scalars['Int']>;
};

export type XcmDepositedsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<XcmDepositedsOrderBy> | XcmDepositedsOrderBy>;
  filter?: InputMaybe<XcmDepositedFilter>;
}>;


export type XcmDepositedsQuery = { __typename?: 'Query', xcmDepositeds?: { __typename?: 'XcmDepositedsConnection', nodes: Array<{ __typename?: 'XcmDeposited', nodeId: string, id: string, createdAt: string, asset: string, amount?: string | null, recipient: string, isForward?: boolean | null } | null> } | null };

export type BridgeDepositedQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BridgeDepositedsOrderBy> | BridgeDepositedsOrderBy>;
  filter?: InputMaybe<BridgeDepositedFilter>;
}>;


export type BridgeDepositedQuery = { __typename?: 'Query', bridgeDepositeds?: { __typename?: 'BridgeDepositedsConnection', nodes: Array<{ __typename?: 'BridgeDeposited', nodeId: string, recipient: string, asset: string, id: string, createdAt: string, amount?: string | null } | null> } | null };


export const XcmDepositedsDocument = `
    query XcmDepositeds($first: Int, $offset: Int, $orderBy: [XcmDepositedsOrderBy!], $filter: XcmDepositedFilter) {
  xcmDepositeds(
    first: $first
    offset: $offset
    orderBy: $orderBy
    filter: $filter
  ) {
    nodes {
      nodeId
      id
      createdAt
      asset
      amount
      recipient
      isForward
    }
  }
}
    `;
export const useXcmDepositedsQuery = <
      TData = XcmDepositedsQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: XcmDepositedsQueryVariables,
      options?: UseQueryOptions<XcmDepositedsQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<XcmDepositedsQuery, TError, TData>(
      variables === undefined ? ['XcmDepositeds'] : ['XcmDepositeds', variables],
      fetcher<XcmDepositedsQuery, XcmDepositedsQueryVariables>(client, XcmDepositedsDocument, variables, headers),
      options
    );
export const BridgeDepositedDocument = `
    query BridgeDeposited($first: Int, $offset: Int, $orderBy: [BridgeDepositedsOrderBy!], $filter: BridgeDepositedFilter) {
  bridgeDepositeds(
    first: $first
    offset: $offset
    orderBy: $orderBy
    filter: $filter
  ) {
    nodes {
      nodeId
      recipient
      asset
      id
      createdAt
      amount
    }
  }
}
    `;
export const useBridgeDepositedQuery = <
      TData = BridgeDepositedQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: BridgeDepositedQueryVariables,
      options?: UseQueryOptions<BridgeDepositedQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<BridgeDepositedQuery, TError, TData>(
      variables === undefined ? ['BridgeDeposited'] : ['BridgeDeposited', variables],
      fetcher<BridgeDepositedQuery, BridgeDepositedQueryVariables>(client, BridgeDepositedDocument, variables, headers),
      options
    );