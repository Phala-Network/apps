/* eslint-disable */
/* This file is generated by graphql-codegen, don't edit it directly. */
import { GraphQLClient } from 'graphql-request';
import { RequestInit } from 'graphql-request/dist/types.dom';
import { useQuery, UseQueryOptions } from '@tanstack/react-query';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

function fetcher<TData, TVariables>(client: GraphQLClient, query: string, variables?: TVariables, headers?: RequestInit['headers']) {
  return async (): Promise<TData> => client.request<TData, TVariables>(query, variables, headers);
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** Big number decimal */
  BigDecimal: string;
  /** Big number integer */
  BigInt: string;
  /** A date-time string in simplified extended ISO 8601 format (YYYY-MM-DDTHH:mm:ss.sssZ) */
  DateTime: string;
};

export type Account = {
  __typename?: 'Account';
  id: Scalars['String'];
  ownedStakePools: Array<StakePool>;
  stakes: Array<StakePoolStake>;
  totalOwnerReward: Scalars['BigDecimal'];
  totalStake: Scalars['BigDecimal'];
  totalStakeReward: Scalars['BigDecimal'];
  whitelistedStakePools: Array<StakePoolWhitelist>;
};


export type AccountOwnedStakePoolsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StakePoolOrderByInput>>;
  where?: InputMaybe<StakePoolWhereInput>;
};


export type AccountStakesArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StakePoolStakeOrderByInput>>;
  where?: InputMaybe<StakePoolStakeWhereInput>;
};


export type AccountWhitelistedStakePoolsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StakePoolWhitelistOrderByInput>>;
  where?: InputMaybe<StakePoolWhitelistWhereInput>;
};

export type AccountEdge = {
  __typename?: 'AccountEdge';
  cursor: Scalars['String'];
  node: Account;
};

export enum AccountOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TotalOwnerRewardAsc = 'totalOwnerReward_ASC',
  TotalOwnerRewardDesc = 'totalOwnerReward_DESC',
  TotalStakeRewardAsc = 'totalStakeReward_ASC',
  TotalStakeRewardDesc = 'totalStakeReward_DESC',
  TotalStakeAsc = 'totalStake_ASC',
  TotalStakeDesc = 'totalStake_DESC'
}

export type AccountWhereInput = {
  AND?: InputMaybe<Array<AccountWhereInput>>;
  OR?: InputMaybe<Array<AccountWhereInput>>;
  id_contains?: InputMaybe<Scalars['String']>;
  id_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_endsWith?: InputMaybe<Scalars['String']>;
  id_eq?: InputMaybe<Scalars['String']>;
  id_gt?: InputMaybe<Scalars['String']>;
  id_gte?: InputMaybe<Scalars['String']>;
  id_in?: InputMaybe<Array<Scalars['String']>>;
  id_isNull?: InputMaybe<Scalars['Boolean']>;
  id_lt?: InputMaybe<Scalars['String']>;
  id_lte?: InputMaybe<Scalars['String']>;
  id_not_contains?: InputMaybe<Scalars['String']>;
  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_not_endsWith?: InputMaybe<Scalars['String']>;
  id_not_eq?: InputMaybe<Scalars['String']>;
  id_not_in?: InputMaybe<Array<Scalars['String']>>;
  id_not_startsWith?: InputMaybe<Scalars['String']>;
  id_startsWith?: InputMaybe<Scalars['String']>;
  ownedStakePools_every?: InputMaybe<StakePoolWhereInput>;
  ownedStakePools_none?: InputMaybe<StakePoolWhereInput>;
  ownedStakePools_some?: InputMaybe<StakePoolWhereInput>;
  stakes_every?: InputMaybe<StakePoolStakeWhereInput>;
  stakes_none?: InputMaybe<StakePoolStakeWhereInput>;
  stakes_some?: InputMaybe<StakePoolStakeWhereInput>;
  totalOwnerReward_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalOwnerReward_gt?: InputMaybe<Scalars['BigDecimal']>;
  totalOwnerReward_gte?: InputMaybe<Scalars['BigDecimal']>;
  totalOwnerReward_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalOwnerReward_isNull?: InputMaybe<Scalars['Boolean']>;
  totalOwnerReward_lt?: InputMaybe<Scalars['BigDecimal']>;
  totalOwnerReward_lte?: InputMaybe<Scalars['BigDecimal']>;
  totalOwnerReward_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalOwnerReward_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalStakeReward_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalStakeReward_gt?: InputMaybe<Scalars['BigDecimal']>;
  totalStakeReward_gte?: InputMaybe<Scalars['BigDecimal']>;
  totalStakeReward_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalStakeReward_isNull?: InputMaybe<Scalars['Boolean']>;
  totalStakeReward_lt?: InputMaybe<Scalars['BigDecimal']>;
  totalStakeReward_lte?: InputMaybe<Scalars['BigDecimal']>;
  totalStakeReward_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalStakeReward_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalStake_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_gt?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_gte?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalStake_isNull?: InputMaybe<Scalars['Boolean']>;
  totalStake_lt?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_lte?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  whitelistedStakePools_every?: InputMaybe<StakePoolWhitelistWhereInput>;
  whitelistedStakePools_none?: InputMaybe<StakePoolWhitelistWhereInput>;
  whitelistedStakePools_some?: InputMaybe<StakePoolWhitelistWhereInput>;
};

export type AccountsConnection = {
  __typename?: 'AccountsConnection';
  edges: Array<AccountEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type BasePool = {
  commission: Scalars['BigDecimal'];
  id: Scalars['String'];
  owner: Account;
  pid: Scalars['BigInt'];
};

export type GlobalState = {
  __typename?: 'GlobalState';
  averageBlockTime: Scalars['Int'];
  height: Scalars['Int'];
  id: Scalars['String'];
  lastRecordedBlockHeight: Scalars['Int'];
  lastRecordedBlockTime: Scalars['DateTime'];
  miningWorkerShare: Scalars['BigDecimal'];
  totalStake: Scalars['BigDecimal'];
};

export type GlobalStateEdge = {
  __typename?: 'GlobalStateEdge';
  cursor: Scalars['String'];
  node: GlobalState;
};

export enum GlobalStateOrderByInput {
  AverageBlockTimeAsc = 'averageBlockTime_ASC',
  AverageBlockTimeDesc = 'averageBlockTime_DESC',
  HeightAsc = 'height_ASC',
  HeightDesc = 'height_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  LastRecordedBlockHeightAsc = 'lastRecordedBlockHeight_ASC',
  LastRecordedBlockHeightDesc = 'lastRecordedBlockHeight_DESC',
  LastRecordedBlockTimeAsc = 'lastRecordedBlockTime_ASC',
  LastRecordedBlockTimeDesc = 'lastRecordedBlockTime_DESC',
  MiningWorkerShareAsc = 'miningWorkerShare_ASC',
  MiningWorkerShareDesc = 'miningWorkerShare_DESC',
  TotalStakeAsc = 'totalStake_ASC',
  TotalStakeDesc = 'totalStake_DESC'
}

export type GlobalStateWhereInput = {
  AND?: InputMaybe<Array<GlobalStateWhereInput>>;
  OR?: InputMaybe<Array<GlobalStateWhereInput>>;
  averageBlockTime_eq?: InputMaybe<Scalars['Int']>;
  averageBlockTime_gt?: InputMaybe<Scalars['Int']>;
  averageBlockTime_gte?: InputMaybe<Scalars['Int']>;
  averageBlockTime_in?: InputMaybe<Array<Scalars['Int']>>;
  averageBlockTime_isNull?: InputMaybe<Scalars['Boolean']>;
  averageBlockTime_lt?: InputMaybe<Scalars['Int']>;
  averageBlockTime_lte?: InputMaybe<Scalars['Int']>;
  averageBlockTime_not_eq?: InputMaybe<Scalars['Int']>;
  averageBlockTime_not_in?: InputMaybe<Array<Scalars['Int']>>;
  height_eq?: InputMaybe<Scalars['Int']>;
  height_gt?: InputMaybe<Scalars['Int']>;
  height_gte?: InputMaybe<Scalars['Int']>;
  height_in?: InputMaybe<Array<Scalars['Int']>>;
  height_isNull?: InputMaybe<Scalars['Boolean']>;
  height_lt?: InputMaybe<Scalars['Int']>;
  height_lte?: InputMaybe<Scalars['Int']>;
  height_not_eq?: InputMaybe<Scalars['Int']>;
  height_not_in?: InputMaybe<Array<Scalars['Int']>>;
  id_contains?: InputMaybe<Scalars['String']>;
  id_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_endsWith?: InputMaybe<Scalars['String']>;
  id_eq?: InputMaybe<Scalars['String']>;
  id_gt?: InputMaybe<Scalars['String']>;
  id_gte?: InputMaybe<Scalars['String']>;
  id_in?: InputMaybe<Array<Scalars['String']>>;
  id_isNull?: InputMaybe<Scalars['Boolean']>;
  id_lt?: InputMaybe<Scalars['String']>;
  id_lte?: InputMaybe<Scalars['String']>;
  id_not_contains?: InputMaybe<Scalars['String']>;
  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_not_endsWith?: InputMaybe<Scalars['String']>;
  id_not_eq?: InputMaybe<Scalars['String']>;
  id_not_in?: InputMaybe<Array<Scalars['String']>>;
  id_not_startsWith?: InputMaybe<Scalars['String']>;
  id_startsWith?: InputMaybe<Scalars['String']>;
  lastRecordedBlockHeight_eq?: InputMaybe<Scalars['Int']>;
  lastRecordedBlockHeight_gt?: InputMaybe<Scalars['Int']>;
  lastRecordedBlockHeight_gte?: InputMaybe<Scalars['Int']>;
  lastRecordedBlockHeight_in?: InputMaybe<Array<Scalars['Int']>>;
  lastRecordedBlockHeight_isNull?: InputMaybe<Scalars['Boolean']>;
  lastRecordedBlockHeight_lt?: InputMaybe<Scalars['Int']>;
  lastRecordedBlockHeight_lte?: InputMaybe<Scalars['Int']>;
  lastRecordedBlockHeight_not_eq?: InputMaybe<Scalars['Int']>;
  lastRecordedBlockHeight_not_in?: InputMaybe<Array<Scalars['Int']>>;
  lastRecordedBlockTime_eq?: InputMaybe<Scalars['DateTime']>;
  lastRecordedBlockTime_gt?: InputMaybe<Scalars['DateTime']>;
  lastRecordedBlockTime_gte?: InputMaybe<Scalars['DateTime']>;
  lastRecordedBlockTime_in?: InputMaybe<Array<Scalars['DateTime']>>;
  lastRecordedBlockTime_isNull?: InputMaybe<Scalars['Boolean']>;
  lastRecordedBlockTime_lt?: InputMaybe<Scalars['DateTime']>;
  lastRecordedBlockTime_lte?: InputMaybe<Scalars['DateTime']>;
  lastRecordedBlockTime_not_eq?: InputMaybe<Scalars['DateTime']>;
  lastRecordedBlockTime_not_in?: InputMaybe<Array<Scalars['DateTime']>>;
  miningWorkerShare_eq?: InputMaybe<Scalars['BigDecimal']>;
  miningWorkerShare_gt?: InputMaybe<Scalars['BigDecimal']>;
  miningWorkerShare_gte?: InputMaybe<Scalars['BigDecimal']>;
  miningWorkerShare_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  miningWorkerShare_isNull?: InputMaybe<Scalars['Boolean']>;
  miningWorkerShare_lt?: InputMaybe<Scalars['BigDecimal']>;
  miningWorkerShare_lte?: InputMaybe<Scalars['BigDecimal']>;
  miningWorkerShare_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  miningWorkerShare_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalStake_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_gt?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_gte?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalStake_isNull?: InputMaybe<Scalars['Boolean']>;
  totalStake_lt?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_lte?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
};

export type GlobalStatesConnection = {
  __typename?: 'GlobalStatesConnection';
  edges: Array<GlobalStateEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type Miner = {
  __typename?: 'Miner';
  coolingDownStartTime?: Maybe<Scalars['DateTime']>;
  id: Scalars['String'];
  isBound: Scalars['Boolean'];
  pInit: Scalars['Int'];
  pInstant: Scalars['Int'];
  stake: Scalars['BigDecimal'];
  stakePool?: Maybe<StakePool>;
  state: MinerState;
  totalReward: Scalars['BigDecimal'];
  v: Scalars['BigDecimal'];
  ve: Scalars['BigDecimal'];
  worker?: Maybe<Worker>;
};

export type MinerEdge = {
  __typename?: 'MinerEdge';
  cursor: Scalars['String'];
  node: Miner;
};

export enum MinerOrderByInput {
  CoolingDownStartTimeAsc = 'coolingDownStartTime_ASC',
  CoolingDownStartTimeDesc = 'coolingDownStartTime_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  IsBoundAsc = 'isBound_ASC',
  IsBoundDesc = 'isBound_DESC',
  PInitAsc = 'pInit_ASC',
  PInitDesc = 'pInit_DESC',
  PInstantAsc = 'pInstant_ASC',
  PInstantDesc = 'pInstant_DESC',
  StakePoolActiveStakeCountAsc = 'stakePool_activeStakeCount_ASC',
  StakePoolActiveStakeCountDesc = 'stakePool_activeStakeCount_DESC',
  StakePoolAprBaseAsc = 'stakePool_aprBase_ASC',
  StakePoolAprBaseDesc = 'stakePool_aprBase_DESC',
  StakePoolCapacityAsc = 'stakePool_capacity_ASC',
  StakePoolCapacityDesc = 'stakePool_capacity_DESC',
  StakePoolCommissionAsc = 'stakePool_commission_ASC',
  StakePoolCommissionDesc = 'stakePool_commission_DESC',
  StakePoolDelegableAsc = 'stakePool_delegable_ASC',
  StakePoolDelegableDesc = 'stakePool_delegable_DESC',
  StakePoolFreeStakeAsc = 'stakePool_freeStake_ASC',
  StakePoolFreeStakeDesc = 'stakePool_freeStake_DESC',
  StakePoolIdAsc = 'stakePool_id_ASC',
  StakePoolIdDesc = 'stakePool_id_DESC',
  StakePoolMiningWorkerCountAsc = 'stakePool_miningWorkerCount_ASC',
  StakePoolMiningWorkerCountDesc = 'stakePool_miningWorkerCount_DESC',
  StakePoolMiningWorkerShareAsc = 'stakePool_miningWorkerShare_ASC',
  StakePoolMiningWorkerShareDesc = 'stakePool_miningWorkerShare_DESC',
  StakePoolOwnerRewardAsc = 'stakePool_ownerReward_ASC',
  StakePoolOwnerRewardDesc = 'stakePool_ownerReward_DESC',
  StakePoolPidAsc = 'stakePool_pid_ASC',
  StakePoolPidDesc = 'stakePool_pid_DESC',
  StakePoolReleasingStakeAsc = 'stakePool_releasingStake_ASC',
  StakePoolReleasingStakeDesc = 'stakePool_releasingStake_DESC',
  StakePoolTotalSharesAsc = 'stakePool_totalShares_ASC',
  StakePoolTotalSharesDesc = 'stakePool_totalShares_DESC',
  StakePoolTotalStakeAsc = 'stakePool_totalStake_ASC',
  StakePoolTotalStakeDesc = 'stakePool_totalStake_DESC',
  StakePoolTotalWithdrawalAsc = 'stakePool_totalWithdrawal_ASC',
  StakePoolTotalWithdrawalDesc = 'stakePool_totalWithdrawal_DESC',
  StakePoolWhitelistEnabledAsc = 'stakePool_whitelistEnabled_ASC',
  StakePoolWhitelistEnabledDesc = 'stakePool_whitelistEnabled_DESC',
  StakePoolWorkerCountAsc = 'stakePool_workerCount_ASC',
  StakePoolWorkerCountDesc = 'stakePool_workerCount_DESC',
  StakeAsc = 'stake_ASC',
  StakeDesc = 'stake_DESC',
  StateAsc = 'state_ASC',
  StateDesc = 'state_DESC',
  TotalRewardAsc = 'totalReward_ASC',
  TotalRewardDesc = 'totalReward_DESC',
  VAsc = 'v_ASC',
  VDesc = 'v_DESC',
  VeAsc = 've_ASC',
  VeDesc = 've_DESC',
  WorkerConfidenceLevelAsc = 'worker_confidenceLevel_ASC',
  WorkerConfidenceLevelDesc = 'worker_confidenceLevel_DESC',
  WorkerIdAsc = 'worker_id_ASC',
  WorkerIdDesc = 'worker_id_DESC',
  WorkerInitialScoreAsc = 'worker_initialScore_ASC',
  WorkerInitialScoreDesc = 'worker_initialScore_DESC',
  WorkerSMaxAsc = 'worker_sMax_ASC',
  WorkerSMaxDesc = 'worker_sMax_DESC',
  WorkerSMinAsc = 'worker_sMin_ASC',
  WorkerSMinDesc = 'worker_sMin_DESC',
  WorkerShareAsc = 'worker_share_ASC',
  WorkerShareDesc = 'worker_share_DESC'
}

export enum MinerState {
  MiningCoolingDown = 'MiningCoolingDown',
  MiningIdle = 'MiningIdle',
  MiningUnresponsive = 'MiningUnresponsive',
  Ready = 'Ready'
}

export type MinerWhereInput = {
  AND?: InputMaybe<Array<MinerWhereInput>>;
  OR?: InputMaybe<Array<MinerWhereInput>>;
  coolingDownStartTime_eq?: InputMaybe<Scalars['DateTime']>;
  coolingDownStartTime_gt?: InputMaybe<Scalars['DateTime']>;
  coolingDownStartTime_gte?: InputMaybe<Scalars['DateTime']>;
  coolingDownStartTime_in?: InputMaybe<Array<Scalars['DateTime']>>;
  coolingDownStartTime_isNull?: InputMaybe<Scalars['Boolean']>;
  coolingDownStartTime_lt?: InputMaybe<Scalars['DateTime']>;
  coolingDownStartTime_lte?: InputMaybe<Scalars['DateTime']>;
  coolingDownStartTime_not_eq?: InputMaybe<Scalars['DateTime']>;
  coolingDownStartTime_not_in?: InputMaybe<Array<Scalars['DateTime']>>;
  id_contains?: InputMaybe<Scalars['String']>;
  id_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_endsWith?: InputMaybe<Scalars['String']>;
  id_eq?: InputMaybe<Scalars['String']>;
  id_gt?: InputMaybe<Scalars['String']>;
  id_gte?: InputMaybe<Scalars['String']>;
  id_in?: InputMaybe<Array<Scalars['String']>>;
  id_isNull?: InputMaybe<Scalars['Boolean']>;
  id_lt?: InputMaybe<Scalars['String']>;
  id_lte?: InputMaybe<Scalars['String']>;
  id_not_contains?: InputMaybe<Scalars['String']>;
  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_not_endsWith?: InputMaybe<Scalars['String']>;
  id_not_eq?: InputMaybe<Scalars['String']>;
  id_not_in?: InputMaybe<Array<Scalars['String']>>;
  id_not_startsWith?: InputMaybe<Scalars['String']>;
  id_startsWith?: InputMaybe<Scalars['String']>;
  isBound_eq?: InputMaybe<Scalars['Boolean']>;
  isBound_isNull?: InputMaybe<Scalars['Boolean']>;
  isBound_not_eq?: InputMaybe<Scalars['Boolean']>;
  pInit_eq?: InputMaybe<Scalars['Int']>;
  pInit_gt?: InputMaybe<Scalars['Int']>;
  pInit_gte?: InputMaybe<Scalars['Int']>;
  pInit_in?: InputMaybe<Array<Scalars['Int']>>;
  pInit_isNull?: InputMaybe<Scalars['Boolean']>;
  pInit_lt?: InputMaybe<Scalars['Int']>;
  pInit_lte?: InputMaybe<Scalars['Int']>;
  pInit_not_eq?: InputMaybe<Scalars['Int']>;
  pInit_not_in?: InputMaybe<Array<Scalars['Int']>>;
  pInstant_eq?: InputMaybe<Scalars['Int']>;
  pInstant_gt?: InputMaybe<Scalars['Int']>;
  pInstant_gte?: InputMaybe<Scalars['Int']>;
  pInstant_in?: InputMaybe<Array<Scalars['Int']>>;
  pInstant_isNull?: InputMaybe<Scalars['Boolean']>;
  pInstant_lt?: InputMaybe<Scalars['Int']>;
  pInstant_lte?: InputMaybe<Scalars['Int']>;
  pInstant_not_eq?: InputMaybe<Scalars['Int']>;
  pInstant_not_in?: InputMaybe<Array<Scalars['Int']>>;
  stakePool?: InputMaybe<StakePoolWhereInput>;
  stakePool_isNull?: InputMaybe<Scalars['Boolean']>;
  stake_eq?: InputMaybe<Scalars['BigDecimal']>;
  stake_gt?: InputMaybe<Scalars['BigDecimal']>;
  stake_gte?: InputMaybe<Scalars['BigDecimal']>;
  stake_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  stake_isNull?: InputMaybe<Scalars['Boolean']>;
  stake_lt?: InputMaybe<Scalars['BigDecimal']>;
  stake_lte?: InputMaybe<Scalars['BigDecimal']>;
  stake_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  stake_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  state_eq?: InputMaybe<MinerState>;
  state_in?: InputMaybe<Array<MinerState>>;
  state_isNull?: InputMaybe<Scalars['Boolean']>;
  state_not_eq?: InputMaybe<MinerState>;
  state_not_in?: InputMaybe<Array<MinerState>>;
  totalReward_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalReward_gt?: InputMaybe<Scalars['BigDecimal']>;
  totalReward_gte?: InputMaybe<Scalars['BigDecimal']>;
  totalReward_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalReward_isNull?: InputMaybe<Scalars['Boolean']>;
  totalReward_lt?: InputMaybe<Scalars['BigDecimal']>;
  totalReward_lte?: InputMaybe<Scalars['BigDecimal']>;
  totalReward_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalReward_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  v_eq?: InputMaybe<Scalars['BigDecimal']>;
  v_gt?: InputMaybe<Scalars['BigDecimal']>;
  v_gte?: InputMaybe<Scalars['BigDecimal']>;
  v_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  v_isNull?: InputMaybe<Scalars['Boolean']>;
  v_lt?: InputMaybe<Scalars['BigDecimal']>;
  v_lte?: InputMaybe<Scalars['BigDecimal']>;
  v_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  v_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  ve_eq?: InputMaybe<Scalars['BigDecimal']>;
  ve_gt?: InputMaybe<Scalars['BigDecimal']>;
  ve_gte?: InputMaybe<Scalars['BigDecimal']>;
  ve_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  ve_isNull?: InputMaybe<Scalars['Boolean']>;
  ve_lt?: InputMaybe<Scalars['BigDecimal']>;
  ve_lte?: InputMaybe<Scalars['BigDecimal']>;
  ve_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  ve_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  worker?: InputMaybe<WorkerWhereInput>;
  worker_isNull?: InputMaybe<Scalars['Boolean']>;
};

export type MinersConnection = {
  __typename?: 'MinersConnection';
  edges: Array<MinerEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor: Scalars['String'];
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor: Scalars['String'];
};

export type Query = {
  __typename?: 'Query';
  accountById?: Maybe<Account>;
  /** @deprecated Use accountById */
  accountByUniqueInput?: Maybe<Account>;
  accounts: Array<Account>;
  accountsConnection: AccountsConnection;
  globalStateById?: Maybe<GlobalState>;
  /** @deprecated Use globalStateById */
  globalStateByUniqueInput?: Maybe<GlobalState>;
  globalStates: Array<GlobalState>;
  globalStatesConnection: GlobalStatesConnection;
  minerById?: Maybe<Miner>;
  /** @deprecated Use minerById */
  minerByUniqueInput?: Maybe<Miner>;
  miners: Array<Miner>;
  minersConnection: MinersConnection;
  squidStatus?: Maybe<SquidStatus>;
  stakePoolById?: Maybe<StakePool>;
  /** @deprecated Use stakePoolById */
  stakePoolByUniqueInput?: Maybe<StakePool>;
  stakePoolStakeById?: Maybe<StakePoolStake>;
  /** @deprecated Use stakePoolStakeById */
  stakePoolStakeByUniqueInput?: Maybe<StakePoolStake>;
  stakePoolStakes: Array<StakePoolStake>;
  stakePoolStakesConnection: StakePoolStakesConnection;
  stakePoolWhitelistById?: Maybe<StakePoolWhitelist>;
  /** @deprecated Use stakePoolWhitelistById */
  stakePoolWhitelistByUniqueInput?: Maybe<StakePoolWhitelist>;
  stakePoolWhitelists: Array<StakePoolWhitelist>;
  stakePoolWhitelistsConnection: StakePoolWhitelistsConnection;
  stakePools: Array<StakePool>;
  stakePoolsConnection: StakePoolsConnection;
  tokenomicParameters: Array<TokenomicParameters>;
  tokenomicParametersById?: Maybe<TokenomicParameters>;
  /** @deprecated Use tokenomicParametersById */
  tokenomicParametersByUniqueInput?: Maybe<TokenomicParameters>;
  tokenomicParametersConnection: TokenomicParametersConnection;
  workerById?: Maybe<Worker>;
  /** @deprecated Use workerById */
  workerByUniqueInput?: Maybe<Worker>;
  workers: Array<Worker>;
  workersConnection: WorkersConnection;
};


export type QueryAccountByIdArgs = {
  id: Scalars['String'];
};


export type QueryAccountByUniqueInputArgs = {
  where: WhereIdInput;
};


export type QueryAccountsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountOrderByInput>>;
  where?: InputMaybe<AccountWhereInput>;
};


export type QueryAccountsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy: Array<AccountOrderByInput>;
  where?: InputMaybe<AccountWhereInput>;
};


export type QueryGlobalStateByIdArgs = {
  id: Scalars['String'];
};


export type QueryGlobalStateByUniqueInputArgs = {
  where: WhereIdInput;
};


export type QueryGlobalStatesArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GlobalStateOrderByInput>>;
  where?: InputMaybe<GlobalStateWhereInput>;
};


export type QueryGlobalStatesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy: Array<GlobalStateOrderByInput>;
  where?: InputMaybe<GlobalStateWhereInput>;
};


export type QueryMinerByIdArgs = {
  id: Scalars['String'];
};


export type QueryMinerByUniqueInputArgs = {
  where: WhereIdInput;
};


export type QueryMinersArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MinerOrderByInput>>;
  where?: InputMaybe<MinerWhereInput>;
};


export type QueryMinersConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy: Array<MinerOrderByInput>;
  where?: InputMaybe<MinerWhereInput>;
};


export type QueryStakePoolByIdArgs = {
  id: Scalars['String'];
};


export type QueryStakePoolByUniqueInputArgs = {
  where: WhereIdInput;
};


export type QueryStakePoolStakeByIdArgs = {
  id: Scalars['String'];
};


export type QueryStakePoolStakeByUniqueInputArgs = {
  where: WhereIdInput;
};


export type QueryStakePoolStakesArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StakePoolStakeOrderByInput>>;
  where?: InputMaybe<StakePoolStakeWhereInput>;
};


export type QueryStakePoolStakesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy: Array<StakePoolStakeOrderByInput>;
  where?: InputMaybe<StakePoolStakeWhereInput>;
};


export type QueryStakePoolWhitelistByIdArgs = {
  id: Scalars['String'];
};


export type QueryStakePoolWhitelistByUniqueInputArgs = {
  where: WhereIdInput;
};


export type QueryStakePoolWhitelistsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StakePoolWhitelistOrderByInput>>;
  where?: InputMaybe<StakePoolWhitelistWhereInput>;
};


export type QueryStakePoolWhitelistsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy: Array<StakePoolWhitelistOrderByInput>;
  where?: InputMaybe<StakePoolWhitelistWhereInput>;
};


export type QueryStakePoolsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StakePoolOrderByInput>>;
  where?: InputMaybe<StakePoolWhereInput>;
};


export type QueryStakePoolsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy: Array<StakePoolOrderByInput>;
  where?: InputMaybe<StakePoolWhereInput>;
};


export type QueryTokenomicParametersArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TokenomicParametersOrderByInput>>;
  where?: InputMaybe<TokenomicParametersWhereInput>;
};


export type QueryTokenomicParametersByIdArgs = {
  id: Scalars['String'];
};


export type QueryTokenomicParametersByUniqueInputArgs = {
  where: WhereIdInput;
};


export type QueryTokenomicParametersConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy: Array<TokenomicParametersOrderByInput>;
  where?: InputMaybe<TokenomicParametersWhereInput>;
};


export type QueryWorkerByIdArgs = {
  id: Scalars['String'];
};


export type QueryWorkerByUniqueInputArgs = {
  where: WhereIdInput;
};


export type QueryWorkersArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WorkerOrderByInput>>;
  where?: InputMaybe<WorkerWhereInput>;
};


export type QueryWorkersConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy: Array<WorkerOrderByInput>;
  where?: InputMaybe<WorkerWhereInput>;
};

export type SquidStatus = {
  __typename?: 'SquidStatus';
  /** The height of the processed part of the chain */
  height?: Maybe<Scalars['Int']>;
};

export type StakePool = BasePool & {
  __typename?: 'StakePool';
  activeStakeCount: Scalars['Int'];
  aprBase: Scalars['BigDecimal'];
  capacity?: Maybe<Scalars['BigDecimal']>;
  commission: Scalars['BigDecimal'];
  delegable?: Maybe<Scalars['BigDecimal']>;
  freeStake: Scalars['BigDecimal'];
  id: Scalars['String'];
  miners: Array<Miner>;
  miningWorkerCount: Scalars['Int'];
  miningWorkerShare: Scalars['BigDecimal'];
  owner: Account;
  ownerReward: Scalars['BigDecimal'];
  pid: Scalars['BigInt'];
  releasingStake: Scalars['BigDecimal'];
  stakes: Array<StakePoolStake>;
  totalShares: Scalars['BigDecimal'];
  totalStake: Scalars['BigDecimal'];
  totalWithdrawal: Scalars['BigDecimal'];
  whitelistEnabled: Scalars['Boolean'];
  whitelists: Array<StakePoolWhitelist>;
  workerCount: Scalars['Int'];
  workers: Array<Worker>;
};


export type StakePoolMinersArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MinerOrderByInput>>;
  where?: InputMaybe<MinerWhereInput>;
};


export type StakePoolStakesArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StakePoolStakeOrderByInput>>;
  where?: InputMaybe<StakePoolStakeWhereInput>;
};


export type StakePoolWhitelistsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StakePoolWhitelistOrderByInput>>;
  where?: InputMaybe<StakePoolWhitelistWhereInput>;
};


export type StakePoolWorkersArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WorkerOrderByInput>>;
  where?: InputMaybe<WorkerWhereInput>;
};

export type StakePoolEdge = {
  __typename?: 'StakePoolEdge';
  cursor: Scalars['String'];
  node: StakePool;
};

export enum StakePoolOrderByInput {
  ActiveStakeCountAsc = 'activeStakeCount_ASC',
  ActiveStakeCountDesc = 'activeStakeCount_DESC',
  AprBaseAsc = 'aprBase_ASC',
  AprBaseDesc = 'aprBase_DESC',
  CapacityAsc = 'capacity_ASC',
  CapacityDesc = 'capacity_DESC',
  CommissionAsc = 'commission_ASC',
  CommissionDesc = 'commission_DESC',
  DelegableAsc = 'delegable_ASC',
  DelegableDesc = 'delegable_DESC',
  FreeStakeAsc = 'freeStake_ASC',
  FreeStakeDesc = 'freeStake_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  MiningWorkerCountAsc = 'miningWorkerCount_ASC',
  MiningWorkerCountDesc = 'miningWorkerCount_DESC',
  MiningWorkerShareAsc = 'miningWorkerShare_ASC',
  MiningWorkerShareDesc = 'miningWorkerShare_DESC',
  OwnerRewardAsc = 'ownerReward_ASC',
  OwnerRewardDesc = 'ownerReward_DESC',
  OwnerIdAsc = 'owner_id_ASC',
  OwnerIdDesc = 'owner_id_DESC',
  OwnerTotalOwnerRewardAsc = 'owner_totalOwnerReward_ASC',
  OwnerTotalOwnerRewardDesc = 'owner_totalOwnerReward_DESC',
  OwnerTotalStakeRewardAsc = 'owner_totalStakeReward_ASC',
  OwnerTotalStakeRewardDesc = 'owner_totalStakeReward_DESC',
  OwnerTotalStakeAsc = 'owner_totalStake_ASC',
  OwnerTotalStakeDesc = 'owner_totalStake_DESC',
  PidAsc = 'pid_ASC',
  PidDesc = 'pid_DESC',
  ReleasingStakeAsc = 'releasingStake_ASC',
  ReleasingStakeDesc = 'releasingStake_DESC',
  TotalSharesAsc = 'totalShares_ASC',
  TotalSharesDesc = 'totalShares_DESC',
  TotalStakeAsc = 'totalStake_ASC',
  TotalStakeDesc = 'totalStake_DESC',
  TotalWithdrawalAsc = 'totalWithdrawal_ASC',
  TotalWithdrawalDesc = 'totalWithdrawal_DESC',
  WhitelistEnabledAsc = 'whitelistEnabled_ASC',
  WhitelistEnabledDesc = 'whitelistEnabled_DESC',
  WorkerCountAsc = 'workerCount_ASC',
  WorkerCountDesc = 'workerCount_DESC'
}

export type StakePoolStake = {
  __typename?: 'StakePoolStake';
  account: Account;
  amount: Scalars['BigDecimal'];
  id: Scalars['String'];
  reward: Scalars['BigDecimal'];
  shares: Scalars['BigDecimal'];
  stakePool: StakePool;
  withdrawalAmount: Scalars['BigDecimal'];
  withdrawalShares: Scalars['BigDecimal'];
  withdrawalStartTime?: Maybe<Scalars['DateTime']>;
};

export type StakePoolStakeEdge = {
  __typename?: 'StakePoolStakeEdge';
  cursor: Scalars['String'];
  node: StakePoolStake;
};

export enum StakePoolStakeOrderByInput {
  AccountIdAsc = 'account_id_ASC',
  AccountIdDesc = 'account_id_DESC',
  AccountTotalOwnerRewardAsc = 'account_totalOwnerReward_ASC',
  AccountTotalOwnerRewardDesc = 'account_totalOwnerReward_DESC',
  AccountTotalStakeRewardAsc = 'account_totalStakeReward_ASC',
  AccountTotalStakeRewardDesc = 'account_totalStakeReward_DESC',
  AccountTotalStakeAsc = 'account_totalStake_ASC',
  AccountTotalStakeDesc = 'account_totalStake_DESC',
  AmountAsc = 'amount_ASC',
  AmountDesc = 'amount_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  RewardAsc = 'reward_ASC',
  RewardDesc = 'reward_DESC',
  SharesAsc = 'shares_ASC',
  SharesDesc = 'shares_DESC',
  StakePoolActiveStakeCountAsc = 'stakePool_activeStakeCount_ASC',
  StakePoolActiveStakeCountDesc = 'stakePool_activeStakeCount_DESC',
  StakePoolAprBaseAsc = 'stakePool_aprBase_ASC',
  StakePoolAprBaseDesc = 'stakePool_aprBase_DESC',
  StakePoolCapacityAsc = 'stakePool_capacity_ASC',
  StakePoolCapacityDesc = 'stakePool_capacity_DESC',
  StakePoolCommissionAsc = 'stakePool_commission_ASC',
  StakePoolCommissionDesc = 'stakePool_commission_DESC',
  StakePoolDelegableAsc = 'stakePool_delegable_ASC',
  StakePoolDelegableDesc = 'stakePool_delegable_DESC',
  StakePoolFreeStakeAsc = 'stakePool_freeStake_ASC',
  StakePoolFreeStakeDesc = 'stakePool_freeStake_DESC',
  StakePoolIdAsc = 'stakePool_id_ASC',
  StakePoolIdDesc = 'stakePool_id_DESC',
  StakePoolMiningWorkerCountAsc = 'stakePool_miningWorkerCount_ASC',
  StakePoolMiningWorkerCountDesc = 'stakePool_miningWorkerCount_DESC',
  StakePoolMiningWorkerShareAsc = 'stakePool_miningWorkerShare_ASC',
  StakePoolMiningWorkerShareDesc = 'stakePool_miningWorkerShare_DESC',
  StakePoolOwnerRewardAsc = 'stakePool_ownerReward_ASC',
  StakePoolOwnerRewardDesc = 'stakePool_ownerReward_DESC',
  StakePoolPidAsc = 'stakePool_pid_ASC',
  StakePoolPidDesc = 'stakePool_pid_DESC',
  StakePoolReleasingStakeAsc = 'stakePool_releasingStake_ASC',
  StakePoolReleasingStakeDesc = 'stakePool_releasingStake_DESC',
  StakePoolTotalSharesAsc = 'stakePool_totalShares_ASC',
  StakePoolTotalSharesDesc = 'stakePool_totalShares_DESC',
  StakePoolTotalStakeAsc = 'stakePool_totalStake_ASC',
  StakePoolTotalStakeDesc = 'stakePool_totalStake_DESC',
  StakePoolTotalWithdrawalAsc = 'stakePool_totalWithdrawal_ASC',
  StakePoolTotalWithdrawalDesc = 'stakePool_totalWithdrawal_DESC',
  StakePoolWhitelistEnabledAsc = 'stakePool_whitelistEnabled_ASC',
  StakePoolWhitelistEnabledDesc = 'stakePool_whitelistEnabled_DESC',
  StakePoolWorkerCountAsc = 'stakePool_workerCount_ASC',
  StakePoolWorkerCountDesc = 'stakePool_workerCount_DESC',
  WithdrawalAmountAsc = 'withdrawalAmount_ASC',
  WithdrawalAmountDesc = 'withdrawalAmount_DESC',
  WithdrawalSharesAsc = 'withdrawalShares_ASC',
  WithdrawalSharesDesc = 'withdrawalShares_DESC',
  WithdrawalStartTimeAsc = 'withdrawalStartTime_ASC',
  WithdrawalStartTimeDesc = 'withdrawalStartTime_DESC'
}

export type StakePoolStakeWhereInput = {
  AND?: InputMaybe<Array<StakePoolStakeWhereInput>>;
  OR?: InputMaybe<Array<StakePoolStakeWhereInput>>;
  account?: InputMaybe<AccountWhereInput>;
  account_isNull?: InputMaybe<Scalars['Boolean']>;
  amount_eq?: InputMaybe<Scalars['BigDecimal']>;
  amount_gt?: InputMaybe<Scalars['BigDecimal']>;
  amount_gte?: InputMaybe<Scalars['BigDecimal']>;
  amount_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  amount_isNull?: InputMaybe<Scalars['Boolean']>;
  amount_lt?: InputMaybe<Scalars['BigDecimal']>;
  amount_lte?: InputMaybe<Scalars['BigDecimal']>;
  amount_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  id_contains?: InputMaybe<Scalars['String']>;
  id_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_endsWith?: InputMaybe<Scalars['String']>;
  id_eq?: InputMaybe<Scalars['String']>;
  id_gt?: InputMaybe<Scalars['String']>;
  id_gte?: InputMaybe<Scalars['String']>;
  id_in?: InputMaybe<Array<Scalars['String']>>;
  id_isNull?: InputMaybe<Scalars['Boolean']>;
  id_lt?: InputMaybe<Scalars['String']>;
  id_lte?: InputMaybe<Scalars['String']>;
  id_not_contains?: InputMaybe<Scalars['String']>;
  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_not_endsWith?: InputMaybe<Scalars['String']>;
  id_not_eq?: InputMaybe<Scalars['String']>;
  id_not_in?: InputMaybe<Array<Scalars['String']>>;
  id_not_startsWith?: InputMaybe<Scalars['String']>;
  id_startsWith?: InputMaybe<Scalars['String']>;
  reward_eq?: InputMaybe<Scalars['BigDecimal']>;
  reward_gt?: InputMaybe<Scalars['BigDecimal']>;
  reward_gte?: InputMaybe<Scalars['BigDecimal']>;
  reward_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  reward_isNull?: InputMaybe<Scalars['Boolean']>;
  reward_lt?: InputMaybe<Scalars['BigDecimal']>;
  reward_lte?: InputMaybe<Scalars['BigDecimal']>;
  reward_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  reward_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  shares_eq?: InputMaybe<Scalars['BigDecimal']>;
  shares_gt?: InputMaybe<Scalars['BigDecimal']>;
  shares_gte?: InputMaybe<Scalars['BigDecimal']>;
  shares_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  shares_isNull?: InputMaybe<Scalars['Boolean']>;
  shares_lt?: InputMaybe<Scalars['BigDecimal']>;
  shares_lte?: InputMaybe<Scalars['BigDecimal']>;
  shares_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  shares_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  stakePool?: InputMaybe<StakePoolWhereInput>;
  stakePool_isNull?: InputMaybe<Scalars['Boolean']>;
  withdrawalAmount_eq?: InputMaybe<Scalars['BigDecimal']>;
  withdrawalAmount_gt?: InputMaybe<Scalars['BigDecimal']>;
  withdrawalAmount_gte?: InputMaybe<Scalars['BigDecimal']>;
  withdrawalAmount_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  withdrawalAmount_isNull?: InputMaybe<Scalars['Boolean']>;
  withdrawalAmount_lt?: InputMaybe<Scalars['BigDecimal']>;
  withdrawalAmount_lte?: InputMaybe<Scalars['BigDecimal']>;
  withdrawalAmount_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  withdrawalAmount_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  withdrawalShares_eq?: InputMaybe<Scalars['BigDecimal']>;
  withdrawalShares_gt?: InputMaybe<Scalars['BigDecimal']>;
  withdrawalShares_gte?: InputMaybe<Scalars['BigDecimal']>;
  withdrawalShares_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  withdrawalShares_isNull?: InputMaybe<Scalars['Boolean']>;
  withdrawalShares_lt?: InputMaybe<Scalars['BigDecimal']>;
  withdrawalShares_lte?: InputMaybe<Scalars['BigDecimal']>;
  withdrawalShares_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  withdrawalShares_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  withdrawalStartTime_eq?: InputMaybe<Scalars['DateTime']>;
  withdrawalStartTime_gt?: InputMaybe<Scalars['DateTime']>;
  withdrawalStartTime_gte?: InputMaybe<Scalars['DateTime']>;
  withdrawalStartTime_in?: InputMaybe<Array<Scalars['DateTime']>>;
  withdrawalStartTime_isNull?: InputMaybe<Scalars['Boolean']>;
  withdrawalStartTime_lt?: InputMaybe<Scalars['DateTime']>;
  withdrawalStartTime_lte?: InputMaybe<Scalars['DateTime']>;
  withdrawalStartTime_not_eq?: InputMaybe<Scalars['DateTime']>;
  withdrawalStartTime_not_in?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type StakePoolStakesConnection = {
  __typename?: 'StakePoolStakesConnection';
  edges: Array<StakePoolStakeEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type StakePoolWhereInput = {
  AND?: InputMaybe<Array<StakePoolWhereInput>>;
  OR?: InputMaybe<Array<StakePoolWhereInput>>;
  activeStakeCount_eq?: InputMaybe<Scalars['Int']>;
  activeStakeCount_gt?: InputMaybe<Scalars['Int']>;
  activeStakeCount_gte?: InputMaybe<Scalars['Int']>;
  activeStakeCount_in?: InputMaybe<Array<Scalars['Int']>>;
  activeStakeCount_isNull?: InputMaybe<Scalars['Boolean']>;
  activeStakeCount_lt?: InputMaybe<Scalars['Int']>;
  activeStakeCount_lte?: InputMaybe<Scalars['Int']>;
  activeStakeCount_not_eq?: InputMaybe<Scalars['Int']>;
  activeStakeCount_not_in?: InputMaybe<Array<Scalars['Int']>>;
  aprBase_eq?: InputMaybe<Scalars['BigDecimal']>;
  aprBase_gt?: InputMaybe<Scalars['BigDecimal']>;
  aprBase_gte?: InputMaybe<Scalars['BigDecimal']>;
  aprBase_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  aprBase_isNull?: InputMaybe<Scalars['Boolean']>;
  aprBase_lt?: InputMaybe<Scalars['BigDecimal']>;
  aprBase_lte?: InputMaybe<Scalars['BigDecimal']>;
  aprBase_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  aprBase_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  capacity_eq?: InputMaybe<Scalars['BigDecimal']>;
  capacity_gt?: InputMaybe<Scalars['BigDecimal']>;
  capacity_gte?: InputMaybe<Scalars['BigDecimal']>;
  capacity_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  capacity_isNull?: InputMaybe<Scalars['Boolean']>;
  capacity_lt?: InputMaybe<Scalars['BigDecimal']>;
  capacity_lte?: InputMaybe<Scalars['BigDecimal']>;
  capacity_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  capacity_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  commission_eq?: InputMaybe<Scalars['BigDecimal']>;
  commission_gt?: InputMaybe<Scalars['BigDecimal']>;
  commission_gte?: InputMaybe<Scalars['BigDecimal']>;
  commission_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  commission_isNull?: InputMaybe<Scalars['Boolean']>;
  commission_lt?: InputMaybe<Scalars['BigDecimal']>;
  commission_lte?: InputMaybe<Scalars['BigDecimal']>;
  commission_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  commission_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  delegable_eq?: InputMaybe<Scalars['BigDecimal']>;
  delegable_gt?: InputMaybe<Scalars['BigDecimal']>;
  delegable_gte?: InputMaybe<Scalars['BigDecimal']>;
  delegable_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  delegable_isNull?: InputMaybe<Scalars['Boolean']>;
  delegable_lt?: InputMaybe<Scalars['BigDecimal']>;
  delegable_lte?: InputMaybe<Scalars['BigDecimal']>;
  delegable_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  delegable_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  freeStake_eq?: InputMaybe<Scalars['BigDecimal']>;
  freeStake_gt?: InputMaybe<Scalars['BigDecimal']>;
  freeStake_gte?: InputMaybe<Scalars['BigDecimal']>;
  freeStake_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  freeStake_isNull?: InputMaybe<Scalars['Boolean']>;
  freeStake_lt?: InputMaybe<Scalars['BigDecimal']>;
  freeStake_lte?: InputMaybe<Scalars['BigDecimal']>;
  freeStake_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  freeStake_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  id_contains?: InputMaybe<Scalars['String']>;
  id_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_endsWith?: InputMaybe<Scalars['String']>;
  id_eq?: InputMaybe<Scalars['String']>;
  id_gt?: InputMaybe<Scalars['String']>;
  id_gte?: InputMaybe<Scalars['String']>;
  id_in?: InputMaybe<Array<Scalars['String']>>;
  id_isNull?: InputMaybe<Scalars['Boolean']>;
  id_lt?: InputMaybe<Scalars['String']>;
  id_lte?: InputMaybe<Scalars['String']>;
  id_not_contains?: InputMaybe<Scalars['String']>;
  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_not_endsWith?: InputMaybe<Scalars['String']>;
  id_not_eq?: InputMaybe<Scalars['String']>;
  id_not_in?: InputMaybe<Array<Scalars['String']>>;
  id_not_startsWith?: InputMaybe<Scalars['String']>;
  id_startsWith?: InputMaybe<Scalars['String']>;
  miners_every?: InputMaybe<MinerWhereInput>;
  miners_none?: InputMaybe<MinerWhereInput>;
  miners_some?: InputMaybe<MinerWhereInput>;
  miningWorkerCount_eq?: InputMaybe<Scalars['Int']>;
  miningWorkerCount_gt?: InputMaybe<Scalars['Int']>;
  miningWorkerCount_gte?: InputMaybe<Scalars['Int']>;
  miningWorkerCount_in?: InputMaybe<Array<Scalars['Int']>>;
  miningWorkerCount_isNull?: InputMaybe<Scalars['Boolean']>;
  miningWorkerCount_lt?: InputMaybe<Scalars['Int']>;
  miningWorkerCount_lte?: InputMaybe<Scalars['Int']>;
  miningWorkerCount_not_eq?: InputMaybe<Scalars['Int']>;
  miningWorkerCount_not_in?: InputMaybe<Array<Scalars['Int']>>;
  miningWorkerShare_eq?: InputMaybe<Scalars['BigDecimal']>;
  miningWorkerShare_gt?: InputMaybe<Scalars['BigDecimal']>;
  miningWorkerShare_gte?: InputMaybe<Scalars['BigDecimal']>;
  miningWorkerShare_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  miningWorkerShare_isNull?: InputMaybe<Scalars['Boolean']>;
  miningWorkerShare_lt?: InputMaybe<Scalars['BigDecimal']>;
  miningWorkerShare_lte?: InputMaybe<Scalars['BigDecimal']>;
  miningWorkerShare_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  miningWorkerShare_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  owner?: InputMaybe<AccountWhereInput>;
  ownerReward_eq?: InputMaybe<Scalars['BigDecimal']>;
  ownerReward_gt?: InputMaybe<Scalars['BigDecimal']>;
  ownerReward_gte?: InputMaybe<Scalars['BigDecimal']>;
  ownerReward_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  ownerReward_isNull?: InputMaybe<Scalars['Boolean']>;
  ownerReward_lt?: InputMaybe<Scalars['BigDecimal']>;
  ownerReward_lte?: InputMaybe<Scalars['BigDecimal']>;
  ownerReward_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  ownerReward_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  owner_isNull?: InputMaybe<Scalars['Boolean']>;
  pid_eq?: InputMaybe<Scalars['BigInt']>;
  pid_gt?: InputMaybe<Scalars['BigInt']>;
  pid_gte?: InputMaybe<Scalars['BigInt']>;
  pid_in?: InputMaybe<Array<Scalars['BigInt']>>;
  pid_isNull?: InputMaybe<Scalars['Boolean']>;
  pid_lt?: InputMaybe<Scalars['BigInt']>;
  pid_lte?: InputMaybe<Scalars['BigInt']>;
  pid_not_eq?: InputMaybe<Scalars['BigInt']>;
  pid_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  releasingStake_eq?: InputMaybe<Scalars['BigDecimal']>;
  releasingStake_gt?: InputMaybe<Scalars['BigDecimal']>;
  releasingStake_gte?: InputMaybe<Scalars['BigDecimal']>;
  releasingStake_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  releasingStake_isNull?: InputMaybe<Scalars['Boolean']>;
  releasingStake_lt?: InputMaybe<Scalars['BigDecimal']>;
  releasingStake_lte?: InputMaybe<Scalars['BigDecimal']>;
  releasingStake_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  releasingStake_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  stakes_every?: InputMaybe<StakePoolStakeWhereInput>;
  stakes_none?: InputMaybe<StakePoolStakeWhereInput>;
  stakes_some?: InputMaybe<StakePoolStakeWhereInput>;
  totalShares_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalShares_gt?: InputMaybe<Scalars['BigDecimal']>;
  totalShares_gte?: InputMaybe<Scalars['BigDecimal']>;
  totalShares_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalShares_isNull?: InputMaybe<Scalars['Boolean']>;
  totalShares_lt?: InputMaybe<Scalars['BigDecimal']>;
  totalShares_lte?: InputMaybe<Scalars['BigDecimal']>;
  totalShares_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalShares_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalStake_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_gt?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_gte?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalStake_isNull?: InputMaybe<Scalars['Boolean']>;
  totalStake_lt?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_lte?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalStake_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalWithdrawal_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalWithdrawal_gt?: InputMaybe<Scalars['BigDecimal']>;
  totalWithdrawal_gte?: InputMaybe<Scalars['BigDecimal']>;
  totalWithdrawal_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  totalWithdrawal_isNull?: InputMaybe<Scalars['Boolean']>;
  totalWithdrawal_lt?: InputMaybe<Scalars['BigDecimal']>;
  totalWithdrawal_lte?: InputMaybe<Scalars['BigDecimal']>;
  totalWithdrawal_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  totalWithdrawal_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  whitelistEnabled_eq?: InputMaybe<Scalars['Boolean']>;
  whitelistEnabled_isNull?: InputMaybe<Scalars['Boolean']>;
  whitelistEnabled_not_eq?: InputMaybe<Scalars['Boolean']>;
  whitelists_every?: InputMaybe<StakePoolWhitelistWhereInput>;
  whitelists_none?: InputMaybe<StakePoolWhitelistWhereInput>;
  whitelists_some?: InputMaybe<StakePoolWhitelistWhereInput>;
  workerCount_eq?: InputMaybe<Scalars['Int']>;
  workerCount_gt?: InputMaybe<Scalars['Int']>;
  workerCount_gte?: InputMaybe<Scalars['Int']>;
  workerCount_in?: InputMaybe<Array<Scalars['Int']>>;
  workerCount_isNull?: InputMaybe<Scalars['Boolean']>;
  workerCount_lt?: InputMaybe<Scalars['Int']>;
  workerCount_lte?: InputMaybe<Scalars['Int']>;
  workerCount_not_eq?: InputMaybe<Scalars['Int']>;
  workerCount_not_in?: InputMaybe<Array<Scalars['Int']>>;
  workers_every?: InputMaybe<WorkerWhereInput>;
  workers_none?: InputMaybe<WorkerWhereInput>;
  workers_some?: InputMaybe<WorkerWhereInput>;
};

export type StakePoolWhitelist = {
  __typename?: 'StakePoolWhitelist';
  account: Account;
  createTime: Scalars['DateTime'];
  id: Scalars['String'];
  stakePool: StakePool;
};

export type StakePoolWhitelistEdge = {
  __typename?: 'StakePoolWhitelistEdge';
  cursor: Scalars['String'];
  node: StakePoolWhitelist;
};

export enum StakePoolWhitelistOrderByInput {
  AccountIdAsc = 'account_id_ASC',
  AccountIdDesc = 'account_id_DESC',
  AccountTotalOwnerRewardAsc = 'account_totalOwnerReward_ASC',
  AccountTotalOwnerRewardDesc = 'account_totalOwnerReward_DESC',
  AccountTotalStakeRewardAsc = 'account_totalStakeReward_ASC',
  AccountTotalStakeRewardDesc = 'account_totalStakeReward_DESC',
  AccountTotalStakeAsc = 'account_totalStake_ASC',
  AccountTotalStakeDesc = 'account_totalStake_DESC',
  CreateTimeAsc = 'createTime_ASC',
  CreateTimeDesc = 'createTime_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  StakePoolActiveStakeCountAsc = 'stakePool_activeStakeCount_ASC',
  StakePoolActiveStakeCountDesc = 'stakePool_activeStakeCount_DESC',
  StakePoolAprBaseAsc = 'stakePool_aprBase_ASC',
  StakePoolAprBaseDesc = 'stakePool_aprBase_DESC',
  StakePoolCapacityAsc = 'stakePool_capacity_ASC',
  StakePoolCapacityDesc = 'stakePool_capacity_DESC',
  StakePoolCommissionAsc = 'stakePool_commission_ASC',
  StakePoolCommissionDesc = 'stakePool_commission_DESC',
  StakePoolDelegableAsc = 'stakePool_delegable_ASC',
  StakePoolDelegableDesc = 'stakePool_delegable_DESC',
  StakePoolFreeStakeAsc = 'stakePool_freeStake_ASC',
  StakePoolFreeStakeDesc = 'stakePool_freeStake_DESC',
  StakePoolIdAsc = 'stakePool_id_ASC',
  StakePoolIdDesc = 'stakePool_id_DESC',
  StakePoolMiningWorkerCountAsc = 'stakePool_miningWorkerCount_ASC',
  StakePoolMiningWorkerCountDesc = 'stakePool_miningWorkerCount_DESC',
  StakePoolMiningWorkerShareAsc = 'stakePool_miningWorkerShare_ASC',
  StakePoolMiningWorkerShareDesc = 'stakePool_miningWorkerShare_DESC',
  StakePoolOwnerRewardAsc = 'stakePool_ownerReward_ASC',
  StakePoolOwnerRewardDesc = 'stakePool_ownerReward_DESC',
  StakePoolPidAsc = 'stakePool_pid_ASC',
  StakePoolPidDesc = 'stakePool_pid_DESC',
  StakePoolReleasingStakeAsc = 'stakePool_releasingStake_ASC',
  StakePoolReleasingStakeDesc = 'stakePool_releasingStake_DESC',
  StakePoolTotalSharesAsc = 'stakePool_totalShares_ASC',
  StakePoolTotalSharesDesc = 'stakePool_totalShares_DESC',
  StakePoolTotalStakeAsc = 'stakePool_totalStake_ASC',
  StakePoolTotalStakeDesc = 'stakePool_totalStake_DESC',
  StakePoolTotalWithdrawalAsc = 'stakePool_totalWithdrawal_ASC',
  StakePoolTotalWithdrawalDesc = 'stakePool_totalWithdrawal_DESC',
  StakePoolWhitelistEnabledAsc = 'stakePool_whitelistEnabled_ASC',
  StakePoolWhitelistEnabledDesc = 'stakePool_whitelistEnabled_DESC',
  StakePoolWorkerCountAsc = 'stakePool_workerCount_ASC',
  StakePoolWorkerCountDesc = 'stakePool_workerCount_DESC'
}

export type StakePoolWhitelistWhereInput = {
  AND?: InputMaybe<Array<StakePoolWhitelistWhereInput>>;
  OR?: InputMaybe<Array<StakePoolWhitelistWhereInput>>;
  account?: InputMaybe<AccountWhereInput>;
  account_isNull?: InputMaybe<Scalars['Boolean']>;
  createTime_eq?: InputMaybe<Scalars['DateTime']>;
  createTime_gt?: InputMaybe<Scalars['DateTime']>;
  createTime_gte?: InputMaybe<Scalars['DateTime']>;
  createTime_in?: InputMaybe<Array<Scalars['DateTime']>>;
  createTime_isNull?: InputMaybe<Scalars['Boolean']>;
  createTime_lt?: InputMaybe<Scalars['DateTime']>;
  createTime_lte?: InputMaybe<Scalars['DateTime']>;
  createTime_not_eq?: InputMaybe<Scalars['DateTime']>;
  createTime_not_in?: InputMaybe<Array<Scalars['DateTime']>>;
  id_contains?: InputMaybe<Scalars['String']>;
  id_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_endsWith?: InputMaybe<Scalars['String']>;
  id_eq?: InputMaybe<Scalars['String']>;
  id_gt?: InputMaybe<Scalars['String']>;
  id_gte?: InputMaybe<Scalars['String']>;
  id_in?: InputMaybe<Array<Scalars['String']>>;
  id_isNull?: InputMaybe<Scalars['Boolean']>;
  id_lt?: InputMaybe<Scalars['String']>;
  id_lte?: InputMaybe<Scalars['String']>;
  id_not_contains?: InputMaybe<Scalars['String']>;
  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_not_endsWith?: InputMaybe<Scalars['String']>;
  id_not_eq?: InputMaybe<Scalars['String']>;
  id_not_in?: InputMaybe<Array<Scalars['String']>>;
  id_not_startsWith?: InputMaybe<Scalars['String']>;
  id_startsWith?: InputMaybe<Scalars['String']>;
  stakePool?: InputMaybe<StakePoolWhereInput>;
  stakePool_isNull?: InputMaybe<Scalars['Boolean']>;
};

export type StakePoolWhitelistsConnection = {
  __typename?: 'StakePoolWhitelistsConnection';
  edges: Array<StakePoolWhitelistEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type StakePoolsConnection = {
  __typename?: 'StakePoolsConnection';
  edges: Array<StakePoolEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type Subscription = {
  __typename?: 'Subscription';
  accountById?: Maybe<Account>;
  accounts: Array<Account>;
  globalStateById?: Maybe<GlobalState>;
  globalStates: Array<GlobalState>;
  minerById?: Maybe<Miner>;
  miners: Array<Miner>;
  stakePoolById?: Maybe<StakePool>;
  stakePoolStakeById?: Maybe<StakePoolStake>;
  stakePoolStakes: Array<StakePoolStake>;
  stakePoolWhitelistById?: Maybe<StakePoolWhitelist>;
  stakePoolWhitelists: Array<StakePoolWhitelist>;
  stakePools: Array<StakePool>;
  tokenomicParameters: Array<TokenomicParameters>;
  tokenomicParametersById?: Maybe<TokenomicParameters>;
  workerById?: Maybe<Worker>;
  workers: Array<Worker>;
};


export type SubscriptionAccountByIdArgs = {
  id: Scalars['String'];
};


export type SubscriptionAccountsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountOrderByInput>>;
  where?: InputMaybe<AccountWhereInput>;
};


export type SubscriptionGlobalStateByIdArgs = {
  id: Scalars['String'];
};


export type SubscriptionGlobalStatesArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GlobalStateOrderByInput>>;
  where?: InputMaybe<GlobalStateWhereInput>;
};


export type SubscriptionMinerByIdArgs = {
  id: Scalars['String'];
};


export type SubscriptionMinersArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MinerOrderByInput>>;
  where?: InputMaybe<MinerWhereInput>;
};


export type SubscriptionStakePoolByIdArgs = {
  id: Scalars['String'];
};


export type SubscriptionStakePoolStakeByIdArgs = {
  id: Scalars['String'];
};


export type SubscriptionStakePoolStakesArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StakePoolStakeOrderByInput>>;
  where?: InputMaybe<StakePoolStakeWhereInput>;
};


export type SubscriptionStakePoolWhitelistByIdArgs = {
  id: Scalars['String'];
};


export type SubscriptionStakePoolWhitelistsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StakePoolWhitelistOrderByInput>>;
  where?: InputMaybe<StakePoolWhitelistWhereInput>;
};


export type SubscriptionStakePoolsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StakePoolOrderByInput>>;
  where?: InputMaybe<StakePoolWhereInput>;
};


export type SubscriptionTokenomicParametersArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TokenomicParametersOrderByInput>>;
  where?: InputMaybe<TokenomicParametersWhereInput>;
};


export type SubscriptionTokenomicParametersByIdArgs = {
  id: Scalars['String'];
};


export type SubscriptionWorkerByIdArgs = {
  id: Scalars['String'];
};


export type SubscriptionWorkersArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WorkerOrderByInput>>;
  where?: InputMaybe<WorkerWhereInput>;
};

export type TokenomicParameters = {
  __typename?: 'TokenomicParameters';
  budgetPerBlock: Scalars['BigDecimal'];
  id: Scalars['String'];
  k: Scalars['BigDecimal'];
  phaRate: Scalars['BigDecimal'];
  re: Scalars['BigDecimal'];
  treasuryRatio: Scalars['BigDecimal'];
  vMax: Scalars['BigDecimal'];
};

export type TokenomicParametersConnection = {
  __typename?: 'TokenomicParametersConnection';
  edges: Array<TokenomicParametersEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type TokenomicParametersEdge = {
  __typename?: 'TokenomicParametersEdge';
  cursor: Scalars['String'];
  node: TokenomicParameters;
};

export enum TokenomicParametersOrderByInput {
  BudgetPerBlockAsc = 'budgetPerBlock_ASC',
  BudgetPerBlockDesc = 'budgetPerBlock_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  KAsc = 'k_ASC',
  KDesc = 'k_DESC',
  PhaRateAsc = 'phaRate_ASC',
  PhaRateDesc = 'phaRate_DESC',
  ReAsc = 're_ASC',
  ReDesc = 're_DESC',
  TreasuryRatioAsc = 'treasuryRatio_ASC',
  TreasuryRatioDesc = 'treasuryRatio_DESC',
  VMaxAsc = 'vMax_ASC',
  VMaxDesc = 'vMax_DESC'
}

export type TokenomicParametersWhereInput = {
  AND?: InputMaybe<Array<TokenomicParametersWhereInput>>;
  OR?: InputMaybe<Array<TokenomicParametersWhereInput>>;
  budgetPerBlock_eq?: InputMaybe<Scalars['BigDecimal']>;
  budgetPerBlock_gt?: InputMaybe<Scalars['BigDecimal']>;
  budgetPerBlock_gte?: InputMaybe<Scalars['BigDecimal']>;
  budgetPerBlock_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  budgetPerBlock_isNull?: InputMaybe<Scalars['Boolean']>;
  budgetPerBlock_lt?: InputMaybe<Scalars['BigDecimal']>;
  budgetPerBlock_lte?: InputMaybe<Scalars['BigDecimal']>;
  budgetPerBlock_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  budgetPerBlock_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  id_contains?: InputMaybe<Scalars['String']>;
  id_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_endsWith?: InputMaybe<Scalars['String']>;
  id_eq?: InputMaybe<Scalars['String']>;
  id_gt?: InputMaybe<Scalars['String']>;
  id_gte?: InputMaybe<Scalars['String']>;
  id_in?: InputMaybe<Array<Scalars['String']>>;
  id_isNull?: InputMaybe<Scalars['Boolean']>;
  id_lt?: InputMaybe<Scalars['String']>;
  id_lte?: InputMaybe<Scalars['String']>;
  id_not_contains?: InputMaybe<Scalars['String']>;
  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_not_endsWith?: InputMaybe<Scalars['String']>;
  id_not_eq?: InputMaybe<Scalars['String']>;
  id_not_in?: InputMaybe<Array<Scalars['String']>>;
  id_not_startsWith?: InputMaybe<Scalars['String']>;
  id_startsWith?: InputMaybe<Scalars['String']>;
  k_eq?: InputMaybe<Scalars['BigDecimal']>;
  k_gt?: InputMaybe<Scalars['BigDecimal']>;
  k_gte?: InputMaybe<Scalars['BigDecimal']>;
  k_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  k_isNull?: InputMaybe<Scalars['Boolean']>;
  k_lt?: InputMaybe<Scalars['BigDecimal']>;
  k_lte?: InputMaybe<Scalars['BigDecimal']>;
  k_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  k_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  phaRate_eq?: InputMaybe<Scalars['BigDecimal']>;
  phaRate_gt?: InputMaybe<Scalars['BigDecimal']>;
  phaRate_gte?: InputMaybe<Scalars['BigDecimal']>;
  phaRate_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  phaRate_isNull?: InputMaybe<Scalars['Boolean']>;
  phaRate_lt?: InputMaybe<Scalars['BigDecimal']>;
  phaRate_lte?: InputMaybe<Scalars['BigDecimal']>;
  phaRate_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  phaRate_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  re_eq?: InputMaybe<Scalars['BigDecimal']>;
  re_gt?: InputMaybe<Scalars['BigDecimal']>;
  re_gte?: InputMaybe<Scalars['BigDecimal']>;
  re_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  re_isNull?: InputMaybe<Scalars['Boolean']>;
  re_lt?: InputMaybe<Scalars['BigDecimal']>;
  re_lte?: InputMaybe<Scalars['BigDecimal']>;
  re_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  re_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  treasuryRatio_eq?: InputMaybe<Scalars['BigDecimal']>;
  treasuryRatio_gt?: InputMaybe<Scalars['BigDecimal']>;
  treasuryRatio_gte?: InputMaybe<Scalars['BigDecimal']>;
  treasuryRatio_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  treasuryRatio_isNull?: InputMaybe<Scalars['Boolean']>;
  treasuryRatio_lt?: InputMaybe<Scalars['BigDecimal']>;
  treasuryRatio_lte?: InputMaybe<Scalars['BigDecimal']>;
  treasuryRatio_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  treasuryRatio_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  vMax_eq?: InputMaybe<Scalars['BigDecimal']>;
  vMax_gt?: InputMaybe<Scalars['BigDecimal']>;
  vMax_gte?: InputMaybe<Scalars['BigDecimal']>;
  vMax_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  vMax_isNull?: InputMaybe<Scalars['Boolean']>;
  vMax_lt?: InputMaybe<Scalars['BigDecimal']>;
  vMax_lte?: InputMaybe<Scalars['BigDecimal']>;
  vMax_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  vMax_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
};

export type WhereIdInput = {
  id: Scalars['String'];
};

export type Worker = {
  __typename?: 'Worker';
  confidenceLevel: Scalars['Int'];
  id: Scalars['String'];
  initialScore?: Maybe<Scalars['Int']>;
  miner?: Maybe<Miner>;
  sMax?: Maybe<Scalars['BigDecimal']>;
  sMin?: Maybe<Scalars['BigDecimal']>;
  share?: Maybe<Scalars['BigDecimal']>;
  stakePool?: Maybe<StakePool>;
};

export type WorkerEdge = {
  __typename?: 'WorkerEdge';
  cursor: Scalars['String'];
  node: Worker;
};

export enum WorkerOrderByInput {
  ConfidenceLevelAsc = 'confidenceLevel_ASC',
  ConfidenceLevelDesc = 'confidenceLevel_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  InitialScoreAsc = 'initialScore_ASC',
  InitialScoreDesc = 'initialScore_DESC',
  MinerCoolingDownStartTimeAsc = 'miner_coolingDownStartTime_ASC',
  MinerCoolingDownStartTimeDesc = 'miner_coolingDownStartTime_DESC',
  MinerIdAsc = 'miner_id_ASC',
  MinerIdDesc = 'miner_id_DESC',
  MinerIsBoundAsc = 'miner_isBound_ASC',
  MinerIsBoundDesc = 'miner_isBound_DESC',
  MinerPInitAsc = 'miner_pInit_ASC',
  MinerPInitDesc = 'miner_pInit_DESC',
  MinerPInstantAsc = 'miner_pInstant_ASC',
  MinerPInstantDesc = 'miner_pInstant_DESC',
  MinerStakeAsc = 'miner_stake_ASC',
  MinerStakeDesc = 'miner_stake_DESC',
  MinerStateAsc = 'miner_state_ASC',
  MinerStateDesc = 'miner_state_DESC',
  MinerTotalRewardAsc = 'miner_totalReward_ASC',
  MinerTotalRewardDesc = 'miner_totalReward_DESC',
  MinerVAsc = 'miner_v_ASC',
  MinerVDesc = 'miner_v_DESC',
  MinerVeAsc = 'miner_ve_ASC',
  MinerVeDesc = 'miner_ve_DESC',
  SMaxAsc = 'sMax_ASC',
  SMaxDesc = 'sMax_DESC',
  SMinAsc = 'sMin_ASC',
  SMinDesc = 'sMin_DESC',
  ShareAsc = 'share_ASC',
  ShareDesc = 'share_DESC',
  StakePoolActiveStakeCountAsc = 'stakePool_activeStakeCount_ASC',
  StakePoolActiveStakeCountDesc = 'stakePool_activeStakeCount_DESC',
  StakePoolAprBaseAsc = 'stakePool_aprBase_ASC',
  StakePoolAprBaseDesc = 'stakePool_aprBase_DESC',
  StakePoolCapacityAsc = 'stakePool_capacity_ASC',
  StakePoolCapacityDesc = 'stakePool_capacity_DESC',
  StakePoolCommissionAsc = 'stakePool_commission_ASC',
  StakePoolCommissionDesc = 'stakePool_commission_DESC',
  StakePoolDelegableAsc = 'stakePool_delegable_ASC',
  StakePoolDelegableDesc = 'stakePool_delegable_DESC',
  StakePoolFreeStakeAsc = 'stakePool_freeStake_ASC',
  StakePoolFreeStakeDesc = 'stakePool_freeStake_DESC',
  StakePoolIdAsc = 'stakePool_id_ASC',
  StakePoolIdDesc = 'stakePool_id_DESC',
  StakePoolMiningWorkerCountAsc = 'stakePool_miningWorkerCount_ASC',
  StakePoolMiningWorkerCountDesc = 'stakePool_miningWorkerCount_DESC',
  StakePoolMiningWorkerShareAsc = 'stakePool_miningWorkerShare_ASC',
  StakePoolMiningWorkerShareDesc = 'stakePool_miningWorkerShare_DESC',
  StakePoolOwnerRewardAsc = 'stakePool_ownerReward_ASC',
  StakePoolOwnerRewardDesc = 'stakePool_ownerReward_DESC',
  StakePoolPidAsc = 'stakePool_pid_ASC',
  StakePoolPidDesc = 'stakePool_pid_DESC',
  StakePoolReleasingStakeAsc = 'stakePool_releasingStake_ASC',
  StakePoolReleasingStakeDesc = 'stakePool_releasingStake_DESC',
  StakePoolTotalSharesAsc = 'stakePool_totalShares_ASC',
  StakePoolTotalSharesDesc = 'stakePool_totalShares_DESC',
  StakePoolTotalStakeAsc = 'stakePool_totalStake_ASC',
  StakePoolTotalStakeDesc = 'stakePool_totalStake_DESC',
  StakePoolTotalWithdrawalAsc = 'stakePool_totalWithdrawal_ASC',
  StakePoolTotalWithdrawalDesc = 'stakePool_totalWithdrawal_DESC',
  StakePoolWhitelistEnabledAsc = 'stakePool_whitelistEnabled_ASC',
  StakePoolWhitelistEnabledDesc = 'stakePool_whitelistEnabled_DESC',
  StakePoolWorkerCountAsc = 'stakePool_workerCount_ASC',
  StakePoolWorkerCountDesc = 'stakePool_workerCount_DESC'
}

export type WorkerWhereInput = {
  AND?: InputMaybe<Array<WorkerWhereInput>>;
  OR?: InputMaybe<Array<WorkerWhereInput>>;
  confidenceLevel_eq?: InputMaybe<Scalars['Int']>;
  confidenceLevel_gt?: InputMaybe<Scalars['Int']>;
  confidenceLevel_gte?: InputMaybe<Scalars['Int']>;
  confidenceLevel_in?: InputMaybe<Array<Scalars['Int']>>;
  confidenceLevel_isNull?: InputMaybe<Scalars['Boolean']>;
  confidenceLevel_lt?: InputMaybe<Scalars['Int']>;
  confidenceLevel_lte?: InputMaybe<Scalars['Int']>;
  confidenceLevel_not_eq?: InputMaybe<Scalars['Int']>;
  confidenceLevel_not_in?: InputMaybe<Array<Scalars['Int']>>;
  id_contains?: InputMaybe<Scalars['String']>;
  id_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_endsWith?: InputMaybe<Scalars['String']>;
  id_eq?: InputMaybe<Scalars['String']>;
  id_gt?: InputMaybe<Scalars['String']>;
  id_gte?: InputMaybe<Scalars['String']>;
  id_in?: InputMaybe<Array<Scalars['String']>>;
  id_isNull?: InputMaybe<Scalars['Boolean']>;
  id_lt?: InputMaybe<Scalars['String']>;
  id_lte?: InputMaybe<Scalars['String']>;
  id_not_contains?: InputMaybe<Scalars['String']>;
  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;
  id_not_endsWith?: InputMaybe<Scalars['String']>;
  id_not_eq?: InputMaybe<Scalars['String']>;
  id_not_in?: InputMaybe<Array<Scalars['String']>>;
  id_not_startsWith?: InputMaybe<Scalars['String']>;
  id_startsWith?: InputMaybe<Scalars['String']>;
  initialScore_eq?: InputMaybe<Scalars['Int']>;
  initialScore_gt?: InputMaybe<Scalars['Int']>;
  initialScore_gte?: InputMaybe<Scalars['Int']>;
  initialScore_in?: InputMaybe<Array<Scalars['Int']>>;
  initialScore_isNull?: InputMaybe<Scalars['Boolean']>;
  initialScore_lt?: InputMaybe<Scalars['Int']>;
  initialScore_lte?: InputMaybe<Scalars['Int']>;
  initialScore_not_eq?: InputMaybe<Scalars['Int']>;
  initialScore_not_in?: InputMaybe<Array<Scalars['Int']>>;
  miner?: InputMaybe<MinerWhereInput>;
  miner_isNull?: InputMaybe<Scalars['Boolean']>;
  sMax_eq?: InputMaybe<Scalars['BigDecimal']>;
  sMax_gt?: InputMaybe<Scalars['BigDecimal']>;
  sMax_gte?: InputMaybe<Scalars['BigDecimal']>;
  sMax_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  sMax_isNull?: InputMaybe<Scalars['Boolean']>;
  sMax_lt?: InputMaybe<Scalars['BigDecimal']>;
  sMax_lte?: InputMaybe<Scalars['BigDecimal']>;
  sMax_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  sMax_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  sMin_eq?: InputMaybe<Scalars['BigDecimal']>;
  sMin_gt?: InputMaybe<Scalars['BigDecimal']>;
  sMin_gte?: InputMaybe<Scalars['BigDecimal']>;
  sMin_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  sMin_isNull?: InputMaybe<Scalars['Boolean']>;
  sMin_lt?: InputMaybe<Scalars['BigDecimal']>;
  sMin_lte?: InputMaybe<Scalars['BigDecimal']>;
  sMin_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  sMin_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  share_eq?: InputMaybe<Scalars['BigDecimal']>;
  share_gt?: InputMaybe<Scalars['BigDecimal']>;
  share_gte?: InputMaybe<Scalars['BigDecimal']>;
  share_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  share_isNull?: InputMaybe<Scalars['Boolean']>;
  share_lt?: InputMaybe<Scalars['BigDecimal']>;
  share_lte?: InputMaybe<Scalars['BigDecimal']>;
  share_not_eq?: InputMaybe<Scalars['BigDecimal']>;
  share_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  stakePool?: InputMaybe<StakePoolWhereInput>;
  stakePool_isNull?: InputMaybe<Scalars['Boolean']>;
};

export type WorkersConnection = {
  __typename?: 'WorkersConnection';
  edges: Array<WorkerEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type AccountRewardsQueryVariables = Exact<{
  accountId: Scalars['String'];
}>;


export type AccountRewardsQuery = { __typename?: 'Query', globalStateById?: { __typename?: 'GlobalState', height: number } | null, accountById?: { __typename?: 'Account', id: string, totalStake: string, totalStakeReward: string, totalOwnerReward: string } | null };

export type GlobalStateQueryVariables = Exact<{ [key: string]: never; }>;


export type GlobalStateQuery = { __typename?: 'Query', globalStateById?: { __typename?: 'GlobalState', height: number, totalStake: string, averageBlockTime: number, miningWorkerShare: string } | null };

export type StakePoolByIdQueryVariables = Exact<{
  stakePoolByIdId: Scalars['String'];
  accountId?: InputMaybe<Scalars['String']>;
  withWhitelist?: InputMaybe<Scalars['Boolean']>;
}>;


export type StakePoolByIdQuery = { __typename?: 'Query', stakePoolById?: { __typename?: 'StakePool', id: string, pid: string, commission: string, capacity?: string | null, delegable?: string | null, freeStake: string, totalStake: string, releasingStake: string, totalShares: string, ownerReward: string, activeStakeCount: number, workerCount: number, miningWorkerCount: number, totalWithdrawal: string, miningWorkerShare: string, aprBase: string, whitelistEnabled: boolean, owner: { __typename?: 'Account', id: string }, whitelists?: Array<{ __typename?: 'StakePoolWhitelist', id: string, createTime: string }> } | null };

export type StakePoolStakesConnectionQueryVariables = Exact<{
  orderBy: Array<StakePoolStakeOrderByInput> | StakePoolStakeOrderByInput;
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolStakeWhereInput>;
}>;


export type StakePoolStakesConnectionQuery = { __typename?: 'Query', stakePoolStakesConnection: { __typename?: 'StakePoolStakesConnection', totalCount: number, edges: Array<{ __typename?: 'StakePoolStakeEdge', cursor: string, node: { __typename?: 'StakePoolStake', amount: string, shares: string, reward: string, withdrawalAmount: string, withdrawalShares: string, withdrawalStartTime?: string | null, account: { __typename?: 'Account', id: string }, stakePool: { __typename?: 'StakePool', id: string, pid: string, commission: string, capacity?: string | null, delegable?: string | null, freeStake: string, releasingStake: string, totalStake: string, totalShares: string, ownerReward: string, activeStakeCount: number, workerCount: number, miningWorkerCount: number, totalWithdrawal: string, owner: { __typename?: 'Account', id: string } } } }>, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor: string, endCursor: string } } };

export type StakePoolWhitelistsConnectionQueryVariables = Exact<{
  orderBy: Array<StakePoolWhitelistOrderByInput> | StakePoolWhitelistOrderByInput;
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWhitelistWhereInput>;
}>;


export type StakePoolWhitelistsConnectionQuery = { __typename?: 'Query', stakePoolWhitelistsConnection: { __typename?: 'StakePoolWhitelistsConnection', totalCount: number, edges: Array<{ __typename?: 'StakePoolWhitelistEdge', cursor: string, node: { __typename?: 'StakePoolWhitelist', createTime: string, account: { __typename?: 'Account', id: string }, stakePool: { __typename?: 'StakePool', id: string } } }>, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor: string, endCursor: string } }, globalStateById?: { __typename?: 'GlobalState', height: number } | null };

export type StakePoolsConnectionQueryVariables = Exact<{
  orderBy: Array<StakePoolOrderByInput> | StakePoolOrderByInput;
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StakePoolWhereInput>;
  accountId?: InputMaybe<Scalars['String']>;
  withStake?: InputMaybe<Scalars['Boolean']>;
  withWhitelist?: InputMaybe<Scalars['Boolean']>;
}>;


export type StakePoolsConnectionQuery = { __typename?: 'Query', stakePoolsConnection: { __typename?: 'StakePoolsConnection', totalCount: number, edges: Array<{ __typename?: 'StakePoolEdge', cursor: string, node: { __typename?: 'StakePool', id: string, pid: string, commission: string, delegable?: string | null, capacity?: string | null, freeStake: string, releasingStake: string, totalStake: string, totalShares: string, ownerReward: string, workerCount: number, miningWorkerCount: number, totalWithdrawal: string, activeStakeCount: number, miningWorkerShare: string, aprBase: string, whitelistEnabled: boolean, owner: { __typename?: 'Account', id: string }, whitelists?: Array<{ __typename?: 'StakePoolWhitelist', id: string, createTime: string }>, stakes?: Array<{ __typename?: 'StakePoolStake', id: string, amount: string, shares: string, reward: string, withdrawalAmount: string, withdrawalShares: string, withdrawalStartTime?: string | null }> } }>, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor: string, endCursor: string } } };

export type TokenomicParametersQueryVariables = Exact<{ [key: string]: never; }>;


export type TokenomicParametersQuery = { __typename?: 'Query', tokenomicParametersById?: { __typename?: 'TokenomicParameters', phaRate: string, budgetPerBlock: string, vMax: string, treasuryRatio: string, k: string, re: string } | null };

export type WorkersConnectionQueryVariables = Exact<{
  orderBy: Array<WorkerOrderByInput> | WorkerOrderByInput;
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkerWhereInput>;
}>;


export type WorkersConnectionQuery = { __typename?: 'Query', workersConnection: { __typename?: 'WorkersConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor: string, endCursor: string }, edges: Array<{ __typename?: 'WorkerEdge', cursor: string, node: { __typename?: 'Worker', id: string, confidenceLevel: number, initialScore?: number | null, sMin?: string | null, sMax?: string | null, stakePool?: { __typename?: 'StakePool', id: string, freeStake: string } | null, miner?: { __typename?: 'Miner', id: string, isBound: boolean, stake: string, state: MinerState, v: string, ve: string, pInit: number, pInstant: number, totalReward: string, coolingDownStartTime?: string | null } | null } }> }, globalStateById?: { __typename?: 'GlobalState', height: number } | null };


export const AccountRewardsDocument = `
    query AccountRewards($accountId: String!) {
  globalStateById(id: "0") {
    height
  }
  accountById(id: $accountId) {
    id
    totalStake
    totalStakeReward
    totalOwnerReward
  }
}
    `;
export const useAccountRewardsQuery = <
      TData = AccountRewardsQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables: AccountRewardsQueryVariables,
      options?: UseQueryOptions<AccountRewardsQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<AccountRewardsQuery, TError, TData>(
      ['AccountRewards', variables],
      fetcher<AccountRewardsQuery, AccountRewardsQueryVariables>(client, AccountRewardsDocument, variables, headers),
      options
    );
export const GlobalStateDocument = `
    query GlobalState {
  globalStateById(id: "0") {
    height
    totalStake
    averageBlockTime
    miningWorkerShare
  }
}
    `;
export const useGlobalStateQuery = <
      TData = GlobalStateQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: GlobalStateQueryVariables,
      options?: UseQueryOptions<GlobalStateQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<GlobalStateQuery, TError, TData>(
      variables === undefined ? ['GlobalState'] : ['GlobalState', variables],
      fetcher<GlobalStateQuery, GlobalStateQueryVariables>(client, GlobalStateDocument, variables, headers),
      options
    );
export const StakePoolByIdDocument = `
    query StakePoolById($stakePoolByIdId: String!, $accountId: String, $withWhitelist: Boolean = false) {
  stakePoolById(id: $stakePoolByIdId) {
    id
    pid
    owner {
      id
    }
    commission
    capacity
    delegable
    freeStake
    totalStake
    releasingStake
    totalShares
    ownerReward
    activeStakeCount
    workerCount
    miningWorkerCount
    totalWithdrawal
    whitelists(where: {account: {id_eq: $accountId}}, limit: 1) @include(if: $withWhitelist) {
      id
      createTime
    }
    miningWorkerShare
    aprBase
    whitelistEnabled
  }
}
    `;
export const useStakePoolByIdQuery = <
      TData = StakePoolByIdQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables: StakePoolByIdQueryVariables,
      options?: UseQueryOptions<StakePoolByIdQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<StakePoolByIdQuery, TError, TData>(
      ['StakePoolById', variables],
      fetcher<StakePoolByIdQuery, StakePoolByIdQueryVariables>(client, StakePoolByIdDocument, variables, headers),
      options
    );
export const StakePoolStakesConnectionDocument = `
    query StakePoolStakesConnection($orderBy: [StakePoolStakeOrderByInput!]!, $after: String, $first: Int, $where: StakePoolStakeWhereInput) {
  stakePoolStakesConnection(
    orderBy: $orderBy
    after: $after
    first: $first
    where: $where
  ) {
    edges {
      node {
        account {
          id
        }
        stakePool {
          id
          pid
          owner {
            id
          }
          commission
          capacity
          delegable
          freeStake
          releasingStake
          totalStake
          totalShares
          ownerReward
          activeStakeCount
          workerCount
          miningWorkerCount
          totalWithdrawal
        }
        amount
        shares
        reward
        withdrawalAmount
        withdrawalShares
        withdrawalStartTime
      }
      cursor
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
  }
}
    `;
export const useStakePoolStakesConnectionQuery = <
      TData = StakePoolStakesConnectionQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables: StakePoolStakesConnectionQueryVariables,
      options?: UseQueryOptions<StakePoolStakesConnectionQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<StakePoolStakesConnectionQuery, TError, TData>(
      ['StakePoolStakesConnection', variables],
      fetcher<StakePoolStakesConnectionQuery, StakePoolStakesConnectionQueryVariables>(client, StakePoolStakesConnectionDocument, variables, headers),
      options
    );
export const StakePoolWhitelistsConnectionDocument = `
    query StakePoolWhitelistsConnection($orderBy: [StakePoolWhitelistOrderByInput!]!, $after: String, $first: Int, $where: StakePoolWhitelistWhereInput) {
  stakePoolWhitelistsConnection(
    orderBy: $orderBy
    after: $after
    first: $first
    where: $where
  ) {
    edges {
      node {
        createTime
        account {
          id
        }
        stakePool {
          id
        }
      }
      cursor
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
  }
  globalStateById(id: "0") {
    height
  }
}
    `;
export const useStakePoolWhitelistsConnectionQuery = <
      TData = StakePoolWhitelistsConnectionQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables: StakePoolWhitelistsConnectionQueryVariables,
      options?: UseQueryOptions<StakePoolWhitelistsConnectionQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<StakePoolWhitelistsConnectionQuery, TError, TData>(
      ['StakePoolWhitelistsConnection', variables],
      fetcher<StakePoolWhitelistsConnectionQuery, StakePoolWhitelistsConnectionQueryVariables>(client, StakePoolWhitelistsConnectionDocument, variables, headers),
      options
    );
export const StakePoolsConnectionDocument = `
    query StakePoolsConnection($orderBy: [StakePoolOrderByInput!]!, $after: String, $first: Int, $where: StakePoolWhereInput, $accountId: String, $withStake: Boolean = false, $withWhitelist: Boolean = false) {
  stakePoolsConnection(
    orderBy: $orderBy
    after: $after
    first: $first
    where: $where
  ) {
    edges {
      node {
        id
        pid
        owner {
          id
        }
        commission
        delegable
        capacity
        freeStake
        releasingStake
        totalStake
        totalShares
        ownerReward
        workerCount
        miningWorkerCount
        totalWithdrawal
        activeStakeCount
        whitelists(where: {account: {id_eq: $accountId}}, limit: 1) @include(if: $withWhitelist) {
          id
          createTime
        }
        stakes(where: {account: {id_eq: $accountId}}, limit: 1) @include(if: $withStake) {
          id
          amount
          shares
          reward
          withdrawalAmount
          withdrawalShares
          withdrawalStartTime
        }
        miningWorkerShare
        aprBase
        whitelistEnabled
      }
      cursor
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
  }
}
    `;
export const useStakePoolsConnectionQuery = <
      TData = StakePoolsConnectionQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables: StakePoolsConnectionQueryVariables,
      options?: UseQueryOptions<StakePoolsConnectionQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<StakePoolsConnectionQuery, TError, TData>(
      ['StakePoolsConnection', variables],
      fetcher<StakePoolsConnectionQuery, StakePoolsConnectionQueryVariables>(client, StakePoolsConnectionDocument, variables, headers),
      options
    );
export const TokenomicParametersDocument = `
    query TokenomicParameters {
  tokenomicParametersById(id: "0") {
    phaRate
    budgetPerBlock
    vMax
    treasuryRatio
    k
    re
  }
}
    `;
export const useTokenomicParametersQuery = <
      TData = TokenomicParametersQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: TokenomicParametersQueryVariables,
      options?: UseQueryOptions<TokenomicParametersQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<TokenomicParametersQuery, TError, TData>(
      variables === undefined ? ['TokenomicParameters'] : ['TokenomicParameters', variables],
      fetcher<TokenomicParametersQuery, TokenomicParametersQueryVariables>(client, TokenomicParametersDocument, variables, headers),
      options
    );
export const WorkersConnectionDocument = `
    query WorkersConnection($orderBy: [WorkerOrderByInput!]!, $after: String, $first: Int, $where: WorkerWhereInput) {
  workersConnection(
    orderBy: $orderBy
    after: $after
    first: $first
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        stakePool {
          id
          freeStake
        }
        miner {
          id
          isBound
          stake
          state
          v
          ve
          pInit
          pInstant
          totalReward
          coolingDownStartTime
        }
        confidenceLevel
        initialScore
        sMin
        sMax
      }
    }
  }
  globalStateById(id: "0") {
    height
  }
}
    `;
export const useWorkersConnectionQuery = <
      TData = WorkersConnectionQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables: WorkersConnectionQueryVariables,
      options?: UseQueryOptions<WorkersConnectionQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) =>
    useQuery<WorkersConnectionQuery, TError, TData>(
      ['WorkersConnection', variables],
      fetcher<WorkersConnectionQuery, WorkersConnectionQueryVariables>(client, WorkersConnectionDocument, variables, headers),
      options
    );